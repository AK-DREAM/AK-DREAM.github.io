{"meta":{"title":"AK-dream","subtitle":"","description":"","author":"AK-dream","url":"http://akdream.tk","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-10-07T04:20:12.012Z","updated":"2020-02-14T02:09:24.000Z","comments":true,"path":"404.html","permalink":"http://akdream.tk/404.html","excerpt":"","text":"404 Not Found"},{"title":"所有标签","date":"2020-10-07T04:20:12.067Z","updated":"2020-02-12T07:19:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://akdream.tk/tags/index.html","excerpt":"","text":""},{"title":"about 作者","date":"2020-02-11T05:48:57.000Z","updated":"2020-03-04T14:20:12.000Z","comments":true,"path":"about/index.html","permalink":"http://akdream.tk/about/index.html","excerpt":"","text":"蒟蒻OIer一名 只会写C++ 不会Java 不会Python 不会Pascal 不会搞html(鬼知道我怎么把这个站搭起来的) 膜拜各位大佬 因为我是蒟蒻 所以转载请注明出处"},{"title":"友链","date":"2020-10-07T04:20:12.053Z","updated":"2020-02-17T04:36:50.000Z","comments":true,"path":"friends/index.html","permalink":"http://akdream.tk/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"战略游戏[SDOI2018]","slug":"战略游戏-SDOI2018","date":"2021-01-04T14:32:03.000Z","updated":"2021-01-04T14:33:27.220Z","comments":true,"path":"post/b441f3b6.html/","link":"","permalink":"http://akdream.tk/post/b441f3b6.html/","excerpt":"","text":"https://www.luogu.com.cn/problem/P4606 题解每次是试图摧毁一个城市和它连着的所有边，发现如果摧毁的不是一个割点那么就不会有任何影响，所以先建出原图的圆方树 每次选择了若干个关键节点，建出这些关键节点在圆方树上的虚树，有一个显而易见的结论： 答案即为虚树上(包括在虚树的某条边上)所有非关键节点的圆点个数 虚树上所有的叶子节点都一定是关键节点 断掉一个非关键的圆点一定会使得它子树里的一个叶子节点和其它子树外的关键节点不再连通 所以断掉一个非关键的圆点一定满足小Q要求 这题也不需要真的把虚树建出来，预处理圆方树上每个点到根的路径上有多少圆点，查询时只需要统计虚树的每条边上有多少圆点，最后再减掉|S|个关键圆点即为答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;#define N 300005using namespace std;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, ff = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') ff = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * ff; &#125;template &lt;typename T&gt;void write(T num) &#123; if (num &lt; 0) putchar('-'), num = -num; if (num &gt; 9) write(num/10); putchar(num%10+'0');&#125;int ttt, n, P, m, Q, K;int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int dfn[N], dfsx[N], low[N], tme, stk[N], top, pp[N]; vector&lt;int&gt; e[N];int d[N], p[N][21], sum[N];void init_TU() &#123; memset(head, 0, sizeof(head)); sz = 0; &#125;void init_OTHERS() &#123; for (int i = 1; i &lt;= n; i++) e[i].clear(); memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); tme = 0; memset(stk, 0, sizeof(stk)); top = 0; memset(dfsx, 0, sizeof(dfsx)); memset(d, 0, sizeof(d)); memset(p, 0, sizeof(p)); memset(sum, 0, sizeof(sum));&#125;void initALL() &#123; init_TU(); init_OTHERS(); &#125;void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void tarjan(int x) &#123; dfn[x] = low[x] = ++tme; stk[++top] = x; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (low[y] == dfn[x]) &#123; int z = 0; ++n; do &#123; z = stk[top--]; e[z].push_back(n); e[n].push_back(z); &#125; while (z != y); e[x].push_back(n); e[n].push_back(x); &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125;&#125;void dfs(int x, int fa) &#123; dfsx[x] = ++tme; sum[x] = (x &lt;= P) + sum[fa]; for (int l = 1; (1 &lt;&lt; l) &lt;= n; l++) p[x][l] = p[p[x][l-1]][l-1]; for (auto y : e[x]) &#123; if (y == fa) continue; d[y] = d[x] + 1; p[y][0] = x; dfs(y, x); &#125;&#125;inline int LCA(int x, int y) &#123; if (d[x] &lt; d[y]) swap(x, y); for (int i = 20; ~i; i--) if (d[x]-(1&lt;&lt;i)&gt;=d[y]) x = p[x][i]; if (x == y) return x; for (int i = 20; ~i; i--) if (p[x][i] != p[y][i]) x = p[x][i], y = p[y][i]; return p[x][0];&#125; bool cmp(int x, int y) &#123; return dfsx[x] &lt; dfsx[y]; &#125;int solve() &#123; top = 0; int ans = 0; for (int i = 1; i &lt;= K; i++) &#123; if (!top) &#123; stk[++top] = pp[i]; continue; &#125; int lca = LCA(stk[top], pp[i]); while (top &gt; 1 &amp;&amp; dfsx[stk[top-1]] &gt;= dfsx[lca]) &#123; ans += sum[stk[top]]-sum[stk[top-1]]; --top; &#125; if (stk[top] != lca) &#123; ans += sum[stk[top]]-sum[lca]; stk[top] = lca; &#125; stk[++top] = pp[i]; &#125; while (top &gt; 1) &#123; ans += sum[stk[top]]-sum[stk[top-1]]; --top; &#125; ans += (stk[top] &lt;= P); return ans - K;&#125;int main() &#123; read(ttt); while (ttt--) &#123; initALL(); read(n); read(m); P = n; for (int i = 1, u, v; i &lt;= m; i++) &#123; read(u); read(v); addedge(u, v); &#125; tarjan(1); tme = 0; dfs(1, 0); read(Q); for (int kk = 1; kk &lt;= Q; kk++) &#123; read(K); for (int i = 1; i &lt;= K; i++) read(pp[i]); sort(pp + 1, pp + K + 1, cmp); write(solve()); puts(\"\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"强/双连通分量","slug":"强-双连通分量","permalink":"http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"虚树","slug":"虚树","permalink":"http://akdream.tk/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"最佳团体[JSOI2016]","slug":"最佳团体-JSOI2016","date":"2021-01-04T14:30:48.000Z","updated":"2021-01-04T14:34:46.617Z","comments":true,"path":"post/6d3463b1.html/","link":"","permalink":"http://akdream.tk/post/6d3463b1.html/","excerpt":"","text":"https://www.luogu.com.cn/problem/P4322 题解网上怎么这么多O(n^3\\log n)假做法啊。。。一条链就卡掉了 假设0号节点是根 建出表示依赖关系的图 发现正好有n条边且每个点的父亲都比它编号小所以正好是一棵树 那么原问题就是要在树上取一个包含根的性价比最高的连通块 看到”性价比”考虑使用01分数规划 假设x_i\\in \\{0,1\\}表示第i个人选不选 答案是ans 那么 \\dfrac{\\sum x_iP_i}{\\sum x_iS_i} \\le ans挪一下 \\sum x_i(P_i-S_i*ans) \\le 0二分答案mid，如果上方左式可以大于0说明答案小了 否则答案大了 如何求出左式的最大值？ 考虑dp，求出原树的dfs序，设f[i][j]表示考虑到dfs序为i的点，共选了j个点 设V_i=P_i-S_i*mid，a_i是dfs序为i的点的V值 可以选择这个点并且进入它的子树，即 f[i+1][j] = \\max(f[i+1][j], f[i][j-1]+a_i)可以不选这个点，这样它子树里的所有点都不能选了，所以直接跳到下一个在它子树外的点，假设它的dfs序是k： f[k][j]=\\max(f[k][j],f[i][j])这种按dfs序dp的方式常见于求包含根的连通块 先预处理一下每个点的dfs序和下一个它子树外的点的dfs序编号 一次dp是O(n^2)的，总时间O(n^2\\log n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define N 2505using namespace std;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, ff = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') ff = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * ff; &#125;int m, n, a[N], b[N], dfn[N], ed[N], tme = -1;int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;double p[N], f[N][N], ans;inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void dfs(int x, int fa) &#123; dfn[x] = ++tme; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; dfs(y, x); &#125; ed[dfn[x]] = tme;&#125;double check(double k) &#123; for (int i = 0; i &lt;= n+1; i++) &#123; p[dfn[i]] = 1.0 * a[i] - k * b[i]; for (int j = 0; j &lt;= m; j++) f[i][j] = -1e9; &#125; f[0][0] = 0; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; f[ed[i]+1][j] = max(f[ed[i]+1][j], f[i][j]); if (j &gt; 0) f[i+1][j] = max(f[i+1][j], f[i][j-1] + p[i]); &#125; &#125; return f[n+1][m];&#125; int main() &#123; read(m); read(n); ++m; for(int i = 1, x; i &lt;= n; i++) &#123; read(b[i]); read(a[i]); read(x); addedge(x, i); &#125; dfs(0, 0); double l = 0, r = 1e4, mid = 0; while (r - l &gt; 1e-5) &#123; mid = (l + r) / 2; if (check(mid) &gt; 0) &#123; l = mid + 1e-7; &#125; else r = mid - 1e-7; &#125; printf(\"%.3lf\\n\", l); return 0;&#125;","categories":[],"tags":[{"name":"01分数规划","slug":"01分数规划","permalink":"http://akdream.tk/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"按位或[HAOI2015]","slug":"按位或-HAOI2015","date":"2021-01-04T14:28:35.000Z","updated":"2021-01-04T14:45:53.774Z","comments":true,"path":"post/9fcbf1e0.html/","link":"","permalink":"http://akdream.tk/post/9fcbf1e0.html/","excerpt":"","text":"题目描述刚开始你有一个数字0，每一秒钟你会随机选择一个[0,2^n-1]的数字，与你手上的数字进行或（C++, C 的 |， Pascal 的 or）操作。选择数字i 的概率是p[i]（保证0\\le p[i]\\le 1,\\ \\sum p[i]=1） 问期望多少秒后，你手上的数字变成2^n-1。 题解min-max容斥： \\max(S)=\\sum\\limits_{T \\subset S \\cap T \\neq \\varnothing} (-1)^{|T|+1}\\min(T).\\max(S)表示集合S的最大元素 证明大概就是除了\\max(S)剩一个，其他都加加减减消掉了。。。 如果我们设E(x)表示二进制中x这一位第一次变成1的期望步数，则有 .\\max\\limits_{x\\in S}E(x)=\\sum\\limits_{T \\subset S \\cap T \\neq \\varnothing} (-1)^{|T|+1}\\min\\limits_{y\\in T}E(y) .\\max\\limits_{x\\in S}E(x)也就是S中所有位都变成1的期望步数，\\min\\limits_{x\\in S}E(x)即为S中至少有1位变成1的期望步数 考虑后者怎么求，一步就使得S中至少有1位变成1的概率为(1-\\sum\\limits_{i\\cap S=\\varnothing} p[i])，所以期望步数就是\\dfrac{1}{1-\\sum\\limits_{i\\cap S=\\varnothing} p[i]} 假设S_0为S的补集，那么\\sum\\limits_{i\\cap S=\\varnothing} p[i]=\\sum\\limits_{i\\subseteq S_0} p[i]，右式可以用FMT或者状压DP在O(n2^n)的复杂度中求得 那么\\min\\limits_{x\\in S}E(x)=\\dfrac{1}{1-\\sum\\limits_{i\\subseteq S_0} p[i]}然后套用上面的minmax容斥即可 答案即为\\max\\limits_{x\\in S}E(2^n-1) 无解判断方法很多也很好判断就不说了 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define N 1100005using namespace std;typedef long long ll;int n;double a[N], ans;void FWT(double *F) &#123; for (int i = 1; i &lt; (1&lt;&lt;n); i&lt;&lt;=1) &#123; for (int p = i&lt;&lt;1, j = 0; j &lt; (1&lt;&lt;n); j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; double x = F[j+k], y = F[j+k+i]; F[j+k] = x; F[j+k+i] = x + y; &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; (1&lt;&lt;n); i++) scanf(\"%lf\", &amp;a[i]); FWT(a); for (int i = 1; i &lt; (1&lt;&lt;n); i++) &#123; if (1.0-a[((1&lt;&lt;n)-1)^i] &lt;= 1e-8) &#123; puts(\"INF\"); return 0; &#125; if (__builtin_popcount(i) &amp; 1) ans += 1.0 / (1.0-a[((1&lt;&lt;n)-1)^i]); else ans -= 1.0 / (1.0-a[((1&lt;&lt;n)-1)^i]); &#125; printf(\"%.10lf\", ans); return 0;&#125;","categories":[],"tags":[{"name":"FWT","slug":"FWT","permalink":"http://akdream.tk/tags/FWT/"}]},{"title":"无归岛[HNOI2009]","slug":"无归岛-HNOI2009","date":"2021-01-04T14:27:21.000Z","updated":"2021-01-04T14:46:24.047Z","comments":true,"path":"post/61f3b981.html/","link":"","permalink":"http://akdream.tk/post/61f3b981.html/","excerpt":"","text":"题目描述https://www.luogu.com.cn/problem/P4410 题解原图显然是一个仙人掌(似乎还有些别的性质 但是其实没什么必要) 先考虑树的情况，题意即为不能同时选择相邻的两点，设f[x][0/1]表示选/不选x时，x子树内的最大战斗力 f[x][0]=\\max\\limits_{y\\in son(x)} (\\max(f[y][0],f[y][1]))f[x][1]=\\max\\limits_{y\\in son(x)} (f[y][0]) + A_x在环上如何dp？ 在环上找到一个点x并从那里把环断开，分x选或x不选两种，分别进行dp来推出f[x][0/1]即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define N 500005using namespace std;int n, m, ans, a[N], f[N][2];int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;int dfn[N], low[N], stk[N], top, c[N], tot, tme;void solve(int x) &#123; int a0 = 0, a1 = 0, b0 = 0, b1 = -0x3f3f3f3f; //不选x for (int i = 1; i &lt;= tot; i++) &#123; a0 = max(b0, b1) + f[c[i]][0]; a1 = b0 + f[c[i]][1]; b0 = a0; b1 = a1; &#125; f[x][0] += max(b0, b1); a0 = a1 = 0; b0 = -0x3f3f3f3f; b1 = 0; //选择x for (int i = 1; i &lt;= tot; i++) &#123; a0 = max(b0, b1) + f[c[i]][0]; a1 = b0 + f[c[i]][1]; b0 = a0; b1 = a1; &#125; f[x][1] += b0;&#125;void tarjan(int x) &#123; dfn[x] = low[x] = ++tme; stk[++top] = x; f[x][1] = a[x]; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] == low[y]) &#123; int u = 0; tot = 0; do &#123; u = stk[top--]; c[++tot] = u; &#125; while (u != y); solve(x); &#125; else if (dfn[x] &lt; low[y]) &#123; f[x][0] += max(f[y][0], f[y][1]); f[x][1] += f[y][0]; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) &#123; scanf(\"%d %d\", &amp;u, &amp;v); addedge(u, v); &#125; for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); tarjan(1); printf(\"%d\\n\", max(f[1][0], f[1][1])); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"仙人掌","slug":"仙人掌","permalink":"http://akdream.tk/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"}]},{"title":"仓库建设[ZJOI2007]","slug":"仓库建设-ZJOI2007","date":"2020-12-13T11:53:33.000Z","updated":"2020-12-22T11:44:52.354Z","comments":true,"path":"post/4cbc3c7c.html/","link":"","permalink":"http://akdream.tk/post/4cbc3c7c.html/","excerpt":"","text":"题目描述https://www.luogu.com.cn/problem/P2120 题解设S_i=\\sum\\limits_{j=1}^{i} p_j，T_i=\\sum\\limits_{j=1}^{i} p_j*a_j $S_i$即为前i个工厂的物品总数，T_i为前i个工厂都把所有物品运到工厂1的总花费（虽然不能运到仓库1） 设f_i表示把前i个工厂的物品都运到仓库里且在i工厂处建立仓库的最小花费 则有f_i=\\min\\limits_{1\\le j < i} f_j + a_i * (S_i-S_j) - (T_i-T_j) + c_i 变化一下式子就是(f_j+T_j)=a_i*S_j+(F_i-a_i*S_i-c_i+T_i) 使用斜率优化即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, head, tail, q[N];ll a[N], p[N], c[N], dp[N], sum[N], sum2[N], K[N];inline ll getx(int id) &#123; return sum[id];&#125;inline ll gety(int id) &#123; return dp[id] + sum2[id];&#125;inline double slope(int x, int y) &#123; return getx(x) == getx(y) ? 1e15 : 1.0 * (gety(x) - gety(y)) / (getx(x) - getx(y));&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); read(p[i]); read(c[i]); sum[i] = sum[i-1] + p[i]; sum2[i] = sum2[i-1] + a[i] * p[i]; K[i] = a[i]; &#125; q[head=tail=1] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (head &lt; tail &amp;&amp; slope(q[head], q[head+1]) &lt; K[i]) head++; int j = q[head]; dp[i] = dp[j] + a[i] * (sum[i] - sum[j]) - (sum2[i] - sum2[j]) + c[i]; while (head &lt; tail &amp;&amp; slope(q[tail-1], q[tail]) &gt; slope(q[tail], i)) tail--; q[++tail] = i; &#125; printf(\"%lld\\n\", dp[n]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"征途[SDOI2016]","slug":"征途-SDOI2016","date":"2020-12-11T13:48:10.000Z","updated":"2020-12-22T10:29:06.230Z","comments":true,"path":"post/d391bdf.html/","link":"","permalink":"http://akdream.tk/post/d391bdf.html/","excerpt":"","text":"题目描述Pine 开始了从S地到T地的征途。 从S地到T地的路可以划分成h段，相邻两段路的分界点设有休息站。Pine 计划用m天到达T地。除第n天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。Pine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。 帮助 Pine 求出最小方差是多少。 设方差是v，可以证明，v*m^2是一个整数。为了避免精度误差，输出结果时输出v*m^2。 输入格式第一行两个数n、m。第二行n个数，表示n段路的长度。 题解CCF不考DP了(悲) 假设有一个序列a_1\\sim a_n，平均数是v，那么它的方差就是\\dfrac{\\sum\\limits_{i=1}^{n}(a_i)^2}{n}-v^2 所以原问题就变成：将n个数分为m段，假设第i段内的所有数之和为b_i，求\\sum\\limits_{i=1}^{m} (b_i)^2的最小值 设f_{i,j}表示将前j个数分成i段的最小平方和 容易得到转移方程：f_{i,j} = \\min\\limits_{0\\le k","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"区间[NOI2016]","slug":"区间-NOI2016","date":"2020-12-04T11:31:41.000Z","updated":"2020-12-04T11:33:44.105Z","comments":true,"path":"post/ba8b5f94.html/","link":"","permalink":"http://akdream.tk/post/ba8b5f94.html/","excerpt":"","text":"题目描述在数轴上有n个闭区间从1至n编号，第i个闭区间为[l_i,r_i] 现在要从中选出m个区间，使得这m个区间共同包含至少一个位置。换句话说，就是使得存在一个x，使得对于每一个被选中的区间[l_i,r_i] 对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间[l_i,r_i]的长度定义为(r_i-l_i)即等于它的右端点的值减去左端点的值。 求所有合法方案中最小的花费。如果不存在合法的方案，输出−1。 输入格式第一行包含两个整数，分别代表n和m。 第2到第(n + 1)行，每行两个整数表示一个区间，第(i + 1)行的整数l_i, r_i分别代表第i个区间的左右端点。 输出格式输出一行一个整数表示答案。 题解将区间按长度从小到大排序，记为p_1,p_2,\\cdots p_n 假设最后选的区间中长度最短和最长的分别是p_l, p_r，那么答案就是p_r的长度减p_l的长度，在p_{l+1}\\sim p_{r-1}中选哪些并不会给答案造成影响 判定一个答案是否合法的方法：假设现在有一个长度为1e9的序列，每个位置的值都是0，如果我们对于p_l \\sim p_r的每个区间，都把这个区间中的每个位置+1，那么操作完后如果有某个位置的值大于m，那么就说明这个位置被p_l \\sim p_r中的至少m个区间覆盖了，也就是说存在一种合法方案只选择了m个p_l\\sim p_r中的区间，就可以用 (p_r的长度减p_l的长度) 来更新答案 如果选择的最短区间为p_l时，使得代价最小的方案中选择的的最长区间是p_r，那么选择的最短区间固定为p_{l+1}时，此时的最优方案选择的最长区间一定比p_r长 证明：假设最短区间固定为p_{l+1}时，此时的最优方案选择的最长区间是p_k，且k < r，那么按照上面那个判合法性的方法，选择p_l\\sim p_k也一定是合法的，矛盾 所以可以使用双指针的方法，每次固定左指针(即最短区间)，然后移动右指针找到第一个满足条件的最长区间，然后更新答案 上面的判定合法的方法需要区间加，查询全局最大值，用线段树维护即可 为方便线段树维护，可以先给区间端点进行离散化 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, m, len[N], srt[N], mx;struct intv &#123; int l, r;&#125; p[N];bool cmp(intv x, intv y) &#123; return x.r-x.l &lt; y.r-y.l; &#125;void fCuCcFk() &#123; for (int i = 1; i &lt;= n; i++) srt[++mx] = p[i].l, srt[++mx] = p[i].r; sort(srt+1, srt+mx+1); mx = unique(srt+1, srt+mx+1) - srt - 1; for (int i = 1; i &lt;= n; i++) &#123; len[i] = p[i].r - p[i].l + 1; p[i].l = lower_bound(srt+1, srt+mx+1, p[i].l) - srt; p[i].r = lower_bound(srt+1, srt+mx+1, p[i].r) - srt; &#125; &#125;struct segtree &#123; int mx, tag;&#125; tr[N&lt;&lt;2];void build(int ind, int l, int r) &#123; tr[ind].mx = tr[ind].tag = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(ind&lt;&lt;1, l, mid); build(ind&lt;&lt;1|1, mid+1, r);&#125;inline void pushdown(int ind) &#123; if (!tr[ind].tag) return; int v = tr[ind].tag; tr[ind].tag = 0; tr[ind&lt;&lt;1].mx += v; tr[ind&lt;&lt;1].tag += v; tr[ind&lt;&lt;1|1].mx += v; tr[ind&lt;&lt;1|1].tag += v;&#125;void update(int ind, int l, int r, int x, int y, int v) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].mx += v; tr[ind].tag += v; return; &#125; pushdown(ind); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(ind&lt;&lt;1, l, mid, x, y, v); if (mid &lt; y) update(ind&lt;&lt;1|1, mid+1, r, x, y, v); tr[ind].mx = max(tr[ind&lt;&lt;1].mx, tr[ind&lt;&lt;1|1].mx);&#125;int main() &#123; read(n); read(m); for (int i = 1; i &lt;= n; i++) &#123; read(p[i].l); read(p[i].r); &#125; sort(p + 1, p + n + 1, cmp); fCuCcFk(); int ans = 0x3f3f3f3f; build(1, 1, mx); update(1, 1, mx, p[1].l, p[1].r, 1); for (int i = 1, j = 1; i &lt;= n; i++) &#123; while (j &lt; n &amp;&amp; tr[1].mx &lt; m) &#123; j++; update(1, 1, mx, p[j].l, p[j].r, 1); &#125; if (tr[1].mx &gt;= m) ans = min(ans, len[j] - len[i]); update(1, 1, mx, p[i].l, p[i].r, -1); &#125; printf(\"%d\\n\", ans == 0x3f3f3f3f ? -1 : ans); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"文件路径[BOI2015]","slug":"文件路径-BOI2015","date":"2020-12-04T11:27:34.000Z","updated":"2020-12-04T11:33:44.107Z","comments":true,"path":"post/832a20d9.html/","link":"","permalink":"http://akdream.tk/post/832a20d9.html/","excerpt":"","text":"题目描述https://www.luogu.com.cn/problem/P6843 题解题目实际在求这样一个东西：给定一棵树和边权，你可以在树中加上一条长为S的有向边 对于每个叶子节点问：是否能构造出一条从根节点出发以该节点为终点的长为K的路径 设有一个叶子节点x 情况1根到x的路径长等于`$K$ 那显然答案就是 Yes 情况2走了一次附加的有向边使得路径长为`$K$ 考虑这条有向边的终点在哪里：由于走过这条有向边之后还要从它的终点走到x$，所以有向边的终点一定要是`$x的一个祖先 记点p的深度是d_p$，那么假设走了一条`$p\\rightarrow q的有向边，总长度就是`$d_p+S+(d_x-d_q)$ 其中，$p$是树上的任意一个非叶子节点，$q$必须是x的祖先 要判断是否有p,q满足d_p+S+(d_x-d_q)=K，可以考虑枚举q，这样就确定了d_x-d_q，预处理出d_p+S可以取哪些值(存在一个 bool 数组里)，如果存在某个p使得d_p+S=K-(d_x-d_q)那么x的答案就是 Yes 一个例子 情况3当然，可能可以走很多次附加的有向边(在一个环上一直绕) 如果一条有向边可以走很多次，那么必须满足它的终点是起点的祖先 又因为终点要是x的祖先，所以现在需要找到这样一条路径p\\rightarrow q： 满足d_x+t*(d_p-d_q+S)=K(t为一个正整数) 其中q是x的祖先，p是q子树中一个非叶子节点 在dfs时，每到一个非叶子节点就再把以它为根的子树遍历一遍，把所有合法的d_p-d_q+S存在 bool 数组里，并在回溯时清除贡献 枚举K-d_x的所有约数，判断是否有满足条件的d_p-d_q+S即可 时间复杂度O((n+m)^2+m\\sqrt{K}) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define N 20005using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, ff = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') ff = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * ff;&#125;int n, ccf, K, S, a[N], d[N];int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int ok[1000005], ok2[1000005], ans[N];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void dfs1(int x, int fa) &#123; if (d[x]+S &lt;= 1000000 &amp;&amp; x &lt;= ccf) ok[d[x]+S]++; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; d[y] = d[x] + a[y]; dfs1(y, x); &#125;&#125; void dfs3(int x, int fa, int rt, int v) &#123; if (x &gt; ccf) return; int now = d[x] - d[rt] + S; if (now &lt;= 1000000) ok2[now] += v; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y != fa) dfs3(y, x, rt, v); &#125;&#125;int stk[N], top;void solve(int x) &#123; if (d[x] == K) &#123; ans[x] = 1; return; &#125; for (int i = 1; i &lt;= top; i++) &#123; int y = stk[i]; int v = d[x] - d[y]; if (v &lt;= K &amp;&amp; ok[K-v]) ans[x] = 1; &#125; if (d[x] &lt; K) &#123; int v = K - d[x]; for (int i = 1; i * i &lt;= v; i++) &#123; if (v % i == 0) &#123; if (ok2[i] || ok2[v/i]) ans[x] = 1; &#125; &#125; &#125;&#125;void dfs2(int x, int fa) &#123; if (x &gt; ccf) &#123; solve(x); return; &#125; stk[++top] = x; dfs3(x, fa, x, 1); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y != fa) dfs2(y, x); &#125; dfs3(x, fa, x, -1); top--;&#125;int main() &#123; read(n); read(ccf); read(K); read(S); S++; swap(ccf, n); n += ccf; for (int i = 1, p; i &lt;= n; i++) &#123; read(p); read(a[i]); a[i]++; addedge(p, i); &#125; dfs1(0, 0); dfs2(0, 0); for (int i = ccf + 1; i &lt;= n; i++) puts(ans[i]?\"YES\":\"NO\"); return 0;&#125;","categories":[],"tags":[]},{"title":"仙人掌[ZJOI2017]","slug":"仙人掌-ZJOI2017","date":"2020-11-29T14:18:56.000Z","updated":"2020-11-29T14:31:31.817Z","comments":true,"path":"post/75f14cc2.html/","link":"","permalink":"http://akdream.tk/post/75f14cc2.html/","excerpt":"","text":"题目描述https://www.luogu.com.cn/problem/P3687 题面里咋还有张图啊，就不放这了 题解首先，如果原图不是仙人掌，显然答案为0 如果原图是一棵树，那么我们可以选择若干条边不相交的路径，如果某条路径长度大于一，就将路径的两个端点间加一条边，那么这样构造出来的图一定是一个仙人掌 所以原问题实际在问有多少种方案用若干条边不相交的路径覆盖原图 设f[x]表示考虑x的子树内和x到父亲的那条边，有多少种方案把这些边划分成若干条路径 假设x有k个儿子，那么如果x不为根，就有k+1条从x连出的边，这些边可以两两配对连接形成穿过x的路径，也可以不配对 设p_i表示将i条边两两配对(或不配对)有多少种方案，考虑最后一条边是否和另一条边配对，易得递推式：p_i=p_{i-1}+(i-1)*p_{i-2} 那么对于树边，有f[x]=(\\prod\\limits_{y\\in son(x)} f[y]) * p_{k+1}(如果x是根那么最后乘的应该是p_k) 如果原图不是树而是仙人掌呢？ 考虑仙人掌上的环，从上面那个”路径覆盖”的角度思考，发现环的要求就是环上的边不能被路径覆盖，而树边必须被覆盖 所以直接把所有环上的边删掉得到一个森林，把每棵树的根的答案乘在一起就是最终答案了 当然这样做有点麻烦，维护一个g[x]表示只考虑x的子树内的边 (x到父亲的边可能是环边)，有多少种方案把这些边划分成若干条路径 然后在碰到环时特殊处理一下即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, ff = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') ff = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * ff;&#125;const ll mod = 998244353;int ttt, n, m;int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int dfn[N], low[N], stk[N], top, c[N], tot, tme;ll f[N], g[N], p[N];bool tmp[N], flag;inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void init() &#123; for (int i = 1; i &lt;= n; i++) head[i] = 0; sz = 0; for (int i = 1; i &lt;= n; i++) dfn[i] = low[i] = 0, f[i] = 0; tme = top = 0; flag = 0;&#125;void solve(int X) &#123; //判断是否是仙人掌 for (int i = 1; i &lt;= tot; i++) tmp[c[i]] = 1; int cnt = 0; for (int i = 1; i &lt;= tot; i++) &#123; int x = c[i]; for (int j = head[x]; j; j = pre[j]) if (tmp[to[j]]) cnt++; &#125; if (cnt != tot * 2) flag = 1; for (int i = 1; i &lt;= tot; i++) tmp[c[i]] = 0; // //维护DP值 for (int i = 1; i &lt; tot; i++) f[X] = f[X] * g[c[i]] % mod; //c[1]~c[tot-1]为环上除x之外的其它点 //&#125;void tarjan(int x) &#123; dfn[x] = low[x] = ++tme; stk[++top] = x; f[x] = 1; int cnt = 0; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] == low[y]) &#123; int z = 0; tot = 0; do &#123; z = stk[top--]; c[++tot] = z; &#125; while (z != y); c[++tot] = x; if (tot &gt; 2) solve(x); //找到环 else &#123; cnt++; f[x] = f[x] * f[y] % mod; &#125; &#125; &#125; else low[x] = min(low[x], dfn[y]); &#125; g[x] = f[x] * p[cnt] % mod; f[x] = f[x] * p[cnt+(x!=1)] % mod;&#125;int main() &#123; read(ttt); p[0] = p[1] = 1; for (int i = 2; i &lt;= 500000; i++) p[i] = (p[i-1] + p[i-2] * (i-1) % mod) % mod; while (ttt--) &#123; read(n); read(m); for (int i = 1, u, v; i &lt;= m; i++) &#123; read(u); read(v); addedge(u, v); &#125; tarjan(1); if (flag) puts(\"0\"); else printf(\"%lld\\n\", f[1]); init(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"寻找车位[Code+#3]","slug":"寻找车位-Code-3","date":"2020-11-28T14:10:40.000Z","updated":"2020-11-28T14:13:28.143Z","comments":true,"path":"post/e3b2cbf5.html/","link":"","permalink":"http://akdream.tk/post/e3b2cbf5.html/","excerpt":"","text":"题目描述access_globe 有一个巨大的停车场，这个停车场有N行，每行有M个车位。为了美观，access_globe 在建立这个停车场时，规定这个停车场必须是长条形的，即N\\ge M。每个车位都是一个正方形的区域。 最近，access_globe 正在为抽不到 Missing Poster 而苦恼，因此他请你帮他维护这个停车场。你需要支持两个事件： 一辆车停到某一个车位中，或一辆车从某个车位开走 查询一个矩形区域内最大的只包含空车位的正方形区域 如果你能帮 access_globe 高效地解决这个问题，access_globe 一定会好好奖励你的。 N \\times M \\le 4*10^6,Q\\le 2000题解线段树神题 对N这一维开一棵线段树，然后线段树上的每个节点维护3个数组：lm[M], rm[M], val[M] 假设线段树的某个节点表示的是[l,r]这段区间 (1\\le l\\le r\\le N) ，那么这个节点的 lm[i] 表示第i列中，从第l个车位开始往后数有多少个连续的1，rm[i] 表示从第r个车位往前数有多少个连续的`$1$ 这个节点的 val[i] 表示如果以第i列作为正方形的右边界，且正方形的上下边界在[l,r]内 (这里的l,r实际上是竖着的一段区间) ，全1的正方形的边长最大是多少 lm[M] 和 rm[M] 都很容易通过左右儿子的值求出来，如何求出 val[M] ? 假设mid=\\dfrac{l+r}{2}，先考虑这个正方形的上下边界都在[l,mid]或者都在`$[mid+1,r]$ 显然此时 val[i] 等于左右儿子的 val[i] 的较大值 如果正方形跨过了mid呢? 假设我们现在已经知道了正方形的上下边界在[l,r]内，如果正方形的右边界在i，左边界在j(即边长为i-j+1) ，如何判断是否存在合法的正方形？ 如图 我们对于[j,i]中的每一列，找到从第mid行开始有多少个向上延申的连续的1(蓝线)，同理找到向下延申的，然后分别找到向上和向下最少的 (绿线) ， 记为a,b，如果i-j+1\\le a+b，就表示一定存在合法的正方形 容易发现如果以i为右边界可以构成的最大全1正方形的左边界在j，那么以i+1为右边界可以构成的最大全1正方形的左边界不可能小于j 所以这个每次查询区间[j,i]的最小值可以使用单调队列来维护，枚举右端点i并且维护另外一个指针j，如果此时i-j+1大于上下两个最小值之和，那就说明不满足条件，j继续右移，找到第一个满足条件的j，那么[l,r]这个线段树节点的 val[i] 就等于j 这样就通过合并左右儿子两个区间算出了当前节点的值了 注意这样 pushup 一次的复杂度是O(m)的，所以进行一次修改或查询 那么怎么查询答案呢？ 假设询问是x1,y1,x2,y2，将[x1,x2]在线段树上分为\\log N个区间，然后在线段树上合并这些区间即可 一种比较聪明的做法是用一个没有用的节点暂时储存一下这\\log N个区间合并得到的答案，最后只需要找出这个临时节点 val[y1] 到 val[y2] 之间的最大值即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define N 4000005using namespace std;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, m, Q;int len[N&lt;&lt;2], q1[N], q2[N];vector&lt;int&gt; A[N];int lm[N&lt;&lt;2], rm[N&lt;&lt;2], val[N&lt;&lt;2];inline int o(int x, int y) &#123; return x*m+y; &#125; inline void merge(int ind, int ls, int rs) &#123; int h1 = 1, h2 = 1, t1 = 0, t2 = 0; for (int r = 1, l = 1; r &lt;= m; r++) &#123; while (h1 &lt;= t1 &amp;&amp; rm[o(ls,q1[t1])] &gt; rm[o(ls,r)]) t1--; q1[++t1] = r; while (h2 &lt;= t2 &amp;&amp; lm[o(rs,q2[t2])] &gt; lm[o(rs,r)]) t2--; q2[++t2] = r; while (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; rm[o(ls,q1[h1])] + lm[o(rs,q2[h2])] &lt; r-l+1) &#123; if (q1[h1] == l) h1++; if (q2[h2] == l) h2++; l++; &#125; val[o(ind,r)] = max(max(val[o(ls,r)], val[o(rs,r)]), r-l+1); &#125; for (int i = 1; i &lt;= m; i++) lm[o(ind,i)] = lm[o(ls,i)] + (lm[o(ls,i)]==len[ls]?lm[o(rs,i)]:0); for (int i = 1; i &lt;= m; i++) rm[o(ind,i)] = rm[o(rs,i)] + (rm[o(rs,i)]==len[rs]?rm[o(ls,i)]:0);&#125;void build(int ind, int l, int r) &#123; len[ind] = r-l+1; if (l == r) &#123; for (int i = 1; i &lt;= m; i++) lm[o(ind,i)] = rm[o(ind,i)] = val[o(ind,i)] = A[l][i]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(ind&lt;&lt;1, l, mid); build(ind&lt;&lt;1|1, mid+1, r); merge(ind, ind&lt;&lt;1, ind&lt;&lt;1|1);&#125;void update(int ind, int l, int r, int x, int y, int v) &#123; if (l == r) &#123; lm[o(ind,y)] = rm[o(ind,y)] = val[o(ind,y)] = v; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(ind&lt;&lt;1, l, mid, x, y, v); else update(ind&lt;&lt;1|1, mid+1, r, x, y, v); merge(ind, ind&lt;&lt;1, ind&lt;&lt;1|1);&#125;void query(int ind, int l, int r, int x, int y) &#123; int ret = 0; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; merge(0, 0, ind); //用0号点暂时储存答案 return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) query(ind&lt;&lt;1, l, mid, x, y); if (mid &lt; y) query(ind&lt;&lt;1|1, mid+1, r, x, y);&#125;int main() &#123; read(n); read(m); read(Q); for (int i = 1; i &lt;= n; i++) A[i].resize(m+1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; read(A[i][j]); &#125; build(1, 1, n); for (int i = 1, tp, x, y, a, b; i &lt;= Q; i++) &#123; read(tp); if (tp == 0) &#123; read(x); read(y); if (A[x][y]) update(1, 1, n, x, y, 0); else update(1, 1, n, x, y, 1); A[x][y] = 1 - A[x][y]; &#125; else &#123; read(x); read(y); read(a); read(b); for (int j = 1; j &lt;= m; j++) &#123; lm[o(0,j)] = rm[o(0,j)] = val[o(0,j)] = 0; //用0号点暂时储存答案 &#125; query(1, 1, n, x, a); int ans = 0; for (int j = y; j &lt;= b; j++) &#123; ans = max(ans, min(j-y+1, val[o(0, j)])); &#125; printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"快餐店[NOI2013]","slug":"快餐店-NOI2013","date":"2020-11-28T14:06:43.000Z","updated":"2020-11-28T14:10:02.208Z","comments":true,"path":"post/500a1398.html/","link":"","permalink":"http://akdream.tk/post/500a1398.html/","excerpt":"","text":"题目描述小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。 快餐店的顾客分布在城市 C 的N个建筑中，这N个建筑通过恰好N条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。 现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。 题解首先考虑一棵树上答案是怎样的：答案应该是树直径的\\dfrac{1}{2}，即快餐店取在直径一半处，证明如下： 如果快餐店不在直径的中点处，而是在某点X，假设直径是A\\rightarrow B，长度为d ，那么树上离X最远的点要么是A要么是B，只有\\operatorname{dis}(A,X)","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"贪吃蛇[CSP2020]","slug":"贪吃蛇-CSP2020","date":"2020-11-12T09:55:28.000Z","updated":"2020-11-12T10:28:40.449Z","comments":true,"path":"post/8edb7c14.html/","link":"","permalink":"http://akdream.tk/post/8edb7c14.html/","excerpt":"","text":"题面https://www.luogu.com.cn/problem/P7078 题解考场上开T4的时候只有40~50分钟了 努力思索了10分钟想到一个结论(中途想假了一次) 然后发现部分分还挺多：70分 70分简单说说70分做法：先假设游戏一直进行，那么就可以用set把每轮游戏是谁吃谁处理出来 显然游戏共有n-1轮，从最后一轮开始向前扫，假设当前到第i轮，是A吃掉B，记t为第i\\sim n-1轮中第一次有蛇叫停是在第几轮(初始时$t=n$)，同时记录d_x表示若游戏一直进行则第x条蛇在第d_x轮被吃掉，那么如果d_A < t就表示A如果这一轮吃了B，那它在后面一定会被吃掉，所以A必须叫停，更新t为i，否则不更新 最终答案即为n-t+1，复杂度O(Tn\\log n) 100分如何O(n)把上面set求的东西求出来？ 这题的做法和NOIP2016蚯蚓比较像，通过维护多个普通队列来存取最小/最大值 具体地说，维护两个普通队列，一个初始时装着排好序的所有元素，一个初始为空 每次操作时，分别找出两个队列的队头元素，取其中较小者即是当前的最小元素，最大元素同理取队尾 然后把最大减最小的那个元素放到第二个队列的队头 只要两个队列都具有单调性，这个做法就是对的 显然只出不进的队列1时刻具有单调性 考虑队列2 整个n-1轮分为两个阶段 假设第i轮场上最大的蛇是A_i，最小是B_i 1.A_i\\ge 2*B_i 那么显然有A_{i+1}\\le A_i,B{i+1}\\ge B_i 假设C_i是A_i吃B_i得到的那条蛇，那么有C_i\\ge C_{i+1} 当C_i>C_{i+1}时，队列2就是有单调性的了 当C_i=C_{i+1}时，一定有A_i=A_{i+1}，那么要不A_i和A_{i+1}两次其实都是标号相同的那条蛇(即C_i作为A_{i+1}被弹出队列2了)，要不A_i的标号大于A_{i+1}也就是说C_i的标号大于C_{i+1}，两种情况都满足队列2的单调性 至此证明了阶段1中队列2是有单调性的 2.A_i","categories":[],"tags":[]},{"title":"函数调用[CSP2020]","slug":"函数调用-CSP2020","date":"2020-11-09T13:17:58.000Z","updated":"2020-11-10T09:29:39.678Z","comments":true,"path":"post/aad8b10f.html/","link":"","permalink":"http://akdream.tk/post/aad8b10f.html/","excerpt":"","text":"题目描述https://www.luogu.com.cn/problem/P7077 题解第一眼看像是数据结构题？ 后来发现这题压根不用数据结构 考虑对于给出的操作建一个图：对于所有操作3，按顺序向它调用的函数连边，这样会得到一个DAG 对于乘法操作，在最后给所有数组元素乘上就好了，关键在于每个加法操作最后乘了一个多大的系数 假设整个数组只有一个元素，对它依次执行：+1, *3, +2, *2 那么+1操作实际上就有一个2*3=6的系数，+2有2的系数，所以假设原来这个元素是$x$，那它最后会是$6x+1\\times 6+ 2\\times 2$ 发现一个加法操作带的系数就等于它后面的所有乘法操作之积，所以可以倒着进行操作，一边记录已进行的所有乘法操作的积是多少，这样就能计算出每次加法操作带的系数是多少 至此，只含1,2操作的情况就处理完了，接下来考虑3操作 对于图上的每个点(代表着一种操作)，维护一个mul属性，表示执行一次这个操作会给累计的积乘上多少 对于1类操作，它的mul=1；对于2类操作，它的mul就等于它要乘上的值；而对于3类操作，它的mul等于它直接连向的所有点的mul之积 如图，点2的mul为2，点3的mul为3，所以点1的mul为6，那么执行一次操作1就会让前面执行过的所有的加法操作再乘上6的系数 按照拓扑序倒序扫一遍或者直接dfs即可处理出mul 然后倒着进行$q$次操作，就可以求得每次操作(类型1或3)带着多少系数，记作sum，然后再把类型3的节点的sum下传到它所包含的类型1节点即可 但是有些类型3的操作既包含加法又包含乘法怎么办？ 考虑这样一张图 假设编号为1的操作的sum是$x$，那么+2这个操作的sum应该额外增加$3x$，同理+1的sum应增加$12x$ 所以下传sum时，假设一个点$x$的sum是$S$，它的儿子是$y_1,y_2,\\cdots y_k$，那么$y_i$的sum就应该增加$S$乘上$y_{i+1}\\sim y_k$的mul之积 最后，让数组的每个元素乘上所有$q$次操作的mul，再遍历所有加法操作计算应该加多少即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()); for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x; &#125;const ll mod = 998244353;int n, m, Q, F[N];int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz, inde[N];ll a[N];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; inde[v]++;&#125;struct oper &#123; int tp, p; ll v, mul, sum; &#125; b[N];queue&lt;int&gt; q;int ord[N], bnbn;void toposort() &#123; //拓扑排序 for (int i = 1; i &lt;= m; i++) if (!inde[i]) q.push(i); while (!q.empty()) &#123; int x = q.front(); q.pop(); ord[++bnbn] = x; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; inde[y]--; if (!inde[y]) q.push(y); &#125; &#125;&#125;void getmul() &#123; //计算节点的mul for (int i = m; i; i--) &#123; int x = ord[i]; for (int j = head[x]; j; j = pre[j]) &#123; int y = to[j]; b[x].mul = b[x].mul * b[y].mul % mod; &#125; &#125; &#125;void getsum() &#123; //下传节点的sum for (int i = 1; i &lt;= m; i++) &#123; int x = ord[i]; ll now = 1; for (int j = head[x]; j; j = pre[j]) &#123; int y = to[j]; b[y].sum = (b[y].sum + b[x].sum * now % mod) % mod; now = now * b[y].mul % mod; &#125; &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) read(a[i]); read(m); for (int i = 1; i &lt;= m; i++) &#123; read(b[i].tp); if (b[i].tp == 1) &#123; read(b[i].p); read(b[i].v); b[i].mul = 1; &#125; else if (b[i].tp == 2) &#123; read(b[i].v); b[i].mul = b[i].v; &#125; else &#123; read(b[i].p); b[i].mul = 1; for (int j = 1, x; j &lt;= b[i].p; j++) &#123; read(x); addedge(i, x); &#125; &#125; &#125; toposort(); getmul(); read(Q); ll now = 1; for (int i = 1; i &lt;= Q; i++) read(F[i]); for (int i = Q; i; i--) &#123; int x = F[i]; b[x].sum = (b[x].sum + now) % mod; now = now * b[x].mul % mod; &#125; getsum(); for (int i = 1; i &lt;= n; i++) a[i] = a[i] * now % mod; for (int i = 1; i &lt;= m; i++) &#123; if (b[i].tp == 1) &#123; a[b[i].p] = (a[b[i].p] + b[i].v * b[i].sum % mod) % mod; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf(\"%lld \", a[i]); return 0; &#125;","categories":[],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://akdream.tk/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"动物园[CSP2020]","slug":"动物园-CSP2020","date":"2020-11-09T13:17:32.000Z","updated":"2020-11-09T13:20:51.349Z","comments":true,"path":"post/ad950814.html/","link":"","permalink":"http://akdream.tk/post/ad950814.html/","excerpt":"","text":"题面https://www.luogu.com.cn/problem/P7076 题解这应该是最签到的一题了吧 饲料共有$c$种，1e8存不下，先对饲料编号进行重新标号 注意这里并不需要进行离散化(排序去重)，由于$q_i$互不相同，所以只需要把第$i$种饲料的编号看作$i$即可 (什么叫签到题啊) 首先对于已有的动物，先处理出$K$位中哪些位有动物是1 然后扫一遍所有要求找出哪些饲料必买 最后再扫一遍所有要求算出$K$位中哪些位可以是1 假设有$x$位可以是1，那答案就是$2^x-n$ 注意点： 答案可能爆long long 需要unsigned long long 如果$n=m=0,k=64$，那么答案为$2^64$，会爆unsigned long long。。。需要特判 感觉会在2处挂5pts。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 1000005using namespace std;typedef unsigned long long ull;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()); for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x; &#125;int n, m, c, k, p[N];ull a[N], S, ans, fst;bool buy[N], ok[N];void solvebuy() &#123; for (int i = 1; i &lt;= m; i++) &#123; if ((S&gt;&gt;p[i])&amp;1) buy[i] = 1; &#125;&#125;void solveans() &#123; for (int i = 0; i &lt; k; i++) ok[i] = 1; for (int i = 1; i &lt;= m; i++) &#123; if (!buy[i]) ok[p[i]] = 0; &#125; int cnt = 0; for (int i = 0; i &lt; k; i++) if (ok[i]) cnt++; if (cnt == 64) &#123; ans = (1ull &lt;&lt; 63) - n + (1ull &lt;&lt; 63); &#125; else ans = (1ull &lt;&lt; cnt) - n;&#125; int main() &#123; read(n); read(m); read(c); read(k); if (!n &amp;&amp; !m &amp;&amp; k == 64) &#123; puts(\"18446744073709551616\"); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); S |= a[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; read(p[i]); read(fst); &#125; solvebuy(); solveans(); cout &lt;&lt; ans &lt;&lt; endl; //%lld好像不太行 return 0;&#125;","categories":[],"tags":[]},{"title":"儒略日[CSP2020]","slug":"儒略日-CSP2020","date":"2020-11-09T13:17:16.000Z","updated":"2020-11-09T13:20:51.347Z","comments":true,"path":"post/51b41b34.html/","link":"","permalink":"http://akdream.tk/post/51b41b34.html/","excerpt":"","text":"题面太长不放 https://www.luogu.com.cn/problem/P7075 题解如何优雅地在开考40分钟内完成此题？首先最重要的一点：发现1600年之前的闰年规律都是每4年一次，而1600又正好是400的倍数，所以以1600作为分界线，分成1600年前后两种情况比较好处理 其次，发现0年不存在也不方便，所以把所有的负数年份+1，输出时再改回来 公元前4913年1月1日是第0天也不方便，所以把 r++ 准备工作做好，现在来考虑怎么求解 (一)1600年及以前如果$r&lt;=M$，那么时间在1600年及以前($M$表示-4713到1600共有多少天) 发现-4713到1600只有6000多年，所以干脆把每一年的天数都算出来(然后求前缀和方便二分) 注意的点： 由于我们把所有的负数年份+1了，所以现在所有模4余0的年份都是闰年 1582年只有355天！！！ 求出前缀和后(即-4713年到1600年及之前的某一年一共有多少天)，就可以二分求出究竟是在哪一年的第几天，然后跳转到**(三)** (二)1600年之后如果$r&gt;M$，那么时间在1600年之后，让$r$减去$M$ 此时每400年为一个周期，400年一共经过了$36697+365303=146097$天 算出$p=\\lfloor\\dfrac{r}{146097}\\rfloor$表示一共经过了多少个400年 $q=r\\bmod 146097$表示剩余多少天 注意！如果$q=0$，为方便后续计算，要让$p$减去1，并将$q$设为$146097$ 之后就同**(一)**一样，预处理出400年中每一年的天数和前缀和，就可以二分求出$q$究竟是在最后余下的不到400年中的哪一年，以及是这年的第几天 如果二分求得是最后400年中的第$k$年，那么答案年份就应该是$1600+400p+k$ 然后跳转到**(三)** (三)一年内的判断现在我们已经确定了答案是哪一年，是这一年的第几天，只需要找出月份和日期即可 发现$Q\\le 10^5$，其实可以算出这一年的12个月各有多少天，然后从一月开始枚举，就很容易算出是几月几日 注意前面给负数年份加了1，现在要减回来 注意事项： 1600年之前的闰年判定和1600年之后不同！注意区分 1582年的10月只有21天！ 如果你得出的答案是1582年10月521日，给日期加上10！1582.10.51582.10.14不存在！ 注意事项3成功导致我100pts -&gt; 40pts /kk 写多几个函数一定会比全部挤在main函数中条理更清晰 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f; &#125;ll ttt, M = 5000; //M作为数组的偏移量，防止数组越界 ll n;ll months[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, nmonth[13];ll Aday[10005], Bday[10005]; //A:1600之前; B:400年的周期 ll days400 = 146097;void initrun() &#123; for (ll i = -4712; i &lt;= 1600; i++) Aday[i+M] = 365; for (ll i = -4712; i &lt;= 1600; i += 4) &#123; Aday[i+M] = 366; &#125; Aday[1582+M] = 355; //!!! for (ll i = -4712; i &lt;= 1600; i++) Aday[i+M] += Aday[i+M-1]; for (ll i = 1; i &lt;= 400; i++) &#123; if ((i % 400 == 0) || (i % 4 == 0 &amp;&amp; i % 100 != 0)) Bday[i] = Bday[i-1] + 366; else Bday[i] = Bday[i-1] + 365; &#125; &#125;void printans(ll y, ll m, ll d) &#123; if (y &lt; 0) printf(\"%lld %lld %lld BC\\n\", d, m, -y); else printf(\"%lld %lld %lld\\n\", d, m, y);&#125;void inyear(ll y, ll d) &#123; //y年的第d天 for (ll i = 1; i &lt;= 12; i++) nmonth[i] = months[i]; if (y == 1582) &#123; //in 1582 nmonth[10] = 21; &#125; else if (y &lt;= 1600) &#123; //before 1600 if (y % 4 == 0) nmonth[2] = 29; &#125; else &#123; //after 1600 if ((y % 400 == 0) || (y % 4 == 0 &amp;&amp; y % 100 != 0)) &#123; nmonth[2] = 29; &#125; &#125; if (y &lt;= 0) y--; //恢复负数年份 for (ll i = 1; i &lt;= 12; i++) &#123; if (d &lt;= nmonth[i]) &#123; if (y == 1582 &amp;&amp; i == 10 &amp;&amp; d &gt;= 5) d += 10; //100pts-&gt;40pts printans(y, i, d); break; &#125; else &#123; d -= nmonth[i]; &#125; &#125;&#125;void solve1(ll x) &#123; //before 1600 ll l = -4712, r = 1600, mid = 0, ans = 0; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (Aday[mid+M] &gt;= x) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; inyear(ans, x - Aday[ans+M-1]);&#125;void solve2(ll x) &#123; //after 1600 ll p = x / days400; ll q = x % days400; if (!q) &#123; p--; q = days400; &#125; ll l = 1, r = 400, mid = 0, ans = 0; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (Bday[mid] &gt;= q) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; inyear(1600 + p * 400 + ans, q - Bday[ans-1]);&#125;int main() &#123; read(ttt); initrun(); while (ttt--) &#123; read(n); n++; if (n &lt;= Aday[1600+M]) &#123; //before 1600 solve1(n); &#125; else &#123; //after 1600 solve2(n - Aday[1600+M]); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"矩形区域[IOI2019]","slug":"矩形区域-IOI2019","date":"2020-11-04T03:31:25.000Z","updated":"2020-11-04T03:33:01.124Z","comments":true,"path":"post/f48e3c0f.html/","link":"","permalink":"http://akdream.tk/post/f48e3c0f.html/","excerpt":"","text":"题目描述https://loj.ac/problem/3177 题解假设某个合法的矩形只有一行，是$a_{1,l}\\sim a_{1,r}$，那么显然有这样一个结论成立：$a_{1,l-1}$是$a_{1,r+1}$左侧第一个大于它的 或者$a_{1,r+1}$是$a_{1,l-1}$右侧第一个大于它的 那么对于一个合法矩形，每一行都应该满足这个条件 每一列应该也要满足类似的条件 所以对于一行(或列)，可以通过单调栈来求出所有这样的$[l,r]$ 对于每一行都用这样的方法求出这样的$[l,r]$，用一个vector:$ok[l][r]$来存储所有$a_{i,l}~a_{i,r}$为合法段的$i$ 枚举矩形右边界$r$，并每次更新$lok[u][d]$表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 然后枚举矩形左边界$l$，枚举$ok[l][r]$中的每一个连续段$[u,d]$，那么矩形的上下边界在$[u,d]$中时一定是满足行的限制的，只需找出有多少个左右边界为$l,r$，上下边界在$[u,d]$内的矩形满足条件即可 代码中做了注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define N 2520using namespace std;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f; &#125;int n, m, a[N][N], stk[N], cnt, top, ans; vector&lt;int&gt; ok[N][N]; //ok[l][r]: a[l][i]~a[r][i]为合法段的i的集合 pair&lt;int, int&gt; tmp[N]; //临时存答案 int lok[N][N], rok[N][N]; void solve(int *num, int len) &#123; //找出所有合法段 cnt = top = 0; for (int i = 1; i &lt;= len; i++) &#123; while (top &amp;&amp; num[i] &gt; num[stk[top]]) &#123; if (i &gt; stk[top] + 1) tmp[++cnt] = make_pair(stk[top]+1, i-1); //num[l] &lt; num[r] top--; &#125; if (top) &#123; if (i &gt; stk[top] + 1) tmp[++cnt] = make_pair(stk[top]+1, i-1); //num[l]&gt;num[r] if (num[i] == num[stk[top]]) top--; //特殊处理相等情况 &#125; stk[++top] = i; &#125;&#125;void calc(int l, int r, int u, int d) &#123; //左右边界为l,r;上下边界在[u,d]内 int len = 0; for (int i = u - 1; i &lt;= d + 1; i++) &#123; a[0][++len] = a[i][r]; &#125; solve(a[0], len); //找出列的合法段 for (int i = 1; i &lt;= cnt; i++) &#123; int tl = tmp[i].first + u - 2, tr = tmp[i].second + u - 2; if (lok[tl][tr] &lt;= l) ans++; &#125;&#125; int main() &#123; read(n); read(m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; read(a[i][j]); &#125; &#125; for (int i = 2; i &lt; n; i++) &#123; //预处理ok集合 solve(a[i], m); for (int j = 1; j &lt;= cnt; j++) ok[tmp[j].first][tmp[j].second].push_back(i); &#125; for (int r = 2; r &lt; m; r++) &#123; //枚举矩形右边界 for (int i = 1; i &lt;= n; i++) a[0][i] = a[i][r]; solve(a[0], n); for (int i = 1; i &lt;= cnt; i++) &#123; if (rok[tmp[i].first][tmp[i].second] + 1 &lt; r) lok[tmp[i].first][tmp[i].second] = r; rok[tmp[i].first][tmp[i].second] = r; //lok[u][d]表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 &#125; for (int l = 2; l &lt;= r; l++) &#123; //枚举矩形左边界 if (!ok[l][r].size()) continue; int lst = ok[l][r][0]; for (int i = 1; i &lt; ok[l][r].size(); i++) &#123; if (ok[l][r][i] &gt; ok[l][r][i-1] + 1) &#123; //找出ok[l][r]中的一个连续段 calc(l, r, lst, ok[l][r][i-1]); lst = ok[l][r][i]; &#125; &#125; calc(l, r, lst, ok[l][r][ok[l][r].size()-1]); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[]},{"title":"Mr Panda and Survey[HDU6001]","slug":"Mr Panda and Survey-HDU6001","date":"2020-10-06T12:25:41.000Z","updated":"2020-10-08T12:16:08.016Z","comments":true,"path":"post/d3259d46.html/","link":"","permalink":"http://akdream.tk/post/d3259d46.html/","excerpt":"","text":"题目链接https://acm.hdu.edu.cn/showproblem.php?pid=6001 题解设$f(S)$表示有多少种选问卷的情况使得$S$中所有元素都不是好问题 设$ans[S]$表示选择的问题集合是$S$时，有多少种选择问卷的方案使得它们全部是好问题 那么由容斥原理，$ans[S]=2^n+\\sum\\limits_{S_2\\subseteq S}(-1)^{t(S)}f(S)$，其中$t(S)$为$S$中元素个数 考虑如何预处理$f(S)$ 对于每个问卷$x$，设$tag[x]=\\sum\\limits_{i=1}^{m}2^i[a[x][i]=Y]$，即如果第$i$个问题答案是yes那第$i$位就是$1$ 设$cnt[p]$表示有多少$x$的$cnt[x]=p$ 那么对于一种使得所有问题都不是好问题的选择方案，选择的所有问卷的$tag$一定相等 所以容易得出$f(2^n-1)=1+\\sum\\limits_{i=0}^{2^m-1}(2^{cnt[i]}-1)$ 最前面那个$1$表示取空集 假设我们已经算出$f(S)$，考虑$S$去掉一个元素$i$得到的新集合$S_2$ 那么此时$i$是不是好问题就无所谓了，所以可以直接把$i$这一位给“删掉” 具体实现中，可以对于所有包含$i$的集合$T$，让$cnt[T-i]+=cnt[T]$，然后这个$cnt[T]$就当它不存在，这样就相当于默认第$i$位是$0$(操作A) (这里不是做减法，只是表示$T$集合去掉元素$i$) 那么对于$f(S_2)$，枚举$S_2$的所有子集$S_3$(显然除了$S_3$以外的那些集合$T$的$cnt[T]$已经被我们当成不存在了)，有$f(S_2)=1+\\sum\\limits_{S_3\\subseteq S_2}(2^{cnt[S_3]}-1)$ 然后考虑用一个dfs，我们已经算出$f(S)$了，这时进行上面那个操作A，然后往$S_2$递归，就能算出$f(S_2)$ 这一步的复杂度是$O(m^3)$的，这样就处理出了所有的$f(S)$ 然后回到上面$ans[S]=2^n+\\sum\\limits_{S_2\\subseteq S}(-1)^{t(S)}f(S)$，这一步的复杂度也是$O(m^3)$的，总时间复杂度为$O(tm^3)$(时限40s?) 代码暂时还没有","categories":[],"tags":[]},{"title":"矩阵游戏[NOI2013]","slug":"矩阵游戏-NOI2013","date":"2020-09-27T14:26:06.000Z","updated":"2020-09-27T14:27:12.000Z","comments":true,"path":"post/cd282ac6.html/","link":"","permalink":"http://akdream.tk/post/cd282ac6.html/","excerpt":"","text":"题目描述婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足一个神奇的性质：若用$F[i][j]$来表示矩阵中第$i$行第$j$列的元素，则$F[i][j]$满足下面的递推式: $$F[1][1]=1$$ $$F[i,j]=a\\times F[i][j-1]+b (j\\neq 1)$$ $$F[i,1]=c\\times F[i-1][m]+d (i\\neq 1)$$ 递推式中$a,b,c,d$都是给定的常数。 现在婷婷想知道$F[n][m]$的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出$F[n][m]$除以$1,000,000,007$的余数。 题解考虑$F[i][1]$和$F[i][m]$之间的关系： $$F[i][m]=a(a(\\cdots(a\\times F[i][1]+b)\\cdots)+b)+b$$$$=a^{m-1}\\times F[i][1] + a^{m-2}b + a^{m-3}b + \\cdots + b$$$$=a^{m-1}\\times F[i][1] + \\dfrac{a^{m-1}-1}{a-1}\\times b$$ 由此可得$$F[i+1][1]=a^{m-1}c\\times F[i][1] + \\dfrac{a^{m-1}-1}{a-1}\\times bc + d$$ 设$A=a^{m-1}c,\\ B=\\dfrac{a^{m-1}-1}{a-1}\\times bc + d$，则 $$F[i+1][1]=A\\times F[i][1]+B$$ 如法炮制，可得 $$F[n][1]=A^{n-1}\\times F[1][1] + \\dfrac{A^{n-1}-1}{A-1}\\times B$$ 由于$F[1][1]=1$，所以可以先把$F[n][1]$算出来，然后再使用上面那个$F[i][1]$和$F[i][m]$的关系式来推出$F[n][m]$即可 如何算$a^{m-1}$? 由于$a^{p-1}\\equiv 1 \\pmod p$，所以$a^{m-1}\\equiv a^{(m-1)\\bmod (p-1)} \\pmod p$ 那么对$m-1$取模$p-1$后再进行快速幂即可，$A^{n-1}$同理 注意特判$a=1$或者$A=1$的情况!!! 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;const ll mod = 1000000007;char n[1000005], m[1000005];ll N, M, _N, _M;ll a, b, c, d, nl, ml, am, asum, B, A, Am, Asum;ll ans;inline ll fpow(ll x, ll t) &#123; ll ret = 1; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;int main() &#123; scanf(\"%s %s\", n + 1, m + 1); read(a); read(b); read(c); read(d); a %= mod; b %= mod; c %= mod; d %= mod; nl = strlen(n + 1); ml = strlen(m + 1); for (int i = 1; i &lt;= ml; i++) &#123; M = (M * 10 % mod + m[i] - '0') % mod; &#125; for (int i = 1; i &lt;= ml; i++) &#123; _M = (_M * 10 % (mod-1) + m[i] - '0') % (mod-1); &#125; for (int i = 1; i &lt;= nl; i++) &#123; N = (N * 10 % mod + n[i] - '0') % mod; &#125; for (int i = 1; i &lt;= nl; i++) &#123; _N = (_N * 10 % (mod-1) + n[i] - '0') % (mod-1); &#125; am = fpow(a, _M-1); //a^(p-1)==1 (mod p) if (a == 1) asum = M - 1; else asum = (am - 1) * fpow(a - 1, mod - 2) % mod; B = (b * c % mod * asum % mod + d) % mod; A = am * c % mod; Am = fpow(A, _N-1); if (A == 1) Asum = N - 1; else Asum = (Am - 1) * fpow(A - 1, mod - 2) % mod; ans = (Am + B * Asum % mod) % mod; // f[n][1] ans = (am * ans % mod + b * asum % mod) % mod; //f[n][n] printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[]},{"title":"方伯伯的商场之旅[SCOI2014]","slug":"方伯伯的商场之旅-SCOI2014","date":"2020-09-26T14:05:25.000Z","updated":"2020-09-26T14:07:44.000Z","comments":true,"path":"post/b941660e.html/","link":"","permalink":"http://akdream.tk/post/b941660e.html/","excerpt":"","text":"题目描述方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第$j$堆的石子的数量，刚好是$i$写成$K$进制后的第$j$位。 现在方伯伯要玩一个游戏，商场会给方伯伯两个整数$L,R$。方伯伯要把位置在$[L,R]$中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量$\\times$移动的距离。商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。 输入格式输入仅有一行，包含三个用空格分隔的整数$L$，$R$，$K$，表示商场给方伯伯的两个整数，以及进制数。 输出格式输出仅有一行，包含一个整数，表示最少的代价。 题解考虑用$1\\sim R$的答案减掉$1\\sim L-1$的答案，即$\\operatorname{solve}(R) - \\operatorname{solve}(L-1)$。 考虑$\\operatorname{solve}(n)$，先计算把每个人的石子都全部合并到第$1$堆所需的代价 这个是可以通过一次数位dp解决的 1234567891011ll dfs1(ll d, ll sum, ll lim) &#123; if (!d) return sum; if (!lim &amp;&amp; ~f[d][sum]) return f[d][sum]; ll ret = 0; int mx = lim ? a[d] : k-1; for (ll i = 0; i &lt;= mx; i++) &#123; ret += dfs1(d-1, sum + i * (d - 1), lim &amp; (i == mx)); //第d位有i个石子要移动到第1位 &#125; if (!lim) f[d][sum] = ret; return ret;&#125; 注意到这样一个性质：对于一个人$x$，假设他把所有石子最终全部移到第$k$位，我们把$k$叫做$x$的集合点，这样移动的代价是$f_x(k)$，那么$f_x$一定是一个单谷函数 不妨把$x$的最优集合点叫做$p_x$ 所以我们可以执行这样的操作： for i=2~n，每次把所有 “集合点在$i$时比在$i-1$时更优 (即$f_x(i-1)&gt;f_x(i)$)” 的那些$x$的集合点全部从$i-1$变为$i$，也就是说让答案减去$f_x(i-1)-f_x(i)$ 这样一来，由于$f_x$是单谷函数，那么一个人$x$一定在$i=2\\sim p_x$的时候集合点被移动，那么$x$的最终代价就会是$f_x(p_x)$，所以这个做法是正确的 然后考虑如何进行这个”挪动集合点”的操作 其实和上面的那个计算集合点全为1的数位dp区别不大 12345678910ll dfs2(ll d, ll sum, ll p, ll lim) &#123; if (!d) return max(0ll, sum); //如果sum&lt;0则说明不把集合点从p-1挪到p比较优 if (!lim &amp;&amp; ~f[d][sum]) return f[d][sum]; ll ret = 0; int mx = lim ? a[d] : k-1; for (ll i = 0; i &lt;= mx; i++) &#123; ret += dfs2(d-1, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx)); &#125; if (!lim) f[d][sum] = ret; return ret;&#125; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll k, len, a[60];ll L, R, f[60][5005];ll dfs1(ll d, ll sum, ll lim) &#123; if (!d) return sum; if (!lim &amp;&amp; ~f[d][sum]) return f[d][sum]; ll ret = 0; int mx = lim ? a[d] : k-1; for (ll i = 0; i &lt;= mx; i++) &#123; ret += dfs1(d-1, sum + i * (d - 1), lim &amp; (i == mx)); &#125; if (!lim) f[d][sum] = ret; return ret;&#125;ll dfs2(ll d, ll sum, ll p, ll lim) &#123; if (!d) return max(0ll, sum); if (!lim &amp;&amp; ~f[d][sum]) return f[d][sum]; ll ret = 0; int mx = lim ? a[d] : k-1; for (ll i = 0; i &lt;= mx; i++) &#123; ret += dfs2(d-1, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx)); &#125; if (!lim) f[d][sum] = ret; return ret;&#125;ll solve(ll n) &#123; len = 0; ll tmp = n; while (tmp) &#123; a[++len] = tmp % k; tmp /= k; &#125; memset(f, -1, sizeof(f)); ll ret = dfs1(len, 0, 1); for (ll i = 2; i &lt;= len; i++) &#123; memset(f, -1, sizeof(f)); ret -= dfs2(len, 0, i, 1); &#125; return ret;&#125;int main() &#123; scanf(\"%lld %lld %lld\", &amp;L, &amp;R, &amp;k); printf(\"%lld\\n\", solve(R) - solve(L-1)); return 0;&#125;","categories":[],"tags":[{"name":"数位DP","slug":"数位DP","permalink":"http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"树的计数[NOI2013]","slug":"树的计数-NOI2013","date":"2020-09-23T13:14:37.000Z","updated":"2020-10-08T12:16:08.574Z","comments":true,"path":"post/c65ab714.html/","link":"","permalink":"http://akdream.tk/post/c65ab714.html/","excerpt":"","text":"题目描述我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 1 2 4 5 3，BFS 序都是 1 2 3 4 5。 现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有$K$棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是$h_1,h_2,\\cdots,h_K$，那么请你输出： $$\\dfrac{h_1+h_2+\\cdots +h_K}{K}$$ 输入格式第一行包含$n$个正整数 ，表示树的节点个数。 第二行包含$n$个正整数，是一个$1\\dots n$的排列，表示树的 DFS 序。 第三行包含$n$个正整数，是一个$1\\dots n$的排列，表示树的 BFS 序。 输入保证至少存在一棵树符合给定的两个序列。 输出格式输出$1$个实数，四舍五入保留恰好三位小数，表示树高的平均值。 题解对于给出的dfs序和bfs序，一定有一种方法给点重新标号，使得bfs序变成$1,2,3,\\cdots,n$这个样子 以样例为例：dfs序为$1,2,4,5,3$，bfs序为$1,2,3,4,5$ 发现深度相同的点，在bfs序中一定是连续一段的，所以原题目可以看作给bfs序进行分段，使得分段后满足dfs序 样例中$n=5$，有4个分段点 经过观察，有如下几个分段的限制条件： 条件一深度为1的点一定只有一个(根)，所以$1$后面要进行分段。变为$1 | 2 3 4 5$ 条件二设$p[i]$表示$i$在dfs序中在第几个，如$p[3]=5,p[4]=3$ 对于$i \\in [1, n)$，如果$p[i]&gt;p[i+1]$，那么有如下两种情况： (以样例$p[3]&gt;p[4]$为例) 得到限制条件：对于$i \\in [1, n)$，如果$p[i]&gt;p[i+1]$，那么$i$与$i+1$之间要分段 样例中，$3$和$4$之间必须要有分割线，即$1|23|45$ 样例中，只有$3$满足$p[i]&gt;p[i+1]$，所以已经确定的必须要有的分割线为$1|23|45$ 条件三dfs序为$12453$，$2$后一个为$4$，所以点$4$的深度最多比点$2$多$1$ 在bfs序中，这就等价于说$2$和$4$之间最多有一条分割线 形式化地，设dfs序数组为$d[N]$，那么对于$i\\in [1,n)$，如果$d[i]+1&lt;d[i+1]$，那么在bfs序中$d[i]$与$d[i+1]$之间最多有一条分割线 发现在样例中，$24$连在一起，那么$3$要不在$2$前面，要不在$4$后面 如果$3$在$2$前面，那么有$p[2]&gt;p[3]$，出现条件二的情况，$2$和$3$之间必须有分割线 如果$3$在$4$后面，那么有$p[3]&gt;p[4]$，出现条件二的情况，$3$和$4$之间必须有分割线 样例中就有$p[3]&gt;p[4]$，所以$3$和$4$之间必须有分割线 所以可以得出结论：$2$和$4$之间必定至少有一条 由条件二得出的必须存在的分割线 又因为$2$与$4$之间最多有一条分割线，所以$2\\sim 4$之间别的未确定的空隙中就必定是没有分割线的 以上就是3个分割条件，然后考虑如何实现 先找出所有的必须存在的分割线(条件一，二) 样例中必须存在的分割线就是$1|23|45$ 然后根据条件三，$2\\sim 4$之间剩余的空隙就不能填分割线，这里也就是$2$和$3$之间的那个空隙一定不能填 我们把所有 必须填/必须不填 的分割点打上标记，而可以自由选择填或不填的就不打标记 对于条件一，二，有必须要填的分割线，把必须要填的地方打上标记，并且让答案+1(必须多分割出一层) 对于条件三，有必须不填的分割线，把必须不填的地方打上差分标记 然后扫一遍，如果有可以自由选择填或不填的分割点，就让答案加上0.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 200005using namespace std;typedef long long ll;template &lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, a[N], b[N], sum[N];double ans;int main() &#123; read(n); ans = 2; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1, x; i &lt;= n; i++) &#123; read(x); b[x] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; a[i] = b[a[i]]; &#125; for (int i = 1; i &lt;= n; i++) &#123; b[a[i]] = i; &#125; sum[1]++; sum[2]--; //ban:1 for (int i = 1; i &lt; n; i++) &#123; if (b[i] &gt; b[i+1]) &#123; //情况1：i后面必须分段 ans++; sum[i]++; sum[i+1]--; //ban:i &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; if (a[i] + 1 &lt; a[i+1]) &#123; //a[i]~a[i+1]只能分一次段， 且肯定至少有一个情况1 //若有大于等于两个情况1则无解 sum[a[i]]++; sum[a[i+1]]--; //ban:a[i]~a[i+1]-1 &#125; &#125; int now = 0; for (int i = 1; i &lt; n; i++) &#123; now += sum[i]; //差分 if (!now) ans += 0.5; //now==0表示可以自由选择在i后面分割 &#125; printf(\"%.3lf\\n\", ans); return 0;&#125;","categories":[],"tags":[]},{"title":"方伯伯的玉米田[SCOI2014]","slug":"方伯伯的玉米田-SCOI2014","date":"2020-09-14T10:57:09.000Z","updated":"2020-09-14T10:58:10.000Z","comments":true,"path":"post/1dcb3735.html/","link":"","permalink":"http://akdream.tk/post/1dcb3735.html/","excerpt":"","text":"题目描述方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有$N$株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。 输入格式第一行包含两个整数$N$，$K$，分别表示这排玉米的数目以及最多可进行多少次操作。第二行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。 输出格式输出一个整数，最多剩下的玉米数。 题解有一个显而易见的贪心：即每次都是拔高以$n$结尾的一段区间是最优的 如果拔高了区间$[i,j]$，其中$j&lt;n$，那么换成拔高$[i,n]$一定不会让答案变得更劣 所以现在的问题就变成每次选择一段后缀上的玉米进行拔高 设$dp[i][j]$表示第$i$株玉米总计被拔高了$j$次时，以第$i$株玉米结尾的最长不降子序列的长度(这个子状态有亿点点难想到) 转移方程：$dp[i][j]=\\max(dp[k][l])+1$，其中$k&lt;i,\\ l\\le j,\\ a_k+l\\le a_i+j$ 那这个max怎么快速求得呢？似乎要用树套树 不过这题由于空间够用，所以树状数组套树状数组就行了 答案就是整个dp数组中的最大值 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define N 10005#define lowbit(x) x&amp;(-x)using namespace std;template &lt;typename T&gt; inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, k, a[N], dp[N][505];int tr[N][505], ans;void Update(int x, int y, int v) &#123; y++; for (int i = x; i &lt;= 10000; i += lowbit(i)) &#123; for (int j = y; j &lt;= 501; j += lowbit(j)) &#123; tr[i][j] = max(tr[i][j], v); &#125; &#125;&#125;int Query(int x, int y) &#123; y++; int ret = 0; for (int i = x; i; i -= lowbit(i)) &#123; for (int j = y; j; j -= lowbit(j)) &#123; ret = max(ret, tr[i][j]); &#125; &#125; return ret;&#125;int main() &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = k; j &gt;= 0; j--) &#123; dp[i][j] = Query(a[i] + j, j) + 1; Update(a[i] + j, j, dp[i][j]); ans = max(ans, dp[i][j]); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LCT的进阶应用","slug":"LCT的进阶应用","date":"2020-08-08T14:59:38.000Z","updated":"2020-10-08T12:16:07.992Z","comments":true,"path":"post/cee3a0d7.html/","link":"","permalink":"http://akdream.tk/post/cee3a0d7.html/","excerpt":"","text":"关于LCT的进阶应用 不光是写算法思路，因为已经有很多人写过了，更重要的是代码写法中的细节，不然LCT各种奇怪应用的细节够你一题调一个小时 本篇文章将助你考试一遍过样例！ 当然，还有一些基础应用比如维护路径信息或者维护联通性，但是代码都相对比较模板，所以也没什么好写 一. LCT维护边双连通分量有些题目中会动态加边并有形如“x到y之间有多少必经边” “某个边双内有多少点”的询问，这时候需要用LCT来维护边双联通分量 思路讲解注意到，如果把所有边双缩成点，那么一定会构成一个森林 此时如果新增了一条边$x,y$，一种情况是$x,y$不在同一棵树里，此时直接link(x,y)即可 一种情况是$x,y$在同一棵树中，但不在同一个边双中，那么就会形成一个新的边双 找出$x,y$所在的边双所缩成的点$fx,fy$，然后把$fx$到$fy$这条路径上的所有点缩成一个新点，并让这个新点来记录新的边双中的点的权值之和 实现时可以用并查集来记录每个点在哪个边双中 注意，维护边双时不支持删边操作，因为无法快速确定删除某个边双内部的一条边后会分裂成几个新的边双 代码剖析相信大家都已经记住原版LCT是怎么写的了 这里来看一下维护边双的LCT和原版有哪些区别 1. 并查集维护每个点在哪个边双中123int Fa[N];int find(int x) &#123; return Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;//记得初始化并查集 2. access操作写法发生变化1234567inline void access(int x) &#123; for (int i = 0; x; i = x, x = find(fa[x])) &#123; //x每次跳到find(fa[x])而不是fa[x] splay(x); ch[x][1] = i; if (i) fa[i] = x; //一定要把新的重儿子i的父亲设为x pushup(x); &#125;&#125; 3. 新增操作merge：将x到y的路径缩为一个点1234567891011121314queue&lt;int&gt; q;inline void merge(int x, int y) &#123; split(x, y); //将x到y的路径提取出来 q.push(y); while (!q.empty()) &#123; //用bfs在二叉树上遍历x到y路径上的所有点 int u = q.front(); q.pop(); Fa[find(u)] = y; //维护并查集 if (ch[u][0]) q.push(ch[u][0]); if (ch[u][1]) q.push(ch[u][1]); ch[u][0] = ch[u][1] = 0; &#125; val[y] = sum[y]; //y成为这个边双的代表元 //如果还有其它信息也是要全部让y来存&#125; 4. 连边$x,y$时的分类讨论伪代码如下 维护两点联通性可以再开一个并查集，也可以用findroot 123456789void LINK(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) return; //x,y已在同一边双中 if (x,y不在同一棵树中) &#123; link(x,y); //如果用另一个并查集维护联通性记得更新并查集 &#125; else &#123; merge(fx,fy); //是fx,fy 不是x,y!!! &#125;&#125; 5. 进行任何修改/询问操作时都一定是对$fx=find(x)$进行，而不是$x$本身！例题[bzoj2959]长跑[AHOI2005]航线规划 二. LCT维护子树信息LCT一般用来维护路径信息而不是子树信息，因为LCT维护子树信息非常不方便。。。 但是有些毒瘤题可能在询问子树信息的同时还有加边删边操作，或者可能有换根操作，就只能被迫使用LCT了 思路讲解假设现在需要用LCT维护原树中一个子树的$siz$ 为了方便查询，一般会把原树中一条重链的顶端$x$的子树信息存储在 ($x$在LCT中所在的二叉树的根) 的位置 如上图，原树中的$siz[1]$实际上存在LCT中的$siz[3]$里 但是一个点子树的$siz$不仅包含自己所在的那条重链的$siz$啊 如何维护轻子树的大小？ 我们记$lsiz[x]$表示LCT中$x$的所有轻子树的$siz$之和，这样$siz[x]$就等于$siz[lson]+siz[rson]+lsiz[x]+1$ 如果我们希望查询$x$点的子树信息，只需要access(x)，然后此时$x$就会位于一条重链的底端，那么$siz[lson]$和$siz[rson]$都为$0$，$siz[x]=lsiz[x]+1$，而此时LCT中$x$的轻子树一定一一对应着原树中$x$的子树，所以此时的$siz[x]$就是$x$在原树中的$siz$ 如果需要查询以$x$为根时整棵子树的信息，只需makeroot(x)，然后直接查询 接下来的问题就在于如何维护这个$lsiz$了 来看一下代码 代码剖析1. pushup操作写法发生变化123inline void pushup(int x) &#123; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + lsum[x] + val[x]; //lsum表示轻子树的权值和&#125; 2. access操作写法发生变化1234567inline void access(int x) &#123; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x); lsum[x] += (siz[ch[x][1]] - siz[i]); //ch[x][1]变为轻儿子，而i不再是轻儿子 ch[x][1] = i; pushup(x); &#125;&#125; 3. link操作写法发生变化123456inline void link(int x, int y) &#123; makeroot(x); makeroot(y); //x,y都要makeroot! fa[x] = y; lsum[y] += sum[x]; //x成为y的轻儿子 pushup(y);&#125; 4. 单点修改$x$时先 makeroot(x)！例题[BJOI2014]大融合[bzoj3510]首都 3. LCT维护形态树+权值树这类题目一般是要求维护树上路径信息，但是经常会对路径上的点权做一些奇怪的操作 如[BZOJ3159]决战：路径翻转操作 [GDSOI2017]中学生数据结构题：路径循环移位操作 思路讲解众所周知，LCT上的Splay以原树中的节点深度为关键字，随便你怎么rotate，只要节点的相对次序不变，那么就只有辅助树的形态会发生改变，而对应的原树形态不变 在makeroot(x)操作中，我们翻转了以$x$为根的Splay，节点的相对次序发生了改变，所以其实在原树中就体现为原树的根变成了$x$ 但是在这种题里，如果你还是为了维护权值胡乱操作辅助树Splay，那说不定什么时候你就不小心把哪个点变成原树的根了。。。 所以我们要再建出一棵辅助树来维护权值，使得在这棵辅助树上进行操作一定不会影响原树形态，我们把这棵辅助树叫做权值树，而LCT那棵叫形态树 这里我选择了非旋Treap来维护权值树 现在需要解决的问题就是 我们希望形态树和权值树是时刻对应的 比如说，现在LCT被分为这样几棵Splay：$[1,2],[3,5,6],[4,7]$，那么此时权值树一定也是被这样划分为3棵的 还有一个东西也要对应，就是形态树的中序遍历序列要时刻与权值树的中序遍历序列相同，这样才能够保证形态树中某棵平衡树排名第$k$的点和权值树中对应平衡树的第$k$个点是同一个点，方便进行修改 比如说此时形态树中3棵平衡树的中序遍历分别为$[1,2],[6,3,5],[7,4]$，那么权值树也要一样，绝不可能是$[1,2],[5,3,6],[4,7]$ 为了实现这个功能，我们需要在LCT更改轻边重边时同样维护权值树的连边 同时为了方便查询，还需要动态维护每棵形态树中的平衡树对应着权值树中的哪一棵平衡树 用$rt[x]$来维护这个信息，一定要保证形态树中每棵平衡树的树根的$rt[x]$是权值树对应的那棵平衡树的树根，这样才能正确修改和查询 代码剖析1. 权值树该怎么写怎么写，写一个正常的平衡树就行2. splay操作写法发生变化1234567891011inline void splay(int x) &#123; q[top=1] = x; int i; for (i = x; !isroot(i); i = fa[i]) q[++top] = fa[i]; swap(rt[i], rt[x]); //x将会变成平衡树的根，把原来根的rt值给x while (top) pushdown(q[top--]); while (!isroot(x)) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) ((ch[z][1] == y) ^ (ch[y][1] == x)) ? rotate(x) : rotate(y); rotate(x); &#125;&#125; 3. 划重点！access操作写法123456789101112131415inline void access(int x) &#123; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x); if (ch[x][1]) &#123; VAL::split(rt[x], siz[x] - siz[ch[x][1]], rt[x], rt[ch[x][1]]); //x的重儿子不再是ch[x][1]，把它的子树从x对应的平衡树中删去 &#125; if (i) &#123; rt[x] = VAL::merge(rt[x], rt[i]); //i成为x的重儿子，把它的子树加入x对应的平衡树 //注意merge顺序 &#125; ch[x][1] = i; pushup(x); &#125;&#125; 3. makeroot操作写法发生变化1234inline void makeroot(int x) &#123; access(x); splay(x); rev(x); VAL::Rev(rt[x]); //为了保证中序遍历相同，权值树也要翻转&#125; 4. 对于任何修改/查询，先split(x,y)，然后在权值树的对应平衡树上修改/查询12345inline void Add(int x, int y, ll v) &#123; split(x, y); VAL::Add(rt[y], v); &#125;inline void Rev(int x, int y) &#123; split(x, y); VAL::Rev(rt[y]); &#125;inline ll Qsum(int x, int y) &#123; split(x, y); return VAL::sum[rt[y]]; &#125;inline ll Qmax(int x, int y) &#123; split(x, y); return VAL::mx[rt[y]]; &#125;inline ll Qmin(int x, int y) &#123; split(x, y); return VAL::mn[rt[y]]; &#125; 例题[bzoj3159]决战 4. LCT维护边权信息LCT怎么维护边权？LCT维护不了边权。 但是可以把边拆成点，然后就变成维护点权了（ 多用于维护生成树 思路讲解新科技：KrusLCT算法$O(m\\log m)$求最小生成树！ 对于一条边$(u,v)$，新建一个点$w$，把$w$的点权设为边权，$u,v$的点权视题目设成正无穷，负无穷，$0$之类的，然后连边$(u,w)$，$(w,v)$ 这样有什么好处呢？如果我想要查询$x$到$y$路径上的最大边权，只需要在LCT上查询$x$到$y$的最大点权就好了 所以可以口胡出一个最小生成树算法： 按顺序考虑每一条边$u,v$：若$u,v$不连通，则在LCT中连上$u,v$ 否则找出LCT上$u,v$路径上的最大点权，若这个”点”权大于当前边$u,v$的边权，就把那条边断开，连上这条边 当然这就是LCT维护边权的一个应用，其实理解起来非常简单 代码剖析实在是没有什么好写的了 因为和普通的LCT没有什么区别，唯一的区别就是连边/删边要删两条？ 1. 我到底应该删哪两条边？1//使用 map&lt;pair&lt;int, int&gt; , int&gt; !!! 例题[NOI2014]魔法森林[WC2006]水管局长","categories":[],"tags":[{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"}]},{"title":"长跑[BZOJ2959]","slug":"长跑-BZOJ2959","date":"2020-08-06T12:38:27.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/f9901713.html/","link":"","permalink":"http://akdream.tk/post/f9901713.html/","excerpt":"","text":"题目描述某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加3000米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。为了让同学们更好地监督自己，学校推行了刷卡机制。学校中有$n$个地点，用$1$到$n$的整数表示，每个地点设有若干个刷卡机。有以下三类事件： 修建了一条连接A地点和B地点的跑道。 A点的刷卡机台数变为了B。 进行了一次长跑。问一个同学从A出发，最后到达B最多可以刷卡多少次。具体的要求如下： 当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从A地点到B地点能刷卡的最多次数。 输入格式输入的第一行包含两个正整数$n,m$，表示地点的个数和操作的个数。 第二行包含$n$个非负整数，其中第$i$个数为第个地点最开始刷卡机的台数。 接下来有$m$行，每行包含三个非负整数$P,A,B$，$P$为事件类型，$A,B$为事件的两个参数。 最初所有地点之间都没有跑道。 每行相邻的两个数之间均用一个空格隔开。表示地点编号的数均在$1$到$n$之间，每个地点的刷卡机台数始终不超过$10000$，$P=1,2,3$。 输出格式输出的行数等于第3类事件的个数，每行表示一个第3类事件。如果该情况下存在一种设定跑道方向的方案和路径的方案，可以到达，则输出最多可以刷卡的次数。如果A不能到达B，则输出$-1$。 题解LCT维护边双连通分量 说是叫边双连通分量，其实就是在连边导致产生环时把环缩成一个点 例如此题，显然，如果进入了一个环的某个点，那么就一定能把这个环上所有点全部走完，然后再从任意一个点出去 所以可以把所有环缩成点，点权为环上所有点权之和，这样原图就变成了一棵树，每次直接查询A所在的环到B所在的环之间路径的点权和即可 然后此题就做完了 实现也非常简单，可以开并查集来记录两个点是否在同一个边双里，大部分操作与普通的LCT无异，但是有一些细节： LCT内部维护一个并查集记录两个点是否在同一个边双内，外部还要维护一个并查集记录两个点当前是否联通 access时跳父亲要跳到find(fa[x])上，更改重儿子时还要记得把新的重儿子的父亲设为自己！ 如果在两点之间连边时，两点已在同一棵树中，但不在同一个边双中，则要把两点之间的路径上的点合并为一个点： 123456789101112inline void merge(int x, int y) &#123; split(x, y); q.push(y); while (!q.empty()) &#123; int u = q.front(); q.pop(); Fa[find(u)] = y; if (ch[u][0]) q.push(ch[u][0]); if (ch[u][1]) q.push(ch[u][1]); ch[u][0] = ch[u][1] = 0; //把儿子清零避免pushup时出错！ &#125; val[y] = sum[y]; &#125; 进行任何操作时(例如link,split)，都是对find(x)进行修改，而不是$x$！ 更多细节详见代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;#define N 150005using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f; &#125;namespace LCT&#123; int Fa[N], fa[N], ch[N][2], sum[N], val[N], tag[N]; int find(int x) &#123; return Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline void pushup(int x) &#123; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; &#125; inline void rev(int x) &#123; swap(ch[x][0], ch[x][1]); tag[x] ^= 1; &#125; inline void pushdown(int x) &#123; if (!tag[x]) return; tag[x] = 0; if (ch[x][0]) rev(ch[x][0]); if (ch[x][1]) rev(ch[x][1]); &#125; inline void rotate(int x) &#123; int y = fa[x], z = fa[y], k = (ch[y][1]==x); if (!isroot(y)) ch[z][ch[z][1]==y] = x; fa[x] = z; ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y; ch[x][!k] = y; fa[y] = x; pushup(y); pushup(x); &#125; int stk[N], top; inline void splay(int x) &#123; stk[top=1] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x)) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) ((ch[y][1]==x)^(ch[z][1]==y)) ? rotate(x) : rotate(y); rotate(x); &#125; &#125; inline void access(int x) &#123; for (int i = 0; x; i = x, x = find(fa[x])) &#123; splay(x); ch[x][1] = i; if (i) fa[i] = x; pushup(x); &#125; &#125; inline void makeroot(int x) &#123; access(x); splay(x); rev(x); &#125; inline void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125; inline void link(int x, int y) &#123; makeroot(x); fa[x] = y; &#125; queue&lt;int&gt; q; inline void merge(int x, int y) &#123; split(x, y); q.push(y); while (!q.empty()) &#123; int u = q.front(); q.pop(); Fa[find(u)] = y; if (ch[u][0]) q.push(ch[u][0]); if (ch[u][1]) q.push(ch[u][1]); ch[u][0] = ch[u][1] = 0; &#125; val[y] = sum[y]; &#125;&#125;int n, m, Fa[N], a[N];int find(int x) &#123; return Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;void Link(int x, int y) &#123; int fx = LCT::find(x), fy = LCT::find(y); if (fx == fy) return; int u = find(x), v = find(y); if (u != v) &#123; Fa[u] = v; LCT::link(fx, fy); &#125; else &#123; LCT::merge(fx, fy); &#125; &#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = LCT::val[i] = read(); for (int i = 1; i &lt;= n; i++) Fa[i] = LCT::Fa[i] = i; for (int i = 1, tp, x, y; i &lt;= m; i++) &#123; tp = read(); x = read(); y = read(); if (tp == 1) &#123; Link(x, y); &#125; else if (tp == 2) &#123; int v = y - a[x]; a[x] = y; int fx = LCT::find(x); LCT::makeroot(fx); LCT::val[fx] += v; LCT::pushup(fx); &#125; else &#123; if (find(x) != find(y)) puts(\"-1\"); else &#123; int fx = LCT::find(x), fy = LCT::find(y); LCT::split(fx, fy); printf(\"%d\\n\", LCT::sum[fy]); &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"}]},{"title":"我们的CPU遭到攻击[LOJ558]","slug":"我们的CPU遭到攻击-LOJ558","date":"2020-08-06T12:36:25.000Z","updated":"2020-10-08T12:16:08.441Z","comments":true,"path":"post/53e0f243.html/","link":"","permalink":"http://akdream.tk/post/53e0f243.html/","excerpt":"","text":"题目描述给你一个有$n$个点的森林，点有黑白两种颜色，初始时所有点都是白色，森林的每条边有边权，初始时这个森林有$m$条边。 对这个森林进行$k$次操作，操作有三种： L u v w：添加一条连接$u$和$v$，长度为$w$的边。 C u v：删除连接$u$和$v$的边（保证存在）。 F u：反转点$u$的颜色（黑变白，白变黑）。 Q u：询问所有与$u$相连的黑点到$u$的距离之和。（相连指的是在同一连通块中） 输入格式第一行三个非负整数，分别表示$n,m,k$。以下$m$行，每行三个整数$u,v,w$，表示初始时有一条边连接$u$和$v$，长度为$w$。以下$k$行，每行描述一个操作，格式如上所述。 输出格式对于每个 Q 操作，单独一行输出一个整数表示答案。 保证任何时候这个图都是一个森林。 题解LCT维护子树信息 假设现在需要用LCT维护原树中一个子树的$siz$ 为了方便查询，一般会把原树中一条重链的顶端$x$这个点的子树信息存储在($x$在LCT中所在的二叉树的根)的位置 如上图，原树中的$siz[1]$实际上存在LCT中的$siz[3]$里，而$siz[1]$里存的其实是$1$和$2$的权值和 但是一个点子树的$siz$不仅包含自己所在的那条重链啊 如何维护轻子树的大小？ 很简单，我们记$lsiz[x]$表示LCT中$x$的所有轻子树的$siz$之和，这样$siz[x]$就等于$siz[lson]+siz[rson]+lsiz[x]+1$ 如何维护$lsiz$呢？首先，在link(x,y)操作时$y$会变成$x$的一个新的轻儿子，所以$lsiz[x]$要加上$siz[y]$ 其次，access时经过的点的重儿子变成了轻儿子，而某个轻儿子变成了重儿子，要注意更新$lsiz$ 总之记住轻儿子发生变化的时候记得更新$lsiz$即可 但是实际应用中我们肯定不会用LCT去维护子树$siz$这种这么简单的东西的(好像还真有，而且不少)，所以来看看这道题 对于询问操作，其实我们可以通过LCT来做一个makeroot(u)的操作，这样每次询问就变成了询问所有黑点到根的距离之和了 对于每条边$u,v$，新建一个点$w$，把$w$的点权设为边权，把$u,v$的点权设为$0$，然后在LCT中连$u,w$和$w,v$，这样询问路径长度就变成询问路径上的点权和了 对于点$x$如何统计答案？ 这里是一张LCT的部分图，图中的箭头表示某一个点走到根应该沿什么方向走 由于LCT中左子树的点在原树中深度较小，所以应该向左走 我们设$sum[x]$表示LCT中$x$子树的点权和，$siz[x]$表示有多少个黑点，$lsiz[x]$表示$x$的所有轻子树中共有多少个黑点 不难发现，如果图中所有点想要从$x$开始走到$x$所在重链的顶端，那么需要走过的路径长度是$sum[lson]+val[x]$ 有多少个点要走过去呢？$lsiz[x]+siz[rson]$个，如果$x$也是黑点就还要额外+1 所以这里$x$的答案就是$(sum[lson]+val[x])*(lsiz[x]+siz[rson]+color[x])$ 累加答案也可以用类似的方法 即$ans[x]=ans[lson]+ans[rson]+lightans[x]$；$lightans[x]$就是轻子树的答案之和 然后是一些细节： 进行access时，某个重儿子变成了轻儿子，而轻儿子变成了重儿子，所以要记得更新$lsiz[x]$之类的东西 注意，执行makeroot操作时翻转了整棵LCT，所以我们不仅要记录从右子树向左子树走的答案，还要记录从左到右的答案，这样才能$O(1)$翻转 时间复杂度$O(n\\log n)$ 代码还算较为好写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;#define N 1000005 using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char cch = getchar(); for (; cch &gt; '9' || cch &lt; '0'; cch = getchar()) if (cch == '-') f = -1; for (; cch &lt;= '9' &amp;&amp; cch &gt;= '0'; cch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (cch ^ '0'); num = x * f; &#125;template&lt;typename T&gt;inline void write(T num) &#123; if (num &lt; 0) putchar('-'), num = -num; if (num &gt; 9) write(num / 10); putchar(num % 10 + '0');&#125;int n, tot, m, q, ch[N][2], fa[N];ll siz[N], lsiz[N], tp[N], sum[N], val[N], lans[N], rans[N], light[N], tag[N];inline void pushup(int x) &#123; siz[x] = lsiz[x] + siz[ch[x][0]] + siz[ch[x][1]] + tp[x]; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; lans[x] = lans[ch[x][0]] + lans[ch[x][1]] + light[x]; lans[x] += (sum[ch[x][0]] + val[x]) * (lsiz[x] + siz[ch[x][1]] + tp[x]); rans[x] = rans[ch[x][0]] + rans[ch[x][1]] + light[x]; rans[x] += (sum[ch[x][1]] + val[x]) * (lsiz[x] + siz[ch[x][0]] + tp[x]);&#125;inline void rev(int x) &#123; swap(ch[x][0], ch[x][1]); swap(lans[x], rans[x]); tag[x] ^= 1;&#125;inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125;inline void pushdown(int x) &#123; if (!tag[x]) return; if (ch[x][1]) rev(ch[x][1]); if (ch[x][0]) rev(ch[x][0]); tag[x] = 0;&#125;inline void rotate(int x) &#123; int y = fa[x], z = fa[y], k = (ch[y][1] == x); if (!isroot(y)) ch[z][ch[z][1]==y] = x; fa[x] = z; ch[y][k] = ch[x][k^1]; fa[ch[x][k^1]] = y; ch[x][k^1] = y; fa[y] = x; pushup(y); pushup(x);&#125;int stk[N], top;inline void splay(int x) &#123; stk[top=1] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x)) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) &#123; ((ch[y][1] == z) ^ (ch[z][1] == y)) ? rotate(x) : rotate(y); &#125; rotate(x); &#125; &#125;inline void access(int x) &#123; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x); lsiz[x] -= (siz[i] - siz[ch[x][1]]); light[x] -= (lans[i] - lans[ch[x][1]]); ch[x][1] = i; pushup(x); &#125;&#125;inline void makeroot(int x) &#123; access(x); splay(x); rev(x);&#125;inline void link(int x, int y) &#123; makeroot(x); makeroot(y); fa[x] = y; lsiz[y] += siz[x]; light[y] += lans[x]; pushup(y);&#125;inline void cut(int x, int y) &#123; makeroot(x); access(y); splay(y); ch[y][0] = fa[x] = 0; pushup(y); &#125;map&lt;pair&lt;int, int&gt; , int&gt; mp;int main() &#123; read(n); read(m); read(q); tot = n; for (int i = 1, u, v; i &lt;= m; i++) &#123; read(u); read(v); read(val[++tot]); link(u, tot); link(v, tot); mp[make_pair(u, v)] = mp[make_pair(v, u)] = tot; &#125; char s[5]; for (int i = 1, x, y; i &lt;= q; i++) &#123; scanf(\"%s\", s); if (s[0] == 'L') &#123; read(x); read(y); read(val[++tot]); link(x, tot); link(y, tot); mp[make_pair(x, y)] = mp[make_pair(y, x)] = tot; &#125; else if (s[0] == 'C') &#123; read(x); read(y); int z = mp[make_pair(x, y)]; mp[make_pair(x, y)] = mp[make_pair(y, x)] = 0; cut(x, z); cut(y, z); &#125; else if (s[0] == 'F') &#123; read(x); makeroot(x); tp[x] ^= 1; pushup(x); &#125; else &#123; read(x); makeroot(x); write(lans[x]); puts(\"\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"}]},{"title":"历史[ZJOI2018]","slug":"历史-ZJOI2018","date":"2020-08-06T12:34:59.000Z","updated":"2020-11-12T10:11:07.567Z","comments":true,"path":"post/5fefa37.html/","link":"","permalink":"http://akdream.tk/post/5fefa37.html/","excerpt":"","text":"题目描述&amp;输入/输出格式[ZJOI2018]历史 题解首先，没有修改时的答案可以使用树形DP解决 上图中，红色数字表示$a_x$，蓝色数字表示$x$子树的点权和$sum_x$ 观察点$2$，显然只有$2,5,6$”崛起”时才有可能在$2$发动战争 显然，当操作顺序形如$5,2,5,6$时，会在$2$进行三次战争，为最大值。 再来看点$1$，其实我们可以把$2,5,6$三个点看作一个点，因为$2,5,6$两两的LCA都为$2$，若某时刻$6$在$5$之后一个崛起，则只会在$2$进行战争，而不会在$1$进行战争 于是此时可以把$sum_2$的点权看作$2$的点权，则此时一种最优的操作顺序为$2,1,2,3,2,2$，在$1$发动五次战争 接着再来找找规律，发现$sum_2=4$，而存在一种操作方案(即上面的$5,2,5,6$)使得相邻两次崛起的城市不相同，所以此时最多在$2$发动$sum_2-1$次战争 而$1$就不存在一种相邻元素不相同的操作方案了，因为来自$2$的操作次数过多 我们记$mx[u]=\\max(\\max_{u,v\\in E} sum[v]\\ , a[u])$， 比如$mx[1]=\\max(sum[2],sum[3],sum[4],a[1])=4$， $ans[x]$为最多在$x$发动多少次战争，则存在这样一个规律： 若$mx[x]*2\\ge sum[x]+1$，则$ans[x]=2*(sum[x]-mx[x])$否则$ans[x]=sum[x]-1$ 然后按照上面的式子进行DP即可拿到30分的暴力分 如何处理修改？ 发现每个点$x$最多有一个儿子$y$满足$sum[y]*2\\ge sum[x]+1$，我们定义这个儿子$y$为$x$的”重”儿子 注意 一个点$x$可能没有任何”重”儿子 维护一棵没有makeroot操作的伪LCT，初始时每个点$x$向”重”儿子连实边，向其他儿子连轻边 每次修改时，从被修改的点$x$开始向上access，沿途把某些满足上述条件的轻边修改为重边，把不满足条件的重边修改成轻边 代码如下 1234567891011121314151617181920212223242526272829303132inline void calc(int x) &#123; CCF -= ans[x]; //不要在意变量名 if (son[x]) ans[x] = 2 * (sum[x] - sum[son[x]]); //如果有\"重\"儿子 else if (a[x] * 2 &gt; sum[x] + 1) ans[x] = 2 * (sum[x] - a[x]); //如果自己点权过大 else ans[x] = sum[x] - 1; //没有点权过大的点或子树 CCF += ans[x];&#125;void access(int x, int v) &#123; a[x] += v; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x); sum[x] += v; if (ch[x][0]) sum[ch[x][0]] += v, tag[ch[x][0]] += v; //给重链上的祖先打标记 //要打标记是因为没有makeroot,没法用split把路径分割出来 //只能通过把重链打上标记来加 if (son[x]) &#123; stk[top=1] = son[x]; for (int j = son[x]; !isroot(j); j = fa[j]) stk[++top] = fa[j]; while (top) pushdown(stk[top--]); //pushdown确保sum[son[x]]的值正确 if (sum[son[x]] * 2 &lt;= sum[x] + 1) ch[x][1] = 0, son[x] = 0; //判断还有没有\"重\"儿子 &#125; int F = findroot(i); //找到轻子树的深度最小的节点 //它的sum才是整棵轻子树的sum if (sum[F] * 2 &gt; sum[x] + 1) ch[x][1] = F, son[x] = F; //找到新的\"重\"儿子 calc(x); //更新答案 &#125;&#125; 那个CCF变量维护的就是答案 注释应该足够详细了 LCT中的其他操作，例如findroot和pushdown，与原来无异 关于此题时间复杂度 复杂度由于重边轻边的不确定性，非常玄学。。。也许是$O(1000ms)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;#define N 400005using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ccf = getchar(); for (; ccf &gt; '9' || ccf &lt; '0'; ccf = getchar()) if (ccf == '-') f = -1; for (; ccf &lt;= '9' &amp;&amp; ccf &gt;= '0'; ccf = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ccf ^ '0'); num = x * f;&#125; template&lt;typename T&gt;void write(T num) &#123; if (num &lt; 0) putchar('-'), num = -num; if (num &gt; 9) write(num / 10); putchar(num % 10 +'0');&#125;int n, m;int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;ll CCF, a[N], sum[N], ans[N];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; &#125;namespace Main&#123; int fa[N], son[N], ch[N][2]; ll tag[N]; inline void calc(int x) &#123; CCF -= ans[x]; if (son[x]) ans[x] = 2 * (sum[x] - sum[son[x]]); //如果有\"重\"儿子 else if (a[x] * 2 &gt; sum[x] + 1) ans[x] = 2 * (sum[x] - a[x]); //如果自己点权过大 else ans[x] = sum[x] - 1; //没有点权过大的点或子树 CCF += ans[x]; &#125; void dfs(int x) &#123; sum[x] = a[x]; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x]) continue; fa[y] = x; dfs(y); sum[x] += sum[y]; if (!son[x] || sum[son[x]] &lt; sum[y]) son[x] = y; &#125; if (sum[son[x]] * 2 &lt;= sum[x] + 1) son[x] = 0; calc(x); ch[x][1] = son[x]; &#125; inline void pushdown(int x) &#123; if (!x || !tag[x]) return; if (ch[x][0]) &#123; tag[ch[x][0]] += tag[x]; sum[ch[x][0]] += tag[x]; &#125; if (ch[x][1]) &#123; tag[ch[x][1]] += tag[x]; sum[ch[x][1]] += tag[x]; &#125; tag[x] = 0; &#125; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline void rotate(int x) &#123; int y = fa[x], z = fa[y], k = (ch[y][1]==x); if (!isroot(y)) ch[z][ch[z][1]==y] = x; fa[x] = z; ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y; ch[x][!k] = y; fa[y] = x; &#125; int stk[N], top; inline void splay(int x) &#123; stk[top=1] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x)) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) ((ch[y][1]==x)^(ch[z][1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline int findroot(int x) &#123; while (ch[x][0]) pushdown(x), x = ch[x][0]; return x; &#125; void access(int x, int v) &#123; a[x] += v; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x); sum[x] += v; if (ch[x][0]) sum[ch[x][0]] += v, tag[ch[x][0]] += v; //给重链上的祖先打标记 //要打标记是因为没有makeroot,没法用split把路径分割出来 //只能通过把重链打上标记来加 if (son[x]) &#123; stk[top=1] = son[x]; for (int j = son[x]; !isroot(j); j = fa[j]) stk[++top] = fa[j]; while (top) pushdown(stk[top--]); //pushdown确保sum[son[x]]的值正确 if (sum[son[x]] * 2 &lt;= sum[x] + 1) ch[x][1] = 0, son[x] = 0; //判断还有没有\"重\"儿子 &#125; int F = findroot(i); //找到轻子树的深度最小的节点 //它的sum才是整棵轻子树的sum if (sum[F] * 2 &gt; sum[x] + 1) ch[x][1] = F, son[x] = F; //找到新的\"重\"儿子 calc(x); //更新答案 &#125; &#125; void solve() &#123; dfs(1); printf(\"%lld\\n\", CCF); for (int i = 1, x, w; i &lt;= m; i++) &#123; read(x); read(w); access(x, w); printf(\"%lld\\n\", CCF); &#125; &#125;&#125;int main() &#123; read(n); read(m); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1, u, v; i &lt; n; i++) &#123; read(u); read(v); addedge(u, v); &#125; Main::solve(); return 0;&#125;","categories":[],"tags":[{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"},{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"字符串[LOJ6517]","slug":"字符串-LOJ6517","date":"2020-08-02T14:15:29.000Z","updated":"2020-10-08T12:16:08.352Z","comments":true,"path":"post/b4d563a7.html/","link":"","permalink":"http://akdream.tk/post/b4d563a7.html/","excerpt":"","text":"题目描述有$N$个字符串，每个字符串有一个权值$v_i$。随后给出$M$次询问，每次对一个区间进行检测。令最长的字符串长度为$L$，那么会给出$g_1,\\cdots,g_L$表示每个长度的字符串的「识别值」。 对若干个字符串构成的集合$P$进行测试的过程如下： 对字符串$S$定义$f(S)$表示$S$在$P$中以其为前缀出现的串的权值和。 那么如果$S$在$P$中作为前缀出现过，并且$B*f(S)+A*\\mathrm{len}(S)\\ge C$，那么则将$g_{\\mathrm{len}(S)}$加入集合。 最后随机选择一个区间$[x,y]\\ (1\\le x\\le y\\le L)$，如果 $[x, y] \\bigcap G =\\not \\emptyset$，那么测试成功，否则测试失败。输出测试成功的概率并用最简分数表示。 特别地，整数$k$表示为$k/1$。 输入格式第一行四个数$N, A, B, C$。 接下来一行$N$个数$v_1, \\cdots, v_N$ 接下来一行一个数$M$。 接下来$M$行，每行两个数$l,r$，表示对第$l$到第$r$个字符串进行测试。 输出格式$M$个数表示答案。 题解首先对题目中的$n$个串建出Trie树。显然如果在某一个$P$中有一个串以$S$为前缀出现，那么$S$一定是Trie树上的一个节点，也就是说Trie树上的每个节点都代表着一个$S$ 考虑暴力做法，可以暴力在Trie树上查询$[l,r]$之间的字符串，在Trie树上查询串$i$时，对Trie树上经过的每个节点$S$，令$f(S)$加上$v_i$，然后判断是否满足$B*f(S)+A*\\mathrm{len}(S)\\ge C$，如果满足就把$g_{\\mathrm{len}(S)}$加入集合$G$。 然后考虑怎么统计答案 显然测试成功的概率=1-测试失败的概率 假设集合$G$中从小到大排序有$b_1,b_2,\\cdots,b_k$这$k$个元素，那么测试失败的情况数就是$\\sum\\limits_{i=2}^{k} \\dfrac{(b_i-b_{i-1})(b_i-b_{i-1}-1)}{2}$ 因为如果测试失败，则$[x,y]$必然满足：对于某一个$i$，$b_i &lt; x \\le y &lt; b_{i+1}$ 这样我们就得到了一个$O(nm)$的算法 接下来考虑如何优化 发现询问是区间询问 可以用莫队来处理 需要支持每次在$P$中加入或删除一个字符串 修改时$f(S)$显然是可以在Trie树上维护的 可以证明时间复杂度的上限是$O(L\\sqrt{N})$的 考虑如何维护集合$G$ 我们设$V(x)=\\dfrac{x(x+1)}{2}$，那么如果我们在集合$G$的$b_i$与$b_{i+1}$两个元素中插入一个元素$y$，那么答案就需要减去$V(b_{i+1}-b_i-1)$，然后加上$V(b_{i+1}-y-1)$和$V(y-b_i-1)$ 删除$G$中的一个元素时同理 于是就可以想到一个用set维护$G$的naive做法 每次删除/插入元素$y$时找出它的前驱和后继来修改当前答案 不过这样时间复杂度是$O(M\\sqrt{N}\\log{N})$的 我们需要找到一个可以$O(1)$维护集合$G$的数据结构 链表这种数据结构 删除元素或查找前驱后继是$O(1)$的 但是如果要在指定位置插入元素就会很慢 所以我们可以换用只删除不插入的回滚莫队 这样插入操作就去和梁非凡共进晚餐了 然后我们就把$O(\\log n)$修改的set成功换成了$O(1)$修改的链表 这样就得到了一个上限为$O((M+L)\\sqrt{N})$的大常数？算法 可以通过此题 如果没有找到正确思路，代码非常非常难写。。。所以在这里放上注释过的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;nnum) &#123; T x = 0, f = 1; char cch = getchar(); for (; cch &gt; '9' || cch &lt; '0'; cch = getchar()) if (cch == '-') f = -1; for (; cch &lt;= '9' &amp;&amp; cch &gt;= '0'; cch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (cch ^ '0'); nnum = x * f;&#125;int n, st[N], ed[N], bst[N], bed[N], g[N&lt;&lt;2], len[N&lt;&lt;2], m, L, Q, sz, bcnt; char s[N&lt;&lt;2], t[N&lt;&lt;2];bool vis[N&lt;&lt;2];int ch[N&lt;&lt;2][26], tot, in[N], rnk[N&lt;&lt;2], pre[N&lt;&lt;2], nxt[N&lt;&lt;2], num[N&lt;&lt;2], top;ll ans1[N], ans2[N], v[N], cnt[N&lt;&lt;2], nowans, a, b, c;pair&lt;int, pair&lt;int, int&gt; &gt; changed[N&lt;&lt;2];void insert(int l, int r) &#123; //建Trie树 int x = 0; for (int i = l; i &lt;= r; i++) &#123; if (!ch[x][s[i]-'a']) &#123; ch[x][s[i]-'a'] = ++tot; &#125; x = ch[x][s[i]-'a']; len[x] = i - l + 1; &#125;&#125;inline ll calc(ll x) &#123; if (x &lt;= 0) return 0; else return x * (x + 1) / 2;&#125;inline ll V(int x) &#123; if (!cnt[x]) return 0; return 1ll * b * cnt[x] + 1ll * a * len[x]; &#125;void del(int l, int r, int id) &#123; //删除操作，修改点权+修改链表+修改答案 int x = 0; for (int i = l; i &lt;= r; i++) &#123; x = ch[x][s[i]-'a']; cnt[x] -= v[id]; if (V(x) &lt; c &amp;&amp; vis[x]) &#123; //若当前节点不满足条件且现在在集合G里 if (!(--num[g[len[x]]])) &#123; //将g[len_S]的出现次数-1 int y = g[len[x]], _pre = pre[y], _nxt = nxt[y]; nowans -= calc(y - _pre - 1) + calc(_nxt - y - 1); nowans += calc(_nxt - _pre - 1); //修改当前答案 changed[++top] = make_pair(_pre, make_pair(pre[_pre], nxt[_pre])); changed[++top] = make_pair(_nxt, make_pair(pre[_nxt], nxt[_nxt])); //记录一下哪些链表元素被修改了 回滚时暴力修改回去 nxt[_pre] = _nxt; pre[_nxt] = _pre; &#125; vis[x] = 0; &#125; &#125;&#125;void add(int l, int r, int id) &#123; //增加操作，仅修改点权，不修改链表和答案 int x = 0; for (int i = l; i &lt;= r; i++) &#123; x = ch[x][s[i]-'a']; cnt[x] += v[id]; if (V(x) &gt;= c &amp;&amp; !vis[x]) &#123; //若当前节点已满足条件且不在集合G里 num[g[len[x]]]++; vis[x] = 1; &#125; &#125;&#125;struct node&#123; int l, r, id; bool operator &lt; (const node bb) const &#123; return in[l] != in[bb.l] ? l &lt; bb.l : r &gt; bb.r; //由于是只删不增的回滚莫队 所以右端点从大到小排序 &#125;&#125; q[N];int main() &#123; read(n); read(a); read(b); read(c); sz = sqrt(n); bcnt = 1; for (int i = 1; i &lt;= n; i++) &#123; if (i % sz == 1) bst[bcnt] = i; in[i] = bcnt; if (i % sz == 0) bed[bcnt] = i, bcnt++; //表示一个块的起始和结束位置 &#125; if (n % sz == 0) bcnt--; bed[bcnt] = n; for (int i = 1; i &lt;= n; i++) &#123; read(v[i]); &#125; for (int i = 1, l; i &lt;= n; i++) &#123; scanf(\"%s\", t + 1); l = strlen(t + 1); L = max(L, l); st[i] = m + 1; for (int j = 1; j &lt;= l; j++) &#123; s[++m] = t[j]; &#125; ed[i] = m; &#125; for (int i = 1; i &lt;= L; i++) &#123; read(g[i]); &#125; read(Q); for (int i = 1; i &lt;= Q; i++) &#123; read(q[i].l); read(q[i].r); q[i].id = i; &#125; sort(q + 1, q + Q + 1); for (int i = 1; i &lt;= n; i++) &#123; insert(st[i], ed[i]); &#125; num[L+1] = 114514; //哼哼啊啊啊啊 int now = 1, nl = 0, nr = 0; for (int i = 1; i &lt;= bcnt; i++) &#123; nowans = 0; for (int j = bst[i]; j &lt;= n; j++) &#123; add(st[j], ed[j], j); //将 当前块的起始位置 ~ N 的所有字符串加入集合P &#125; int lst = 0; for (int j = 1; j &lt;= L + 1; j++) &#123; if (num[j]) &#123; //预处理出初始链表和初始答案 pre[j] = lst; nxt[lst] = j; nowans += calc(j - lst - 1); lst = j; &#125; &#125; nr = n; //当前右端点从N开始向左移动 while (in[q[now].l] == i) &#123; while (nr &gt; q[now].r) del(st[nr], ed[nr], nr), nr--; top = 0; //右端点的修改不用回滚！ ll tmp = nowans; //记录当前答案 方便查询完这次之后直接改回去 nl = bst[i]; while (nl &lt; q[now].l) del(st[nl], ed[nl], nl), nl++; //删除时 点权，链表，答案可以一起修改 但是撤销时最好要一个一个撤销比较好写 ans1[q[now].id] = nowans; ans2[q[now].id] = 1ll * L * (L+1) / 2; for (int j = q[now].l - 1; j &gt;= bst[i]; j--) add(st[j], ed[j], j); //撤销对Trie树上点权的修改 while (top) &#123; //撤销对链表的修改 pre[changed[top].first] = changed[top].second.first; nxt[changed[top].first] = changed[top].second.second; top--; &#125; nowans = tmp; //撤销对答案的修改 now++; &#125; while (nr &gt;= bst[i]) &#123; //把剩余字符串全部删掉 相当于让P集合回到空集 del(st[nr], ed[nr], nr); nr--; &#125; &#125; for (int i = 1; i &lt;= Q; i++) &#123; ans1[i] = ans2[i] - ans1[i]; if (ans1[i] == 0) puts(\"0/1\"); else if (ans1[i] == ans2[i]) puts(\"1/1\"); else &#123; ll gcd = __gcd(ans1[i], ans2[i]); ans1[i] /= gcd; ans2[i] /= gcd; printf(\"%lld/%lld\\n\", ans1[i], ans2[i]); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"},{"name":"Trie树","slug":"Trie树","permalink":"http://akdream.tk/tags/Trie%E6%A0%91/"}]},{"title":"奥运公交[LOJ3255]","slug":"奥运公交-LOJ3255","date":"2020-07-31T14:18:32.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/b8eba3fa.html/","link":"","permalink":"http://akdream.tk/post/b8eba3fa.html/","excerpt":"","text":"题目描述JOI 王国共有$N$个城市，这些城市从$1$到$N$编号。共有$M$条公交线路连接这些城市，这些线路从$1$到$M$编号。第$i$条公交线是从城市$U_i$到城市$V_i$的，票价为$C_i$日元。如果乘客乘坐第$i$条公交线，他只能在城市$U_i$上车，在城市$V_i$下车。从一个城市到另一个城市可能有多条公交线。 不久，JOI 王国将举办奥运会。K 理事长是 JOI 王国交通部部长。他会在奥运会之前选择最多一条公交线，并翻转这条公交线的起点和终点，但不改变票价。换句话说，如果他选择第 条公交线，在奥运会期间它将不会从$U_i$城市开往$V_i$城市，而是从$V_i$城市开往$U_i$城市，但票价仍为$C_i$日元。翻转一条公交线需要$D_i$日元，并且这个钱是 K 理事长出的。为了避免迷惑行为，在奥运会期间不允许翻转公交线。 因为 K 理事长是 JOI 王国的交通部部长，在奥运会期间他会使用这些公交线在城市$1$和城市$N$之间往返。通过恰当地选择翻转某条（或不翻转任何）公交线，他想要最小化往返城市$1$和城市$N$的公交总票价与翻转公交线的代价和。 现给定城市数和公交线情况，写一个程序求出这个最小代价和。如果不能通过翻转某条公交线来达到往返城市$1$与城市$N$的目的，请输出$-1$。 输入格式第一行两个整数$N,M$，意义如题目描述； 接下来$M$行，每行四个整数$U_i,V_i,C_i,D_i$，意义如题目描述。 输出格式输出一行一个整数，如果可以通过翻转某条（或不翻转任何）公交线使得可以往返于城市$1$与城市$N$，输出往返所需公交总票价与翻转公交线的代价和的最小值，否则输出$-1$。 题解翻转一条边$u,v$后$1$到$N$的最短路： (1) 不经过翻转后的边$v,u$：由于这种情况中我们不经过这条边 所以可以看作是删除了这条边 如果$u,v$在以$1$为源的最短路树上，那么删除这条边之后$1$到$N$的最短路可能会发生变化，需要重新跑一次 dijkstra (注意是不经过边$u,v$的) 如果不在最短路树上，则删除该边后$1$到$N$的最短路一定和原来的一样 (2) 经过翻转后的边$v,u$：此时$1$到$N$的最短路为： $1$到$v$的不经过边$u,v$的最短路 +$u$到$N$的不经过边$u,v$的最短路 +$\\mathrm{dis}(v,u)$ 求$1$到$v$的不经过边$u,v$的最短路同(1) 求$u$到$N$的不经过边$u,v$的最短路 可以在反图上找出以$N$为源的最短路树，然后判断$u,v$是否在这棵最短路树上，同(1)一样进行分类讨论 对于每条边$i$，我们可以开一个$mn[i]$取上面两种情况的最小值，这就是翻转边$u_i,v_i$后$1$到$N$的最短路 翻转某边后$N$到$1$的最短路同理，可以存在$mn2[i]$中 那么答案就是$\\min_{i=1}^{m} mn[i]+mn2[i]+D_i$ 最后记得计算一下不翻转边时的总代价 p.s. inf最好不要设得太大 不然好几个inf加一起就爆longlong了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#define M 100005using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;const ll inf = 1e16;int n, m;int head[205][2], lst[205][2], from[M][2], pre[M][2], to[M][2], sz[2]; //0:原图 1:反图 ll c[M][2], d[M][2], ans, mn[M][2];bool ok[M][2];inline void addedge(int u, int v, ll w, ll w2, int tp) &#123; pre[++sz[tp]][tp] = head[u][tp]; head[u][tp] = sz[tp]; ok[sz[tp]][tp] = 1; from[sz[tp]][tp] = u; to[sz[tp]][tp] = v; c[sz[tp]][tp] = w; d[sz[tp]][tp] = w2;&#125;priority_queue&lt;pair&lt;ll, int&gt; &gt; q;ll dis[205][2], tmp[205]; bool vis[205], tag[M][2];void dijkstra(int s, int tp) &#123; for (int i = 1; i &lt;= n; i++) dis[i][tp] = inf; dis[s][tp] = 0; memset(vis, 0, sizeof(vis)); q.push(make_pair(0, s)); while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = 1; for (int i = head[x][tp]; i; i = pre[i][tp]) &#123; int y = to[i][tp]; if (dis[y][tp] &gt; dis[x][tp] + c[i][tp]) &#123; dis[y][tp] = dis[x][tp] + c[i][tp]; lst[y][tp] = i; q.push(make_pair(-dis[y][tp], y)); &#125; &#125; &#125;&#125;void tmp_dij(int s, int tp) &#123; for (int i = 1; i &lt;= n; i++) tmp[i] = inf; tmp[s] = 0; memset(vis, 0, sizeof(vis)); q.push(make_pair(0, s)); while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = 1; for (int i = head[x][tp]; i; i = pre[i][tp]) &#123; int y = to[i][tp]; if (!ok[i][tp]) continue; if (tmp[y] &gt; tmp[x] + c[i][tp]) &#123; tmp[y] = tmp[x] + c[i][tp]; q.push(make_pair(-tmp[y], y)); &#125; &#125; &#125;&#125;void solve(int s, int t, int o) &#123; dijkstra(s, 0); dijkstra(t, 1); memset(tag, 0, sizeof(tag)); for (int i = 1; i &lt;= n; i++) &#123; tag[lst[i][0]][0] = 1; tag[lst[i][1]][0] = 1; &#125; for (int i = 1; i &lt;= sz[0]; i++) &#123; int u = from[i][0], v = to[i][0]; ll now = c[i][0]; if (!tag[i][0]) &#123; mn[i][o] = dis[t][0]; now += dis[v][0]; &#125; else &#123; ok[i][0] = 0; tmp_dij(s, 0); ok[i][0] = 1; mn[i][o] = tmp[t]; now += tmp[v]; &#125; if (!tag[i][1]) &#123; now += dis[u][1]; &#125; else &#123; ok[i][1] = 0; tmp_dij(t, 1); ok[i][1] = 1; now += tmp[u]; &#125; mn[i][o] = min(mn[i][o], now); &#125;&#125;int main() &#123; read(n); read(m); for (int i = 1, u, v; i &lt;= m; i++) &#123; ll cc, dd; read(u); read(v); read(cc); read(dd); addedge(u, v, cc, dd, 0); addedge(v, u, cc, dd, 1); &#125; ans = inf; ll now = 0; dijkstra(1, 0); now += dis[n][0]; dijkstra(n, 0); now += dis[1][0]; ans = min(ans, now); solve(1, n, 0); solve(n, 1, 1); for (int i = 1; i &lt;= sz[0]; i++) &#123; ans = min(ans, mn[i][0] + mn[i][1] + d[i][0]); &#125; printf(\"%lld\\n\", ans &gt;= inf ? -1 : ans); return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"BLO-Blockade[POI2008]","slug":"BLO-Blockade-POI2008","date":"2020-07-31T13:50:45.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/5959e41f.html/","link":"","permalink":"http://akdream.tk/post/5959e41f.html/","excerpt":"","text":"题目描述在Byteotia有$n$个城镇。 一些城镇之间由无向边连接。在城镇外没有十字路口，尽管可能有桥，隧道或者高架公路（反正不考虑这些）。每两个城镇之间至多只有一条直接连接的道路。人们可以从任意一个城镇直接或间接到达另一个城镇。每个城镇都有一个公民，他们被孤独所困扰。事实证明，每个公民都想拜访其他所有公民一次（在主人所在的城镇）。所以，一共会有$n*(n-1)$次拜访。 不幸的是，一个程序员总罢工正在进行中，那些程序员迫切要求购买某个软件。作为抗议行动，程序员们计划封锁一些城镇，阻止人们进入，离开或者路过那里。正如我们所说，他们正在讨论选择哪些城镇会导致最严重的后果。 编写一个程序： 读入Byteotia的道路系统，对于每个被决定的城镇，如果它被封锁，有多少访问不会发生，输出结果。 输入格式第一行读入$n，m (1\\le n\\le 100\\ 000, 1\\le m\\le 500\\ 000)$，分别是城镇数目和道路数目 城镇编号$1\\sim n$ 接下来$m$行每行两个数字$a,b (1\\le a&lt;b\\le n)$，表示$a$和$b$之间有一条无向边 输出格式输出$n$行，每行一个数字，为第$i$个城镇被锁时不能发生的访问的数量。 题解显然，只有被封锁的点为割点时，才会出现无法访问的情况 所以求出所有点双连通分量，对原图建出圆方树，只需要找出对于每个非叶子的圆点(原图中的割点)，有多少条圆点到圆点的路径经过它。当这个割点被封锁后，这些路径就无法访问了 把圆点的权值看作$1$，方点权值看作$0$，然后维护子树权值和就可以求出答案 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, nn, m;int head[100005], pre[1000005], to[1000005], sz;int siz[200005];ll ans[100005];void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;int dfn[100005], low[100005], tme, q[100005], top;bool gd[100005];vector&lt;int&gt; e[200005];void tarjan(int x) &#123; dfn[x] = low[x] = ++tme; q[++top] = x; int now = 0; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; n++; int z = 0; do &#123; z = q[top]; e[n].push_back(z); e[z].push_back(n); top--; &#125; while (z != y); e[n].push_back(x); e[x].push_back(n); &#125; &#125; else &#123; low[x] = min(low[x], dfn[y]); &#125; &#125;&#125;void dfs(int x, int fa) &#123; if (x &lt;= nn) siz[x] = 1; for (auto y : e[x]) &#123; if (y == fa) continue; dfs(y, x); if (x &lt;= nn) &#123; ans[x] += 1ll * siz[x] * siz[y]; &#125; siz[x] += siz[y]; &#125; if (x &lt;= nn) &#123; ans[x] += 1ll * siz[x] * (nn - siz[x]); &#125;&#125;int main() &#123; read(n); nn = n; read(m); for (int i = 1; i &lt;= m; i++) &#123; int a, b; read(a); read(b); addedge(a, b); &#125; tarjan(1); dfs(1, 0); for (int i = 1; i &lt;= nn; i++) &#123; printf(\"%lld\\n\", ans[i] * 2); //u-&gt;v和v-&gt;u都要算 &#125; return 0;&#125;","categories":[],"tags":[{"name":"强/双连通分量","slug":"强-双连通分量","permalink":"http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"压力[BJOI2013]","slug":"压力-BJOI2013","date":"2020-07-31T13:30:21.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/239a758c.html/","link":"","permalink":"http://akdream.tk/post/239a758c.html/","excerpt":"","text":"题目描述如今,路由器和交换机构建起了互联网的骨架。处在互联网的骨干位置的核心路由器典型的要处理100Gbit/s的网络流量。他们每天都生活在巨大的压力之下。小强建立了一个模型。这世界上有$N$个网络设备,他们之间有$M$个双向的链接。这个世界是连通的。在一段时间里,有$Q$个数据包要从一个网络设备发送到另一个网络设备。一个网络设备承受的压力有多大呢?很显然,这取决于$Q$个数据包各自走的路径。不过,某些数据包无论走什么路径都不可避免的要通过某些网络设备。你要计算：对每个网络设备,必须通过(包括起点、终点)他的数据包有多少个? 输入格式第一行包含3个由空格隔开的正整数$N,M,Q$。 接下来$M$行,每行两个整数$u,v$,表示第$u$个网络设备(从$1$开始编号)和第$v$个网络设备之间有一个链接。$u$不会等于$v$。两个网络设备之间可能有多个链接。 接下来$Q$行,每行两个整数$p,q$,表示第$p$个网络设备向第$q$个网络设备发 送了一个数据包。$p$不会等于$q$。 输出格式输出$N$行,每行$1$个整数,表示必须通过某个网络设备的数据包的数量。 题解如果有一条路径必须经过某个点$x$，那么显然点$x$必为一个割点。 所以建出原图的圆方树，其中每个非叶子的圆点必然代表着原图的一个割点 然后对于一次$x$到$y$的数据传输，必须经过圆方树上$x,y$两点之间的路径，所以使用树上差分统计每个非叶子圆点被经过多少次即可 时间复杂度$O(n\\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, nn, m, Q;int head[400005], pre[400005], to[400005], sz;void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;int dfn[400005], low[400005], tme, q[400005], top;vector&lt;int&gt; e[400005];int f[400005];void tarjan(int x) &#123; dfn[x] = low[x] = ++tme; q[++top] = x; int now = 0; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); if (dfn[x] &lt;= low[y]) &#123; n++; int z = 0; do &#123; z = q[top]; e[n].push_back(z); e[z].push_back(n); top--; &#125; while (z != y); e[n].push_back(x); e[x].push_back(n); &#125; &#125; else &#123; low[x] = min(low[x], dfn[y]); &#125; &#125;&#125;int d[400005], p[400005][21];void dfs1(int x, int fa) &#123; for (int i = 0; i &lt; e[x].size(); i++) &#123; int y = e[x][i]; if (y == fa) continue; d[y] = d[x] + 1; p[y][0] = x; dfs1(y, x); &#125;&#125;int LCA(int x, int y) &#123; if (d[x] &lt; d[y]) swap(x, y); for (int i = 20; i &gt;= 0; i--) &#123; if (d[x] - (1 &lt;&lt; i) &gt;= d[y]) x = p[x][i]; &#125; if (x == y) return x; for (int i = 20; i &gt;= 0; i--) &#123; if (p[x][i] != p[y][i]) &#123; x = p[x][i]; y = p[y][i]; &#125; &#125; return p[x][0];&#125;void dfs(int x, int fa) &#123; for (int i = 0; i &lt; e[x].size(); i++) &#123; int y = e[x][i]; if (y == fa) continue; dfs(y, x); f[x] += f[y]; &#125;&#125;int main() &#123; read(n); nn = n; read(m); read(Q); for (int i = 1; i &lt;= m; i++) &#123; int a, b; read(a); read(b); addedge(a, b); &#125; tarjan(1); dfs1(1, 0); for (int l = 1; (1 &lt;&lt; l) &lt;= n; l++) &#123; for (int i = 1; i &lt;= n; i++) &#123; p[i][l] = p[p[i][l-1]][l-1]; &#125; &#125; for (int i = 1; i &lt;= Q; i++) &#123; int x, y, lca; read(x); read(y); lca = LCA(x, y); f[x]++; f[y]++; f[lca]--; f[p[lca][0]]--; &#125; dfs(1, 0); for (int i = 1; i &lt;= nn; i++) &#123; printf(\"%d\\n\", f[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"强/双连通分量","slug":"强-双连通分量","permalink":"http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"Earthquake[USACO01OPEN]","slug":"Earthquake-USACO01OPEN","date":"2020-07-31T13:28:45.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/958dddf1.html/","link":"","permalink":"http://akdream.tk/post/958dddf1.html/","excerpt":"","text":"题目描述一场地震把约翰家的牧场摧毁了， 坚强的约翰决心重建家园。 约翰已经重建了$n$个牧场，现在他希望能修建一些道路把它们连接起来。研究地形之后，约翰发现可供修建的道路有$m$条。碰巧的是，奶牛们最近也成立一个工程队，专门从事修复道路。而然，奶牛们很有经济头脑，如果无利可图，它们是不会干的。 奶牛们关注的是挣钱速度，即总利润和总施工时间的比值。约翰和奶牛达成了协议，奶牛负责修建道路，将所有牧场连通，而约翰需要支付$f$元。每条道路都有自己的施工时间和建造成本。连接两个相同的牧场的道路可能有多条。保证所有的牧场必定是可连通的，不过也有可能一些道路的建造成本之和会超过$f$。 请帮助奶牛们选择修复哪些道路，才能使单位时间的利润最大？ 输入格式第一行三个整数$n,m,f$。 第二行到第$m+1$行，第$i+1$行表示第$i$条道路的信息。每行有四个整数$u_i,v_i,c_i,t_i$，$u_i$和$v_i$表示这条道路连接的牧场编号，$c_i$表示修建道路的成本，$t_i$表示道路修建所需要的时间。 输出格式第一行，一个保留四位小数的浮点数，表示奶牛们能挣到的最大单位时间利润，如果奶牛们无钱可赚，则输出 0.0000。 题解我们想要求出$\\dfrac{f-\\sum c_ix_i}{\\sum t_ix_i}$的最大值，其中$x_i=0$或$1$表示第$i$条路修或者不修 不妨设最大值为$P$，则有$\\dfrac{f-\\sum c_ix_i}{\\sum t_ix_i} \\le P$ 变形一下得$\\sum x_i(P*t_i+c_i) \\ge f$ 二分答案$mid$放到不等式中代替$P$，如果$mid &lt; P$，那么不等式左边就会偏小，我们需要找到有没有一种分配$x_i$的情况使得这个不等式不成立，即$\\sum x_i(Pt_i+c_i) &lt; f$ 如果能找到这样的解，则表示$mid &lt; P$，否则$mid \\ge P$ 由于我们想让左式尽可能小，所以把每条边的边权重新设为$mid*t_i+c_i$，然后再跑最小生成树求出左式的最小值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, m, F;struct edge&#123; int u, v, c, t; double val; bool operator &lt; (const edge b) const &#123; return val &lt; b.val; &#125;&#125; e[10005];int fa[405];int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]);&#125;bool check(double k) &#123; for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= m; i++) &#123; e[i].val = e[i].c * 1.0 + k * e[i].t; &#125; sort(e + 1, e + m + 1); double ret = 0; for (int i = 1; i &lt;= m; i++) &#123; int tx = find(e[i].u), ty = find(e[i].v); if (tx != ty) &#123; ret += e[i].val; fa[ty] = tx; &#125; &#125; return ret &lt; F;&#125;int main() &#123; read(n); read(m); read(F); for (int i = 1; i &lt;= m; i++) &#123; read(e[i].u); read(e[i].v); read(e[i].c); read(e[i].t); &#125; double l = 0, r = 2e9, mid = 0; while (r - l &gt; 1e-7) &#123; mid = (l + r) / 2; if (check(mid)) &#123; l = mid + 0.000001; &#125; else r = mid - 0.000001; &#125; printf(\"%.4lf\\n\", l); return 0;&#125;","categories":[],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://akdream.tk/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"01分数规划","slug":"01分数规划","permalink":"http://akdream.tk/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"}]},{"title":"暴力写挂[CTSC2018]","slug":"暴力写挂[CTSC2018]","date":"2020-07-27T14:43:35.000Z","updated":"2020-10-08T12:16:08.530Z","comments":true,"path":"post/476e6451.html/","link":"","permalink":"http://akdream.tk/post/476e6451.html/","excerpt":"","text":"题目描述给定两棵树$T$和$T’$ 求$$\\max(\\operatorname{depth}(x) + \\operatorname{depth}(y) - ({\\operatorname{depth}(\\operatorname{LCA}(x,y))}+{\\operatorname{depth’}(\\operatorname{LCA’}(x,y))}))$$ 注：带[$’$]的表示第二棵树 题解注意到题目给的这个$$\\operatorname{depth}(x) + \\operatorname{depth}(y) - {\\operatorname{depth}(\\operatorname{LCA}(x,y))}-{\\operatorname{depth’}(\\operatorname{LCA’}(x,y))}$$似乎不太好算 我们把前3项转换一下 发现上面这个式子实际上等于$$\\dfrac{1}{2}(\\operatorname{depth}(x) + \\operatorname{depth}(y) + \\operatorname{dis}(x,y) - 2* \\operatorname{depth’}(\\operatorname{LCA’}(x,y)))$$ 这样一来，前三项可以通过边分治处理出来，然后最后一项则需要在第二棵树上来计算 具体地说，我们对第一棵树进行边分治，然后将当前分治边左边的点标为黑点，右边标为白点 假设一个点$x$到分治边的距离为$\\operatorname{d}(x)$，分治边的长度是$v$，那么上面式子的前3项实际上就等于$\\operatorname{depth}(x) + \\operatorname{depth}(y) + (\\operatorname{d}(x) + \\operatorname{d}(y) + v)$ 所以把每个点的点权$\\operatorname{val}(x)$设为$\\operatorname{depth}(x) + \\operatorname{d}(x)$，然后就可以去处理第二棵树了 在第二棵树中枚举每个点作为lca，那么现在目标就是找到两个颜色不同，且在两个不同儿子子树里的点使得它们的$\\operatorname{val}$之和最大 设$f[x][0]$表示$x$子树中最大的黑点权值，$f[x][1]$表示最大白点权值；然后就可以在第二棵树上进行dp来得到最大值 具体dp转移见代码 但是dp一次是$O(n)$的 所以我们还需要在dp之前对第二棵树建虚树 在虚树上dp 这样总时间复杂度就是$O(n\\log^2 n)$的 依然会被卡掉。。。 如果想要$O(n\\log n)$可以加上欧拉序+ST表求LCA以及基数排序建虚树来强行降低复杂度 这里我只写了个$O(1)$求LCA 吸氧后勉强卡过 基数排序什么的表示不懂 代码难度非常非常大 写到心态爆炸 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include &lt;bits/stdc++.h&gt;#define NN 370005using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, q[NN], tp[NN], tot;ll ww[NN], ans = -0x3f3f3f3f3f3f3f3f;namespace p2&#123; int head[NN], dfn[NN], pre[NN&lt;&lt;1], to[NN&lt;&lt;1], sz = 1, tme; ll val[NN&lt;&lt;1]; inline void addedge(int u, int v, int w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w; &#125; int d[NN], p[1000005][21], lg2[1000005]; int stk[NN], top; ll dep[NN], f[NN][2]; bool tag[NN]; void dfs(int x, int fa) &#123; p[++tme][0] = x; dfn[x] = tme; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; d[y] = d[x] + 1; dep[y] = dep[x] + val[i]; dfs(y, x); p[++tme][0] = x; &#125; &#125; inline int LCA(int x, int y) &#123; if (dfn[x] &gt; dfn[y]) swap(x, y); int l = dfn[x], r = dfn[y], len = dfn[y] - dfn[x] + 1; if (d[p[l][lg2[len]]] &lt; d[p[r-(1&lt;&lt;lg2[len])+1][lg2[len]]]) &#123; return p[l][lg2[len]]; &#125; else return p[r-(1&lt;&lt;lg2[len])+1][lg2[len]]; &#125; void init() &#123; dfs(1, 0); for (int i = 2; i &lt;= tme; i++) lg2[i] = lg2[i&gt;&gt;1] + 1; for (int l = 1; (1 &lt;&lt; l) &lt;= tme; l++) &#123; for (int i = 1; i &lt;= tme; i++) &#123; if (d[p[i][l-1]] &lt; d[p[i+(1&lt;&lt;(l-1))][l-1]]) &#123; p[i][l] = p[i][l-1]; &#125; else p[i][l] = p[i+(1&lt;&lt;(l-1))][l-1]; &#125; &#125; memset(head, 0, sizeof(head)); sz = 1; &#125; bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125; void buildtree() &#123; sz = 1; sort(q + 1, q + tot + 1, cmp); for (int i = 1; i &lt;= tot; i++) tag[q[i]] = 1; stk[top=1] = 1; for (int i = 1; i &lt;= tot; i++) &#123; if (q[i] == 1) continue; if (top == 1) &#123; stk[++top] = q[i]; continue; &#125; int lca = LCA(stk[top], q[i]); while (top &gt; 1 &amp;&amp; dfn[stk[top-1]] &gt;= dfn[lca]) &#123; addedge(stk[top], stk[top-1], 0); top--; &#125; if (lca != stk[top]) &#123; addedge(stk[top], lca, 0); stk[top] = lca; &#125; stk[++top] = q[i]; &#125; while (top &gt; 1) &#123; addedge(stk[top], stk[top-1], 0); top--; &#125; &#125; void dp(int x, int fa, ll len) &#123; f[x][0] = f[x][1] = -0x3f3f3f3f3f3f3f3f; if (tag[x]) f[x][tp[x]] = ww[x]; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; dp(y, x, len); ll now = max(f[x][0] + f[y][1], f[x][1] + f[y][0]); ans = max(ans, len + now - 2 * dep[x]); f[x][0] = max(f[x][0], f[y][0]); f[x][1] = max(f[x][1], f[y][1]); &#125; tag[x] = 0; head[x] = 0; &#125; void solve(ll len) &#123; buildtree(); dp(1, 0, len); &#125;&#125;namespace p1&#123; int head[NN&lt;&lt;2], pre[NN&lt;&lt;3], to[NN&lt;&lt;3], sz = 1, N; ll val[NN&lt;&lt;3]; vector&lt;pair&lt;int, ll&gt; &gt; son[NN&lt;&lt;2]; bool vis[NN&lt;&lt;2]; int siz[NN&lt;&lt;2], ct, mn, sum; ll dep[NN&lt;&lt;2]; inline void addedge(int u, int v, ll w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w; &#125; void dfs1(int x, int fa) &#123; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; son[x].push_back(make_pair(y, val[i])); dep[y] = dep[x] + val[i]; dfs1(y, x); &#125; &#125; void rebuild() &#123; memset(head, 0, sizeof(head)); sz = 1; for (int i = 1; i &lt;= N; i++) &#123; int k = son[i].size(); if (k &lt;= 2) &#123; for (int j = 0; j &lt; k; j++) &#123; addedge(i, son[i][j].first, son[i][j].second); &#125; &#125; else &#123; addedge(i, ++N, 0); addedge(i, ++N, 0); for (int j = 0; j &lt; k; j++) &#123; if (j &amp; 1) son[N-1].push_back(son[i][j]); else son[N].push_back(son[i][j]); &#125; &#125; &#125; &#125; void findct(int x, int fa) &#123; siz[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa || vis[i&gt;&gt;1]) continue; findct(y, x); siz[x] += siz[y]; int now = max(siz[y], sum - siz[y]); if (now &lt; mn) &#123; mn = now; ct = i; &#125; &#125; &#125; void dfs(int x, int fa, ll dis, int o) &#123; if (x &lt;= n) &#123; q[++tot] = x; ww[x] = dep[x] + dis; tp[x] = o; &#125; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa || vis[i&gt;&gt;1]) continue; dfs(y, x, dis + val[i], o); &#125; &#125; void divide(int x, int _siz) &#123; ct = 0; mn = 0x7fffffff; sum = _siz; findct(x, 0); if (!ct) return; vis[ct&gt;&gt;1] = 1; int l = to[ct], r = to[ct^1]; tot = 0; dfs(l, 0, 0, 0); dfs(r, 0, 0, 1); if (!tot) return; p2::solve(val[ct]); divide(l, siz[to[ct]]); divide(r, _siz - siz[to[ct]]); &#125;&#125;int main() &#123; read(n); p1::N = n; for (int i = 1, u, v, w; i &lt; n; i++) &#123; read(u); read(v); read(w); p1::addedge(u, v, w); &#125; for (int i = 1, u, v, w; i &lt; n; i++) &#123; read(u); read(v); read(w); p2::addedge(u, v, w); &#125; p1::dfs1(1, 0); p1::rebuild(); p2::init(); p1::divide(1, p1::N); ans &gt;&gt;= 1; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, p1::dep[i] - p2::dep[i]); &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"点/边分治","slug":"点-边分治","permalink":"http://akdream.tk/tags/%E7%82%B9-%E8%BE%B9%E5%88%86%E6%B2%BB/"},{"name":"虚树","slug":"虚树","permalink":"http://akdream.tk/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"维修数列[NOI2005]","slug":"维修数列[NOI2005]","date":"2020-07-27T14:20:34.000Z","updated":"2020-10-08T12:16:08.673Z","comments":true,"path":"post/c8d4ab6b.html/","link":"","permalink":"http://akdream.tk/post/c8d4ab6b.html/","excerpt":"","text":"好久没写题解了 来水一篇题解 题目描述请写一个程序，要求维护一个数列，支持以下 6 种操作： 输入格式输入的第1行包含两个数$N$和$M(M \\leq 20 000)$，$N$表示初始时数列中数的个数，$M$表示要进行的操作数目。 第2行包含$N$个数字，描述初始时的数列。 以下$M$行，每行一条命令，格式参见问题描述中的表格。 任何时刻数列中最多含有$500000$个数，数列中任何一个数字均在$[-1 000, 1 000]$内。 插入的数字总数不超过$4 000 000$个，输入文件大小不超过20MB。 输出格式对于输入数据中的GET-SUM和MAX-SUM操作，向输出文件依次打印结果，每个答案（数字）占一行。 题解一道平衡树维护各种标记以及pushup,pushdown的模板题？ 我这里用的是飞旋非旋Treap，Splay也可以做，但是显然非旋Treap要比较好写 维护最大子段和的套路就是维护区间最大前缀和以及最大后缀和，pushup时： 最大前缀和 = max（左儿子最大前缀和，左儿子区间和+当前节点权值+右儿子最大前缀和）最大后缀和 = max（右儿子最大后缀和，右儿子区间和+当前节点权值+左儿子最大后缀和）最大子段和 = max（ max（左儿子最大子段和，右儿子最大子段和），左儿子最大后缀和+当前节点权值+右儿子最大前缀和） 此题细节特别多： 最大子段不能为空 所以修改时要注意不能让它不含任何元素而子段和等于$0$，尤其是pushup的时候注意 最大前缀和以及最大后缀和可以为空，所以最小也是$0$，不会为负 覆盖标记的初始值不能设成$0$！因为一次操作可能会要求把一段区间全部赋为$0$，可以把覆盖标记初始值设成inf 区间翻转的时候，不光要交换左右儿子，还要交换最大前缀和与最大后缀和！ 在树的结构即将发生变化时，一定要记得先pushdown！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;#define N 500005#define M 4000005using namespace std;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, m, nowtot;int rt, tot, siz[M], val[M], rnd[M], ch[M][2], tag[M], rev[M];int mx[M], sum[M], lmx[M], rmx[M];const int inf = 0x7fffffff;inline int newnode(int v) &#123; tot++; siz[tot] = 1; val[tot] = sum[tot] = v; rnd[tot] = rand(); ch[tot][0] = ch[tot][1] = 0; tag[tot] = inf; rev[tot] = 0; lmx[tot] = rmx[tot] = max(0, v); mx[tot] = v; return tot;&#125;inline void pushup(int x) &#123; siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; lmx[x] = max(lmx[ch[x][0]], sum[ch[x][0]] + val[x] + lmx[ch[x][1]]); rmx[x] = max(rmx[ch[x][1]], sum[ch[x][1]] + val[x] + rmx[ch[x][0]]); lmx[x] = max(lmx[x], 0); rmx[x] = max(rmx[x], 0); mx[x] = rmx[ch[x][0]] + val[x] + lmx[ch[x][1]]; if (ch[x][0]) mx[x] = max(mx[x], mx[ch[x][0]]); if (ch[x][1]) mx[x] = max(mx[x], mx[ch[x][1]]); &#125;inline void change(int x, int v) &#123; val[x] = v; sum[x] = siz[x] * v; lmx[x] = rmx[x] = max(0, siz[x] * v); mx[x] = max(v, siz[x] * v); tag[x] = v;&#125;inline void Rev(int x) &#123; swap(lmx[x], rmx[x]); swap(ch[x][0], ch[x][1]); rev[x] ^= 1;&#125;inline void pushdown(int x) &#123; if (tag[x] != inf) &#123; int v = tag[x]; tag[x] = inf; if (ch[x][0]) change(ch[x][0], v); if (ch[x][1]) change(ch[x][1], v); &#125; if (rev[x]) &#123; if (ch[x][0]) Rev(ch[x][0]); if (ch[x][1]) Rev(ch[x][1]); rev[x] = 0; &#125;&#125;void split(int now, int k, int &amp;x, int &amp;y) &#123; if (!now) &#123; x = y = 0; return; &#125; pushdown(now); if (k &gt; siz[ch[now][0]]) &#123; x = now; split(ch[now][1], k - siz[ch[now][0]] - 1, ch[now][1], y); &#125; else &#123; y = now; split(ch[now][0], k, x, ch[now][0]); &#125; pushup(now);&#125;int merge(int x, int y) &#123; if (!x || !y) return x | y; pushdown(x); pushdown(y); if (rnd[x] &lt; rnd[y]) &#123; ch[x][1] = merge(ch[x][1], y); pushup(x); return x; &#125; else &#123; ch[y][0] = merge(x, ch[y][0]); pushup(y); return y; &#125;&#125;char s[50]; int main() &#123; srand(time(NULL)); read(n); read(m); for (int i = 1, v, x, y; i &lt;= n; i++) &#123; read(v); x = y = 0; split(rt, i - 1, x, y); rt = merge(merge(x, newnode(v)), y); &#125; nowtot = n; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%s\", s); int pos = 0, cnt = 0, v = 0, x = 0, y = 0, z = 0; if (s[0] == 'I') &#123; read(pos); read(cnt); nowtot += cnt; split(rt, pos, x, y); for (int j = 1; j &lt;= cnt; j++) &#123; read(v); x = merge(x, newnode(v)); &#125; rt = merge(x, y); &#125; else if (s[0] == 'D') &#123; read(pos); read(cnt); nowtot -= cnt; split(rt, pos - 1, x, y); split(y, cnt, y, z); rt = merge(x, z); &#125; else if (s[0] == 'R') &#123; read(pos); read(cnt); split(rt, pos - 1, x, y); split(y, cnt, y, z); Rev(y); rt = merge(x, merge(y, z)); &#125; else if (s[0] == 'G') &#123; read(pos); read(cnt); split(rt, pos - 1, x, y); split(y, cnt, y, z); printf(\"%d\\n\", sum[y]); rt = merge(x, merge(y, z)); &#125; else if (s[2] == 'K') &#123; read(pos); read(cnt); read(v); split(rt, pos - 1, x, y); split(y, cnt, y, z); change(y, v); rt = merge(x, merge(y, z)); &#125; else &#123; printf(\"%d\\n\", mx[rt]); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://akdream.tk/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"分零食[JSOI2012]","slug":"分零食[JSOI2012]","date":"2020-06-23T10:39:29.000Z","updated":"2020-10-08T12:16:08.259Z","comments":true,"path":"post/dc9b58a7.html/","link":"","permalink":"http://akdream.tk/post/dc9b58a7.html/","excerpt":"","text":"题目描述题面太长有$n$个人，$m$颗糖，要求给前若干个人分糖(把所有糖分完)，如果一个人得到了$x$颗糖，那他的欢乐度就是$Ox^2+Sx+U$，一个分糖方案的总欢乐度是所有分到糖的人的欢乐度的乘积，求所有可行分糖方案的总欢乐度的总和。 题解首先有一个显然的dp方程： 设$dp[i][j]$表示给前$i$个人分了$j$颗糖，设$f(x)=Ox^2+Sx+U$，则$dp[i][j]=\\sum\\limits_{k=1}^{j-i+1} dp[i-1][j-k]*f(k)$ 答案即为$\\sum\\limits_{i=1}^{n} dp[i][m]$ 考虑如何优化这个式子 如果把$dp[i-1][j-k]*f(k)$看作一个卷积形式的话，我们会发现$dp[i]$这一个数组就是$dp[i-1]$和$f$的卷积 我们把$f$以及$dp[i]$看作一个多项式，那么有$f=f(1)x+f(2)x^2+f(3)x^3+\\dots+f(m)x^m$ 由于$dp[i]=dp[i-1]*f$，所以显然$dp[i]=f^i$(这里的乘方是指$i$次卷积，不是指$i$次方。。。) 可以使用FFT优化卷积 但是$n\\le 10^8$，这样还是跑不过，还需要进行优化： 卷积满足交换律，所以可以进行快速幂优化。但是我们要求的答案是$\\sum\\limits_{i=1}^{n} dp[i][m]$，如果用快速幂的话没法计算答案啊 所以我们再定义一个多项式$sum[i]=\\sum\\limits_{j=1}^i dp[i]$，也就是前缀和 首先要意识到，根据上面的定义$dp[i]=f^i$，那么显然$dp[a+b]=dp[a]*dp[b]$ 然后看一下$sum$是怎么快速幂递推的 假设现在在计算$sum[x]$和$dp[x]$ 若$x$为偶，则$dp[x]=dp[\\frac{x}{2}]*dp[\\frac{x}{2}]$； $sum[x]=sum[\\frac{x}{2}]+\\sum\\limits_{i=x/2+1}^x dp[i]$$=sum[\\frac{x}{2}]+dp[\\frac{x}{2}]\\sum\\limits_{i=1}^{x/2} dp[i]$$=sum[\\frac{x}{2}]+dp[\\frac{x}{2}]*sum[\\frac{x}{2}]$ 若$x$为奇那就先把$dp[x-1]$和$sum[x-1]$用上面的方法算出来，然后$dp[x]=dp[x-1]*f$，$sum[x]=sum[x-1]+dp[x]$ 最后的答案就是$sum[n][m]$ 时间复杂度$O(m\\log m\\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353, G = 3, invg = 332748118;int N, m, lim, l, rev[100005], tot;ll dp[100005], sum[100005], F[100005], tmp[100005], invn, O, S, U, p;ll aa[100005], bb[100005];inline ll fpow(ll x, ll t) &#123; ll ret = 1; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;void NTT(ll *c, int tp) &#123; for (int i = 0; i &lt; lim; i++) &#123; if (i &lt; rev[i]) swap(c[i], c[rev[i]]); &#125; for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; int r = mid&lt;&lt;1; ll wn = fpow(~tp?G:invg, (mod-1)/r); for (int j = 0; j &lt; lim; j += r) &#123; ll w = 1; for (int k = 0; k &lt; mid; k++, w = w * wn % mod) &#123; ll x = c[j+k], y = w * c[j+k+mid] % mod; c[j+k] = (x + y) % mod; c[j+k+mid] = (x - y + mod) % mod; &#125; &#125; &#125; if (tp == -1) &#123; for (int i = 0; i &lt; lim; i++) &#123; c[i] = c[i] * invn % mod; &#125; &#125;&#125;inline ll calc(ll x) &#123; return (x * x % p * O % p + x * S % p + U) % p;&#125;void Mul(ll *a, ll *b, ll *c) &#123; for (int i = 0; i &lt; lim; i++) aa[i] = a[i], bb[i] = b[i]; NTT(aa, 1); NTT(bb, 1); for (int i = 0; i &lt; lim; i++) aa[i] = aa[i] * bb[i] % mod; NTT(aa, -1); for (int i = 0; i &lt;= m; i++) c[i] = aa[i] % p; &#125;void solve(int n) &#123; if (n == 1) &#123; for (int i = 0; i &lt;= m; i++) dp[i] = sum[i] = F[i]; return; &#125; solve(n &gt;&gt; 1); tot++; Mul(dp, sum, tmp); Mul(dp, dp, dp); for (int i = 0; i &lt;= m; i++) &#123; sum[i] = (sum[i] + tmp[i]) % p; &#125; if (n &amp; 1) &#123; Mul(dp, F, tmp); for (int i = 0; i &lt;= m; i++) &#123; dp[i] = tmp[i]; sum[i] = (sum[i] + tmp[i]) % p; &#125; &#125;&#125;int main() &#123; scanf(\"%d %lld %d %lld %lld %lld\", &amp;m, &amp;p, &amp;N, &amp;O, &amp;S, &amp;U); lim = 1; while (lim &lt;= m + m) &#123; lim &lt;&lt;= 1; l++; &#125; invn = fpow(lim, mod-2); for (int i = 0; i &lt; lim; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); &#125; for (int i = 1; i &lt;= m; i++) F[i] = calc(i); solve(N); printf(\"%lld\\n\", sum[m]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"FFT","slug":"FFT","permalink":"http://akdream.tk/tags/FFT/"}]},{"title":"Problem b[HAOI2011]","slug":"Problem b[HAOI2011]","date":"2020-06-23T10:37:57.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/93e29827.html/","link":"","permalink":"http://akdream.tk/post/93e29827.html/","excerpt":"","text":"题目描述对于给出的$n$个询问，每次求有多少个数对$(x,y)$，满足$a \\le x \\le b$，$c \\le y \\le d$，且$\\gcd(x,y) = k$，$\\gcd(x,y)$函数为$x$和$y$的最大公约数。 题解莫比乌斯反演 我们可以用二维前缀和的思想，我们设 $f(n,m)=\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m [\\gcd(i,j)=k]$， 那答案应为 $f(b,d)-f(b,c-1)-f(a-1,d)+f(a-1,c-1)$ 接下来看看$f(n,m)$怎么求： $\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m [\\gcd(i,j)=k]$ $=\\sum\\limits_{i=1}^{n/k} \\sum\\limits_{j=1}^{m/k} [\\gcd(i,j)=1]$ 使用莫比乌斯反演 $=\\sum\\limits_{i=1}^{n/k} \\sum\\limits_{j=1}^{m/k} \\sum\\limits_{d|gcd(i,j)}\\mu(d)$ 把$d$放到前面枚举，设$i=xd,\\ j=yd$ $=\\sum\\limits_{d} \\mu(d) * \\sum\\limits_{x=1}^{n/kd} \\sum\\limits_{y=1}^{m/kd} 1$ $=\\sum\\limits_{d} \\mu(d) * \\lfloor \\frac{n}{kd}\\rfloor * \\lfloor \\frac{m}{kd}\\rfloor$ 预处理$\\mu(d)$的前缀和，使用除法分块即可做到时间复杂度$O(\\sqrt{n})$ 总时间复杂度$O(n\\sqrt{n})$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int t, a, b, c, d, k;int pr[50005], mb[50005], sum[50005], tot;bool np[50005];void init() &#123; mb[1] = 1; for (int i = 2; i &lt;= 50000; i++) &#123; if (!np[i]) pr[++tot] = i, mb[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; i * pr[j] &lt;= 50000; j++) &#123; np[i*pr[j]] = 1; if (i % pr[j] == 0) &#123; mb[i*pr[j]] = 0; break; &#125; else mb[i*pr[j]] = -mb[i]; &#125; &#125; for (int i = 1; i &lt;= 50000; i++) sum[i] = sum[i-1] + mb[i];&#125;int solve(int nn, int mm) &#123; int ret = 0, n = nn / k, m = mm / k; for (int l = 1, r = 0; l &lt;= min(n, m); l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ret += (sum[r] - sum[l-1]) * (n / l) * (m / l); &#125; return ret;&#125;int main() &#123; scanf(\"%d\", &amp;t); init(); while (t--) &#123; scanf(\"%d %d %d %d %d\", &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); printf(\"%d\\n\", solve(b, d) + solve(a-1, c-1) - solve(b, c-1) - solve(a-1, d)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://akdream.tk/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯函数","slug":"莫比乌斯函数","permalink":"http://akdream.tk/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"}]},{"title":"树[省选联考2020]","slug":"树[省选联考2020]","date":"2020-06-23T10:36:46.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/da9385f9.html/","link":"","permalink":"http://akdream.tk/post/da9385f9.html/","excerpt":"","text":"题目描述给定一棵$n$个结点的有根树$T$，结点从$1$开始编号，根结点为$1$号结点，每个结点有一个正整数权值$v_i$。 设$x$号结点的子树内（包含$x$自身）的所有结点编号为$c_1,c_2,\\dots,c_k$，定义$x$的价值为： $val(x)=(v_{c_1}+d(c_1,x)) \\oplus (v_{c_2}+d(c_2,x)) \\oplus \\cdots \\oplus (v_{c_k}+d(c_k, x))$ 其中$d(x,y)$表示树上$x$号结点与$y$号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。⊕ 表示异或运算。 请你求出$\\sum\\limits_{i=1}^n val(i)$的值。 输入格式第一行一个正整数$n$表示树的大小。 第二行$n$个正整数表示$v_i$。 接下来一行$n-1$个正整数，依次表示$2$号结点到$n$号结点，每个结点的父亲编号。 输出格式仅一行一个整数表示答案。 题解很显然的想法是考虑如何让父亲节点利用儿子的$val$信息从而快速计算出父亲的$val$ 考场上首先想的是如何处理这个所有点的点权+1后异或和的变化 我们按二进制位来考虑 假设现在有一个数，二进制末三位为$011$，那么给它+1之后变成$100$，相当于它的二进制第1位，第2位，第3位都取反了 然后很容易发现一个规律，如果一个数字$a \\equiv 2^k-1 \\mod 2^k$，那么a+1之后第$k+1$位就会取反 那么我们可以把当前子树内所有点的权值装进$\\log n$个桶里，$buc[i][j]$表示当前权值(即点权+当前深度)$\\ \\equiv i \\mod 2^j$的点有多少个 为了方便，我们设$v_i=c_i+d(i,1)$，即第$v_i$是自己的权值+自己到根的距离，把这个权值放进上面的桶里面 那么假设我们在计算$val_x$，那么子树中所有点现在的点权应该是$v_i-dis(x,1)$，我们要对于每个$j$，找出有多少个点满足$v_i-dis(x,1)-1 \\equiv 2^j - 1\\mod 2^j$ 化简一下就是$v_i \\equiv dis(x,1) \\mod 2^j$ 所以我们对于每个$j$找到$buc[dis(x,1)\\bmod 2^j][j]$，那么第$j+1$位实际上要取反这么多次 这个就很好处理了 整理一下思路：首先把$val_x$赋为所有儿子$val$的异或和，然后对于每个$j$找到子树中的所有点(不包括自己)有多少个点满足$v_i\\equiv dis(x,1)\\mod 2^j$，然后如果是奇数个就把第$j+1$位取反，否则不变最后把$val_x$异或上$x$的点权 最后关于怎么维护这个桶，用树上启发式合并啊 时间复杂度$O(n\\log^2 n)$，一个是启发式合并的log，另一个是枚举二进制位的log 不过常数很小，洛谷上最慢点跑了1.3s，相信少爷机上更快 代码体感是挺好写的 考场上桶开小了导致100pts-&gt;30pts 心态爆炸123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define N 530005using namespace std;inline void read(int &amp;num) &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, a[N];int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int d[N], siz[N], son[N], fa[N];int buc[N&lt;&lt;1][22], ans[N]; //开两倍大！！！int two[22];long long Ans;inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void dfs1(int x) &#123; siz[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x]) continue; fa[y] = x; d[y] = d[x] + 1; dfs1(y); siz[x] += siz[y]; if (!son[x] || siz[son[x]] &lt; siz[y]) son[x] = y; &#125;&#125;void calc(int x, int tp) &#123; for (int i = 0; i &lt;= 21; i++) &#123; buc[a[x]&amp;two[i]][i] += tp; &#125; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] != fa[x]) calc(to[i], tp); &#125;&#125;void getans(int x) &#123; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] != fa[x]) ans[x] ^= ans[to[i]]; &#125; for (int i = 0; i &lt;= 21; i++) &#123; ans[x] ^= ((buc[d[x]&amp;two[i]][i] &amp; 1) &lt;&lt; i); &#125; ans[x] ^= (a[x] - d[x]);&#125;void dfs(int x, int cl) &#123; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] == fa[x] || to[i] == son[x]) continue; dfs(to[i], 1); &#125; if (son[x]) dfs(son[x], 0); for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] == fa[x] || to[i] == son[x]) continue; calc(to[i], 1); &#125; getans(x); if (cl) &#123; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] == fa[x]) continue; calc(to[i], -1); &#125; &#125; else &#123; for (int i = 0; i &lt;= 21; i++) &#123; buc[a[x]&amp;two[i]][i]++; &#125; &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 2, x; i &lt;= n; i++) &#123; read(x); addedge(i, x); &#125; for (int i = 0; i &lt;= 21; i++) two[i] = (1 &lt;&lt; i) - 1; dfs1(1); for (int i = 1; i &lt;= n; i++) a[i] += d[i]; dfs(1, 0); for (int i = 1; i &lt;= n; i++) &#123; Ans += ans[i]; &#125; printf(\"%lld\\n\", Ans); return 0;&#125;","categories":[],"tags":[{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://akdream.tk/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"}]},{"title":"移动金币「SDOI2019」","slug":"移动金币「SDOI2019」","date":"2020-06-14T13:28:06.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/fda2729a.html/","link":"","permalink":"http://akdream.tk/post/fda2729a.html/","excerpt":"","text":"题目描述一个$1\\times n$的棋盘上最初摆放有$m$枚金币。其中每一枚金币占据了一个独立的格子，任意一个格子内最多只有一枚金币。 Alice 和 Bob 将要进行如下的一场游戏。二人轮流操作，且 Alice 先行。当轮到一个玩家的时候，他可以选择一枚金币，并将其向左移动任意多格，且至少移动一格。金币不能被移出棋盘，也不能越过其它金币。 如果轮到一个玩家的时候他已经无法做出任何有效操作了（显然这个时候$m$枚金币恰好落在最左侧的$m$个格子中），则被判定为输家。已经知道 Alice 和 Bob 都是极致聪明的人，他们在任何局面下总能做出最优的操作。那么有多少初始状态能保证 Alice 必胜呢？ 输入格式输入仅有一行并包含两个正整数，依次为$n$和$m$，如题目所述。 输出格式输出一个整数，表示有多少初始状态可以保证 Alice 作为先手方能先手必胜。由于答案可能很大，请输出关于$10^9+9$取模后的值。 题解首先不难发现，把金币向左移改成向右移是没有区别的 然后把题目看作是$m$枚金币把$n-m$个空位分成了$m+1$个部分(编号从$0\\sim m$)，那么每次把第$i$枚硬币向右移动就相当于是把若干个空位从第$i$部分移动到了第$i-1$部分 然后这显然是一个阶梯$nim$模型，即每次可以选择一个$i\\neq 0$，将若干个物品从第$i$堆移到第$i-1$堆 我们其实不用管$m$枚金币具体在哪些位置，所以我们现在需要解决的问题是：将$n-m$个物品分成编号从$0\\sim m$的$m+1$堆，要求所有奇数堆的异或和不为$0$，有多少种方案？ 容斥一下，可以用总方案数减去奇数堆异或和为$0$的方案数 设$dp[i][j]$表示所有奇数堆的二进制前$i$位的异或和为0，共用了$j$个物品的方案数 在二进制的每一位上，为了异或和为$0$，必须要放偶数个$1$ 假设$m+1$堆中有$a$个奇数堆，$b$个偶数堆， 那么转移方程为：$dp[i][j]=\\sum\\limits_{k%2=0} dp[i-1][j-k*2^{i-1}] * C(a, k)$ 表示在第$i$位上放$k$个1，所以在$a$个奇数位上任选$k$个放上1 然后填好所有奇数堆后，剩下的没有用到的物品就可以用插板法随意地分到偶数堆里 时间复杂度$O(nm\\log n)$，但是实际上跑得很快 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;const ll mod = 1000000009;ll fac[150005], invf[150005], dp[21][150005], ans; // 放了二进制前i位 用了j个物品 int n, m, l; inline ll fpow(ll x, ll t) &#123; ll ret = 1; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;inline ll C(ll _n, ll _m) &#123; return fac[_n] * invf[_m] % mod * invf[_n - _m] % mod;&#125;void init() &#123; fac[0] = invf[0] = 1; for (int i = 1; i &lt;= 150000; i++) &#123; fac[i] = fac[i-1] * i % mod; &#125; invf[150000] = fpow(fac[150000], mod-2); for (int i = 149999; i; i--) &#123; invf[i] = invf[i + 1] * (i + 1) % mod; &#125;&#125;int main() &#123; read(n); read(m); n -= m; init(); int tmp = 1; while (tmp &lt;= n) &#123; l++; tmp &lt;&lt;= 1; &#125; int a = (m + 1) / 2, b = (m + 2) / 2; dp[0][0] = 1; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (!dp[i][j]) continue; for (int k = 0; k &lt;= a &amp;&amp; k * (1 &lt;&lt; i) + j &lt;= n; k += 2) &#123; dp[i+1][j+k*(1&lt;&lt;i)] = (dp[i+1][j+k*(1&lt;&lt;i)] + dp[i][j] * C(a, k)) % mod; &#125; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; ans = (ans + dp[l][i] * C((n-i) + b - 1, b - 1) % mod) % mod; &#125; ans = (C(n+m, m) - ans + mod) % mod; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"博弈论","slug":"博弈论","permalink":"http://akdream.tk/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"世界树[HNOI2014]","slug":"世界树[HNOI2014]","date":"2020-06-12T14:29:23.000Z","updated":"2020-10-08T12:16:08.180Z","comments":true,"path":"post/46575262.html/","link":"","permalink":"http://akdream.tk/post/46575262.html/","excerpt":"","text":"题目描述题目背景太长不放 传送门 给你一棵$n$个节点的树，有$q$次询问，每次指定$m_i$个节点为关键节点；对于任意一个节点，它被距离自己树上距离最近的那个关键节点管辖；输出每个关键节点各管辖多少个节点 $n,, q \\le 300000$，$\\sum m_i\\le 300000$ 题解看到$\\sum m_i\\le 300000$想到什么了？虚树！ 所以我们把关键节点的虚树建出来，然后考虑怎么进行DP (为了方便我们要求$1$号节点一定要在虚树里) 注意这里建虚树要加上一个边权，表示原树上两个节点的距离 首先，对于每个虚树上的点，我们求出它们各自被哪个关键节点管辖，记为$in_x$，这个比较简单就不讲了；把点到管辖它的关键节点之间的距离记为$dis_x$ 然后我们考虑虚树上的一条边$u\\rightarrow v$，$u$是$v$的父亲 这条边上一定存在一个断点$x$，使得上面蓝圈那部分的所有节点被$in_u$管辖，下面绿圈那部分被$in_v$管辖 我们怎么求出这个断点$x$呢？ 如果一个$u\\rightarrow v$链上的点$y$在绿圈部分，$y$离$u$的距离是$a$，离$v$的距离是$b$，那么一定满足：+$in_u$编号小于$in_v$时，$y$须满足$in_u+a&gt;in_v+b$+$in_u$编号大于$in_v$时，$y$须满足$in_u+a\\ge in_v+b$由于我们之前记录了虚树上面每条边的实际长度，所以我们知道$b$，就可以直接用$u\\rightarrow v$的长度减去$b$得到$a$ 这样我们就能$O(1)$找出一个距离$v$最远的$y$，它就是那个断点，可以从$v$开始用倍增往上跳父亲找到 然后怎么进行转移呢？初始时设$ans[in_1]=n$，每次枚举到一条边$u\\rightarrow v$时，找出断点$x$，然后$ans[in_u]$减去$size_x$，$ans[in_v]$加上$size_x$；这里$size_x$表示$x$子树的大小 可以这样理解：由于我们是按照深搜顺序进行dp的，所以搜到这条边时整个$u$的子树都是在由$in_u$管辖，现在我们要把下面的那部分分给$in_v$管辖 时间复杂度$O(n\\log n)$，是倍增求lca以及向上跳的复杂度 码量巨大，我写数据结构题都写不到这么长。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, m, cnt;int head[300005], pre[600005], to[600005], val[600005], sz;int dfn[300005], siz[300005], d[300005], p[300005][21], tme;int q[300005], tmp[300005], stk[300005], top, reset[1000005], tot;int mn[300005], mnind[300005], ans[300005];bool point[300005];inline void addedge(int u, int v, int w) &#123; reset[++tot] = u; reset[++tot] = v; //奇妙重置数组方法 pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w;&#125;void dfs(int x) &#123; siz[x] = 1; dfn[x] = ++tme; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == p[x][0]) continue; d[y] = d[x] + 1; p[y][0] = x; dfs(y); siz[x] += siz[y]; &#125;&#125;inline int LCA(int x, int y) &#123; if (d[x] &lt; d[y]) swap(x, y); for (int i = 20; i &gt;= 0; i--) &#123; if (d[x] - (1 &lt;&lt; i) &gt;= d[y]) x = p[x][i]; &#125; if (x == y) return x; for (int i = 20; i &gt;= 0; i--) &#123; if (p[x][i] != p[y][i]) &#123; x = p[x][i]; y = p[y][i]; &#125; &#125; return p[x][0];&#125;inline int jumpup(int x, int t) &#123; for (int i = 20; i &gt;= 0; i--) &#123; if (t &gt;= (1 &lt;&lt; i)) &#123; t -= (1 &lt;&lt; i); x = p[x][i]; &#125; &#125; return x;&#125;bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y];&#125;void buildtree() &#123; for (int i = 1; i &lt;= tot; i++) &#123; //奇妙重置数组方法 head[reset[i]] = ans[reset[i]] = 0; mn[reset[i]] = 0x3f3f3f3f; &#125; tot = sz = 0; sort(q + 1, q + cnt + 1, cmp); stk[top=1] = 1; for (int i = 1; i &lt;= cnt; i++) &#123; if (q[i] == 1) continue; if (top == 1) &#123; stk[++top] = q[i]; continue; &#125; int lca = LCA(stk[top], q[i]); while (top &gt; 1 &amp;&amp; dfn[stk[top-1]] &gt;= dfn[lca]) &#123; addedge(stk[top], stk[top-1], abs(d[stk[top]] - d[stk[top-1]])); top--; &#125; if (stk[top] != lca) &#123; addedge(stk[top], lca, abs(d[stk[top]]-d[lca])); stk[top] = lca; &#125; stk[++top] = q[i]; &#125; while (top &gt; 1) &#123; addedge(stk[top], stk[top-1], abs(d[stk[top]] - d[stk[top-1]])); top--; &#125;&#125;void dp1(int x, int fa) &#123; if (point[x]) mn[x] = 0, mnind[x] = x; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; dp1(y, x); if (mn[x] &gt; mn[y] + val[i]) &#123; mn[x] = mn[y] + val[i]; mnind[x] = mnind[y]; &#125; else if (mn[x] == mn[y] + val[i]) &#123; if (mnind[x] &gt; mnind[y]) mnind[x] = mnind[y]; &#125; &#125;&#125;void dp2(int x, int fa) &#123; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; if (mn[y] &gt; mn[x] + val[i]) &#123; mn[y] = mn[x] + val[i]; mnind[y] = mnind[x]; &#125; else if (mn[y] == mn[x] + val[i]) &#123; if (mnind[y] &gt; mnind[x]) mnind[y] = mnind[x]; &#125; dp2(y, x); &#125;&#125;void dp3(int x, int fa) &#123; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; if (mnind[x] == mnind[y]) &#123; &#125; else &#123; int dis = val[i] + mn[y] - mn[x], num = 0; if (mnind[x] &lt; mnind[y]) &#123; num = dis / 2; &#125; else num = (dis-1) / 2; num = min(num, val[i]); num = max(num, 0); num = val[i] - num - 1; int z = jumpup(y, num); //z即是这条边的断点 ans[mnind[x]] -= siz[z]; ans[mnind[y]] += siz[z]; &#125; &#125; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] != fa) dp3(to[i], x); &#125;&#125;void solve() &#123; buildtree(); //建虚树 dp1(1, 0); dp2(1, 0); //两遍dfs求出虚树上每个点被哪个点管辖 ans[mnind[1]] = siz[1]; dp3(1, 0); //进行dp for (int i = 1; i &lt;= cnt; i++) &#123; printf(\"%d \", ans[tmp[i]]); &#125; puts(\"\");&#125;int main() &#123; read(n); for (int i = 1, u, v; i &lt; n; i++) &#123; read(u); read(v); addedge(u, v, 0); &#125; dfs(1); //预处理出节点深度，倍增数组，dfs序等 for (int l = 1; (1 &lt;&lt; l) &lt;= n; l++) &#123; for (int i = 1; i &lt;= n; i++) &#123; p[i][l] = p[p[i][l-1]][l-1]; &#125; &#125; read(m); for (int i = 1; i &lt;= m; i++) &#123; read(cnt); for (int j = 1; j &lt;= cnt; j++) &#123; read(q[j]); point[q[j]] = 1; tmp[j] = q[j]; &#125; solve(); for (int j = 1; j &lt;= cnt; j++) &#123; point[q[j]] = 0; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://akdream.tk/tags/%E8%99%9A%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"优秀的拆分「NOI2016」","slug":"优秀的拆分「NOI2016」","date":"2020-06-10T15:02:06.000Z","updated":"2020-10-08T12:16:08.227Z","comments":true,"path":"post/6e1ec315.html/","link":"","permalink":"http://akdream.tk/post/6e1ec315.html/","excerpt":"","text":"题目描述如果一个字符串可以被拆分为$\\text{AABB}$的形式，其中$\\text{A}$和$\\text{B}$是任意非空字符串，则我们称该字符串的这种拆分是优秀的。例如，对于字符串$\\texttt{aabaabaa}$，如果令$\\text{A}=\\texttt{aab}$，$\\text{B}=\\texttt{a}$，我们就找到了这个字符串拆分成$\\text{AABB}$的一种方式。 一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。比如我们令$\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{baa}$，也可以用$\\text{AABB}$表示出上述字符串；但是，字符串$\\texttt{abaabaa}$就没有优秀的拆分。 现在给出一个长度为$n$的字符串$S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。 以下事项需要注意： 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。 在一个拆分中，允许出现$\\text{A}=\\text{B}$。例如$\\texttt{cccc}$存在拆分$\\text{A}=\\text{B}=\\texttt{c}$。 字符串本身也是它的一个子串。 输入格式每个输入文件包含多组数据。输入文件的第一行只有一个整数$T$，表示数据的组数。接下来$T$行，每行包含一个仅由英文小写字母构成的字符串$S$，意义如题所述。 输出格式输出$T$行，每行包含一个整数，表示字符串$S$所有子串的所有拆分中，总共有多少个是优秀的拆分。 $n\\le 30000$ 题解太良心了$85%$的点$n\\le 500$，直接$O(n^3)$暴力枚举区间+断点用哈希判断 然后只要稍微动动脑子：设$a[i]$表示以$i$结尾的$\\text{AA}$串个数，$b[i]$表示以$i$开头的$\\text{AA}$串个数，那么答案就是$\\sum\\limits_{i=1}^{n-1}a[i]*b[i+1]$ $O(n^2)$95分到手 虽然正解和字符串哈希无关，但是我觉得还是应该给这道鉴题加一个字符串哈希的tag 最后五分如果想不出来不拿也感觉无所谓。。。最后五分确实不好想 所以开始说正解： 上面的95分解法问题就在于$a[N],\\ b[N]$，我们需要$O(n^2)$的时间求出来，考虑怎么样求得更快 我们枚举一个$len$表示我们现在想找到那些长度为$2*len$的$\\text{AA}$串 然后在原串上每隔$len$放一个断点 我们枚举相邻的两个断点$i,j$，现在我们想要知道 以$i$开头的后缀与以$j$开头的后缀的最长公共前缀(LCP) 和 以$i$结尾的前缀与以$j$结尾的前缀的最长公共后缀(LCS) LCP可以用后缀数组求；LCS也可以，把原数组翻转之后就变成后缀的LCP了，所以这两个都是可以用ST表$O(1)$求出的 那么现在我们求出了这两个值 情况1 对于这种情况，即$LCP+LCS-1&lt;len$，我们是找不出$\\text{AA}$串的 情况2 用脚画图 不愧是我 $LCP+LCS-1&lt;len$，这个时候就有很多的长为$2*len$的$\\text{AA}$串了，图中画出的$\\text{AA},\\ \\text{BB}$就是最靠左和最靠右的两个这样的串 实际上，我画了”OK”的那个橙色区间的每一个点都是一个长为$2*len$的$\\text{AA}$串的开头 如何找哪一段是合法$\\text{AA}$串的结尾也同理 所以实际上每次就是把$a[N]$和$b[N]$的某一段全部加一 用差分来维护一下就行了 最后来看一下时间复杂度 后缀数组+ST表是$O(n\\log n)$ $\\frac{n}{1}+\\frac{n}{2}+\\frac{n}{3}+\\dots+\\frac{n}{n}$我记得差不多就是$O(n \\log n)$吧。。。可能要稍微大一点 总之$n\\le 30000$的数据是完全没有压力的 注意多组数据初始化数组！注意多组数据初始化数组！注意多组数据初始化数组！代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#define N 60005using namespace std;int t, n, nn;char s[N];int a[N], b[N];int sa[N], sa2[N], rnk[N], sum[N], key[N], height[N], ST[N][21]; inline bool check(int *num, int aa, int bb, int l) &#123; if (aa + l &gt; n || bb + l &gt; n) return false; //多组数据，一定要加！ return num[aa] == num[bb] &amp;&amp; num[aa+l] == num[bb+l];&#125; void DA() &#123; int i, j, p, m = 128; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[rnk[i]=s[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i; i--) sa[sum[rnk[i]]--] = i; for (j = 1; j &lt;= n; j &lt;&lt;= 1, m = p) &#123; for (p = 0, i = n - j + 1; i &lt;= n; i++) sa2[++p] = i; for (i = 1; i &lt;= n; i++) if (sa[i] - j &gt; 0) sa2[++p] = sa[i] - j; for (i = 1; i &lt;= n; i++) key[i] = rnk[sa2[i]]; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[key[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i; i--) sa[sum[key[i]]--] = sa2[i]; for (swap(sa2, rnk), p = 2, rnk[sa[1]] = 1, i = 2; i &lt;= n; i++) &#123; rnk[sa[i]] = check(sa2, sa[i-1], sa[i], j) ? p - 1 : p++; &#125; &#125; &#125;void geth() &#123; int p = 0; for (int i = 1; i &lt;= n; i++) rnk[sa[i]] = i; for (int i = 1; i &lt;= n; i++) &#123; if (p) p--; int j = sa[rnk[i]-1]; while (s[i+p] == s[j+p] &amp;&amp; i + p &lt;= n &amp;&amp; j + p &lt;= n) p++; //多组数据，一定要加！ height[rnk[i]] = p; &#125;&#125;void preST() &#123; for (int i = 1; i &lt;= n; i++) ST[i][0] = height[i]; for (int l = 1; (1 &lt;&lt; l) &lt;= n; l++) &#123; for (int i = 1; i + (1&lt;&lt;l) - 1 &lt;= n; i++) &#123; ST[i][l] = min(ST[i][l-1], ST[i+(1&lt;&lt;(l-1))][l-1]); &#125; &#125;&#125; inline int QST(int x, int y) &#123; if (x &gt; y) swap(x, y); x++; int l = log2(y - x + 1); return min(ST[x][l], ST[y-(1&lt;&lt;l)+1][l]);&#125;inline int LCP(int x, int y) &#123; return QST(rnk[x], rnk[y]); &#125;inline int LCS(int x, int y) &#123; return QST(rnk[n-x+1], rnk[n-y+1]); &#125;void Solve() &#123; for (int l = 1; l * 2 &lt;= nn; l++) &#123; for (int i = 1, j = i + 1; j * l &lt;= nn; i++, j++) &#123; int lcp = min(LCP(i*l, j*l), l), lcs = min(LCS(i*l, j*l), l); if (lcp + lcs - 1 &gt;= l) &#123; a[j*l+l-lcs]++; a[j*l+lcp]--; b[i*l-lcs+1]++; b[i*l-l+lcp+1]--; &#125; &#125; &#125; for (int i = 1; i &lt;= nn; i++) &#123; a[i] += a[i-1]; b[i] += b[i-1]; &#125; long long ans = 0; for (int i = 1; i &lt; nn; i++) &#123; ans += 1ll * a[i] * b[i+1]; &#125; printf(\"%lld\\n\", ans);&#125; int main() &#123; scanf(\"%d\", &amp;t); while (t--) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); scanf(\"%s\", s + 1); n = strlen(s + 1); s[n+1] = '$'; for (int i = n + 2; i &lt;= 2 * n + 1; i++) &#123; s[i] = s[2 * n - i + 2]; &#125; nn = n; n = n * 2 + 1; DA(); geth(); preST(); Solve(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://akdream.tk/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"整数「NOI2017」","slug":"整数「NOI2017」","date":"2020-06-08T14:20:21.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/7517fd9b.html/","link":"","permalink":"http://akdream.tk/post/7517fd9b.html/","excerpt":"","text":"题目描述在人类智慧的山巅，有着一台字长为$1048576$位的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。 不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你…… P 博士将他的计算任务抽象为对一个整数的操作。 具体来说，有一个整数$x$，一开始为$0$。 接下来有$n$个操作，每个操作都是以下两种类型中的一种： 1$a$$b$：将$x$加上整数$a \\cdot 2 ^ b$。其中 aa 为一个整数，bb 为一个非负整数 2$k$：询问$x$在用二进制表示时，位权为$2 ^ k$的位的值（即这一位上的$1$代表$2 ^ k$） 保证在任何时候，$x \\ge 0$。 输入格式从标准输入读入数据。输入的第一行包含四个正整数$n, t_1, t_2, t_3$，nn 的含义见题目描述，$t_1, t_2, t_3$的具体含义见子任务。接下来$n$行，每行给出一个操作，具体格式和含义见题目描述。同一行输入的相邻两个元素之间，用恰好一个空格隔开。 输出格式输出所询问的值。 题解这波是暴力爆踩标程 用线段树的确太麻烦了 首先，如果暴力维护每个二进制位上的值，就算不考虑进位退位，$\\log_2 1e9=30$，时间复杂度是$O(30n)$的，已经不太能卡过去了 发现都是0/1的二进制位，所以我们可以用unsigned int来压位，把32位压进一个uint块，这样$2^k$那一位就在第$k/32$块的第$k%32$位上，每次修改只需要修改两个uint，似乎就是$O(n)$的了 但是进位退位怎么办呢？ 如果只有加法，没有减法的话，每次像高精加法一样暴力向上进位，可以证明时间复杂度是均摊$O(n)$的，但是有了减法，时间复杂度就保证不了了 所以我们把加法和减法分开计算，一个uint数组维护累加的值，另一个数组维护累减的值，然后暴力进行高精加法 这里提一下怎么判断有没有进位：因为uint会自然溢出，而且每次加在一块上的数肯定是小于$2^{32}$的，所以如果加完一个数发现uint比原来还小了，就说明向上一位进了一 设$a_i$表示加数二进制$2^i$那位的值，$b_i$表示减数 最后考虑统计答案： 用$a_k$减去$b_k$就好了？然而并不是 $k$以下的二进制位相减可能会产生借位，如果有借位显然答案应该是$a_k-b_k$再取反，所以我们需要判断是否有借位 判断借位其实也很简单，假设一共加了$sum$这么多，减了$sub$这么多，只需要比较$sum%2^k$和$sub%2^k$哪个更大就行了 假设$k/32=p,\\ k%32=q$，即$k$在第$p$块的第$q$位 把加数和减数 第$p$块的$0\\sim q-1$位的和分别算出来，如果加数的大于减数的就肯定没有借位了，反之则有，但是如果相等的话我们就还要继续向后比较 不可能直接一位一位向后枚举，不过我们可以直接找到第一个$i&lt;k$的$a_i\\neq b_i$比较它们的大小 这个也很好实现，维护一个set动态记录哪些块满足 加数块不等于减数块，每次修改时顺便维护一下，然后查询时直接lower_bound就好了 然后此题就做完了。。。可能写得有点艰涩难懂但是实际上这个乱搞做法是很容易理解的 时间复杂度$O(n\\log n)$，不过set似乎跑得挺快 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define re registerusing namespace std;typedef unsigned int uint;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f; &#125;set&lt;uint&gt; st;uint n, t1, t2, t3; uint a[1000005], b[1000005]; //a维护加法块，b维护减法块void add(uint pos, uint x) &#123; if (a[pos] + x &lt; a[pos]) add(pos+1, 1); a[pos] += x; if (a[pos] != b[pos]) st.insert(pos); else if (st.count(pos)) st.erase(pos);&#125; void del(uint pos, uint x) &#123; if (b[pos] + x &lt; b[pos]) del(pos+1, 1); b[pos] += x; if (a[pos] != b[pos]) st.insert(pos); else if (st.count(pos)) st.erase(pos);&#125;int main() &#123; read(n); read(t1); read(t2); read(t3); for (uint i = 1; i &lt;= n; i++) &#123; uint tp; read(tp); if (tp == 1) &#123; //暴力高精加法 int x, y; read(x); read(y); uint p = y / 32, q = y % 32; if (x &gt; 0) &#123; add(p, x&lt;&lt;q); if (q) add(p+1, x&gt;&gt;(32-q)); &#125; else &#123; x = -x; del(p, x&lt;&lt;q); if (q) del(p+1, x&gt;&gt;(32-q)); &#125; &#125; else &#123; uint k; read(k); uint p = k / 32, q = k % 32; uint now = ((a[p] &gt;&gt; q) ^ (b[p] &gt;&gt; q)) &amp; 1; uint x2 = a[p] % (1 &lt;&lt; q), y2 = b[p] % (1 &lt;&lt; q); if (x2 &lt; y2) &#123; //本块内有借位 putchar((now^1)+'0'); &#125; else if (x2 &gt; y2 || st.empty() || p &lt;= *(st.begin())) &#123; //无需借位 putchar(now+'0'); &#125; else &#123; //可能在本块后借位 set&lt;uint&gt;::iterator it = st.lower_bound(p); it--; uint pp = *it; //找到第一个不同块 if (a[pp] &gt;= b[pp]) &#123; //无需借位 putchar(now+'0'); &#125; else &#123; //需要借位 putchar((now^1)+'0'); &#125; &#125; puts(\"\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"串珠子[BZOJ2560]","slug":"串珠子[BZOJ2560]","date":"2020-06-06T11:37:36.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/805d1a49.html/","link":"","permalink":"http://akdream.tk/post/805d1a49.html/","excerpt":"","text":"题目描述铭铭有$n$个十分漂亮的珠子和若干根颜色不同的绳子。现在铭铭想用绳子把所有的珠子连成一个整体。 现在已知所有的珠子互不相同，用整数$1$到$n$编号。对于第$i$个珠子和第$j$个珠子，可以选择不用绳子连接，或者在$c_{i,j}$根不同颜色的绳子中选择一根将它们连接。如果把珠子看作点，把绳子看作边，将所有珠子连成一个整体即为所有点构成一个连通图。特别地，珠子不能和自己连接。 铭铭希望知道总共有多少种不同的方案将所有珠子连成一个整体。由于答案可能很大，因此只需输出答案对$1000000007$取模的结果。 输入格式输入第一行包含一个正整数$n$，表示珠子的个数。接下来$n$行，每行包含$n$个非负整数，用空格隔开。这$n$行中，第$i$行第$j$个数为$c_{i,j}$。 输出格式输出一行一个整数，为连接方案数对$1000000007$取模的结果。 $n\\le 20$ 题解状压DP 首先我们设$f[S]$表示：$S$中包含的珠子两两之间任意连边(可以不连)的方案数 显然，$f[S]=\\Pi_{i\\in S,j\\in S} (c[i][j]+1)$ 这个可以在$O(2^nn^2)$的时间内预处理 但是这样求出的方案，不一定保证每个方案都是一个连通图 所以我们要再进行一次DP 设$g[S]$表示：$S$中包含的珠子两两之间任意连边(可以不连)，且构成一个连通块的方案数 初始时我们先把每个$g[S]$赋值成$f[S]$，然后再删除掉不合法的部分 我们考虑$1$这颗珠子，在一个不合法的方案中，一定有部分珠子和$1$不在同一个连通块内 所以对于每个$g[S]$，我们枚举$S$的一个不含珠子$1$的子集$S_2$，表示$S_2$中的那些珠子和$1$不在同一个连通块内 这样的方案数有多少？首先，$S_2$内的珠子不一定要形成一整个连通块，所以是$f[S_2]$ 其次，$S-S_2$即与$1$连通的珠子一定在一个连通块内，所以是$g[S-S_2]$ 所以不合法的方案有$f[S_2]*g[S-S_2]$种，从$g[S]$中减去 所以我们可以得到：$g[S]=f[S]-\\sum f[S_2]*g[S-S_2]$($S_2$是$S$的所有不含珠子$1$的子集) 答案即为$g[2^n-1]$ p.s. 我们发现所有的$S-S_2$都是含有珠子1的，所以为了降低复杂度，我们可以不去求那些不含珠子$1$的$g[S]$ 时间复杂度为枚举子集复杂度$O(3^n)$但是大大小于这个上界 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, ff = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') ff = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * ff; &#125;const ll mod = 1000000007;int n;ll a[30][30], f[1050005], g[1050005]; //f:可以不联通 g:必须联通 inline ll fpow(ll x, ll t) &#123; ll ret = 1; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; read(a[i][j]); &#125; &#125; for (int s = 0; s &lt;= (1 &lt;&lt; n) - 1; s++) &#123; f[s] = 1; for (int i = 1; i &lt;= n; i++) for (int j = i + 1; j &lt;= n; j++) &#123; if (((s&gt;&gt;(i-1))&amp;1) &amp;&amp; ((s&gt;&gt;(j-1))&amp;1)) &#123; f[s] = f[s] * (a[i][j] + 1) % mod; &#125; &#125; &#125; memcpy(g, f, sizeof(g)); for (int s = 1; s &lt;= (1 &lt;&lt; n) - 1; s++) &#123; if (!(s &amp; 1)) continue; for (int s2 = (s - 1) &amp; s; s2; s2 = (s2 - 1) &amp; s) &#123; if (!(s2 &amp; 1)) continue; g[s] = (g[s] - g[s2] * f[s-s2] % mod + mod) % mod; &#125; &#125; printf(\"%lld\\n\", g[(1&lt;&lt;n)-1]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://akdream.tk/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"切糕「HNOI2013」","slug":"切糕「HNOI2013」","date":"2020-06-05T14:07:50.000Z","updated":"2020-10-08T12:16:08.273Z","comments":true,"path":"post/c3f51beb.html/","link":"","permalink":"http://akdream.tk/post/c3f51beb.html/","excerpt":"","text":"题目描述经过千辛万苦小 A 得到了一块切糕，切糕的形状是长方体，小 A 打算拦腰将切糕切成两半分给小 B 。出于美观考虑，小 A 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。出于简便考虑，我们将切糕视作一个长$P$、宽$Q$、高$R$的长方体点阵。我们将位于第$z$层中第$x$行、第$y$列上$(1 \\le x \\le P, 1 \\le y \\le Q, 1 \\le z \\le R)$的点称为$(x,y,z)$，它有一个非负的不和谐值$v(x,y,z)$。一个合法的切面满足以下两个条件： 与每个纵轴(一共有$P\\times Q$个纵轴)有且仅有一个交点。即切面是一个函数$f(x,y)$，对于所有$1 \\le x \\le P, 1 \\le y \\le Q$，我们需指定一个切割点$f(x,y)$，且$1 \\le f(x,y) \\le R$。 切面需要满足一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有的$1 \\le x,x’ \\le P$和$1 \\le y,y’ \\le Q$，若$|x-x’|+|y-y’|=1$，则$|f(x,y)-f(x’,y’)| \\le D$，其中$D$是给定的一个非负整数。可能有许多切面$f$满足上面的条件，小 A 希望找出总的切割点上的不和谐值最小的那个，即$\\sum_{x,y}{v(x, y, f (x, y))}$最小。 输入格式输入文件第一行是三个正整数$P$,$Q$,$R$，表示切糕的长$P$、宽$Q$、高$R$。第二行有一个非负整数$D$，表示光滑性要求。接下来是$R$个$P$行$Q$列的矩阵，第$z$个矩阵的第$x$行第$y$列是$v(x,y,z) (1 \\le x \\le P, 1 \\le y \\le Q, 1 \\le z \\le R)$。 输出格式输出仅包含一个整数，表示在合法基础上最小的总不和谐值。 题解最小割 被CZH老师称作是模板题 首先看看第一个条件 对于每一个纵轴，我们都必须取一个高度$z$，表示这个纵轴从$z$这里切 我们可以这样来处理这件事情： 对于每条纵轴$(x,y)$，从源点连inf连向$(x,y,1)$，从$(x,y,R+1)$连inf连向汇点 然后对于每个$z\\in [1,R]$，从$(x,y,z)$连一条流量为$v(x,y,z)$的边连向$(x,y,z+1)$，像一条链一样 由于最后求的是最小割，所以这$R$条边里总是要割掉一条的，符合我们的题意 这样第一个条件就处理完了 接下来是第二个条件 随脚画了一个图 这里我们假设D=2，那么对于每个点$(x,y,z)$，都要向 和它相邻的竖轴的 高度为$z-D$的那几个点各连一条inf 比如这个例子中，$(x,y,4)$要向$(x,y+1,2)$连一条边，$(x,y+1,4)$也要向$(x,y,2)$连边 这有什么用呢？假设我们割的是图中的这两条边，实际上就相当于在切糕上切了$(x,y,4)$和$(x,y+1,1)$这两个地方 这样增加了这种反向边之后，我们发现沿着蓝色路径依然可以从源点到汇点，也就是说割那两条边的方案不是一个合法割 它也确实和题意不符 因为$4-1=3&gt;D$ 这就解决了第二个限制条件 还有一个问题是我做题的时候想到的：万一最小割的方案在一条链上割了两条边怎么办？ 实际上这种情况是不会出现的，画一画就能发现，如果一条链上割了两条边，那么重新连上其中一条边之后一定还是个合法割 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;const int inf = 0x7fffffff;int n, m, h, D, s, t;int dir[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;int a[50][50][50], id[50][50][50], tot; // id[x][y][z]表示切糕上的(x,y,z)对应网络流里的哪个点int now[100005], head[100005], pre[1000005], to[1000005], flow[1000005], sz = 1;void addedge(int u, int v, int w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; flow[sz] = w;&#125;int d[100005];bool bfs() &#123; queue&lt;int&gt; q; memset(d, 0, sizeof(d)); q.push(s); d[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (flow[i] &amp;&amp; !d[y]) &#123; d[y] = d[x] + 1; q.push(y); &#125; &#125; &#125; return d[t];&#125;int dfs(int x, int nowflow) &#123; if (!nowflow || x == t) return nowflow; int rest = nowflow; for (int i = now[x]; i; i = pre[i]) &#123; now[x] = i; int y = to[i]; if (flow[i] &amp;&amp; d[y] == d[x] + 1) &#123; int tmp = dfs(y, min(rest, flow[i])); if (!tmp) d[y] = 0; flow[i] -= tmp; flow[i^1] += tmp; rest -= tmp; if (!rest) break; &#125; &#125; return nowflow - rest;&#125;int dinic() &#123; int ret = 0; while (bfs()) &#123; for (int i = 0; i &lt;= tot; i++) now[i] = head[i]; ret += dfs(s, inf); &#125; return ret;&#125;int main() &#123; read(n); read(m); read(h); read(D); for (int k = 1; k &lt;= h; k++) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; read(a[i][j][k]); &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; for (int k = 1; k &lt;= h+1; k++) &#123; id[i][j][k] = ++tot; &#125; &#125; s = 0, t = ++tot; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; addedge(s, id[i][j][1], inf); addedge(id[i][j][1], s, 0); for (int k = 1; k &lt;= h; k++) &#123; addedge(id[i][j][k], id[i][j][k+1], a[i][j][k]); addedge(id[i][j][k+1], id[i][j][k], 0); &#125; addedge(id[i][j][h+1], t, inf); addedge(t, id[i][j][h+1], 0); for (int l = 0; l &lt; 4; l++) &#123; int x = i + dir[l][0], y = j + dir[l][1]; if (1 &lt;= x &amp;&amp; x &lt;= n &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= m) &#123; for (int k = 2; k + D &lt;= h; k++) &#123; addedge(id[i][j][k+D], id[x][y][k], inf); addedge(id[x][y][k], id[i][j][k+D], 0); &#125; &#125; &#125; &#125; printf(\"%d\\n\", dinic()); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://akdream.tk/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"寿司餐厅[SHOI2017]","slug":"寿司餐厅[SHOI2017]","date":"2020-05-25T14:14:47.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/d4fc01b2.html/","link":"","permalink":"http://akdream.tk/post/d4fc01b2.html/","excerpt":"","text":"题目描述Kiana 最近喜欢到一家非常美味的寿司餐厅用餐。 每天晚上，这家餐厅都会按顺序提供$n$种寿司，第$i$种寿司有一个代号$a_i$和美味度$d_{i, i}$，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana 也可以无限次取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即 Kiana 可以一次取走第$1, 2$种寿司各一份，也可以一次取走第$2, 3$种寿司各一份，但不可以一次取走第$1, 3$种寿司。 由于餐厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水果寿司一起吃就可能会肚子痛。因此，Kiana 定义了一个综合美味度$d_{i, j} \\ (i &lt; j)$，表示在一次取的寿司中，如果包含了餐厅提供的从第$i$份到第$j$份的所有寿司，吃掉这次取的所有寿司后将获得的额外美味度。由于取寿司需要花费一些时间，所以我们认为分两次取来的寿司之间相互不会影响。注意在吃一次取的寿司时，不止一个综合美味度会被累加，比如若 Kiana 一次取走了第$1, 2, 3$种寿司各一份，除了$d_{1, 3}$以外，$d_{1, 2}, d_{2, 3}$也会被累加进总美味度中。 神奇的是，Kiana 的美食评判标准是有记忆性的，无论是单种寿司的美味度，还是多种寿司组合起来的综合美味度，在计入 Kiana 的总美味度时都只会被累加一次。比如，若 Kiana 某一次取走了第$1, 2$种寿司各一份，另一次取走了第$2, 3$种寿司各一份，那么这两次取寿司的总美味度为$d_{1, 1} + d_{2, 2} + d_{3, 3} + d_{1, 2} + d_{2, 3}$，其中$d_{2, 2}$只会计算一次。 奇怪的是，这家寿司餐厅的收费标准很不同寻常。具体来说，如果 Kiana 一共吃过了$c \\ (c &gt; 0)$种代号为$x$的寿司，则她需要为这些寿司付出$mx^2 + cx$，其中$m$是餐厅给出的一个常数。 现在 Kiana 想知道，在这家餐厅吃寿司，自己能获得的总美味度（包括所有吃掉的单种寿司的美味度和所有被累加的综合美味度）减去花费的总钱数的最大值是多少。由于她不会算，所以希望由你告诉她。 题面又臭又长 输入格式第一行包含两个正整数$n, m$，分别表示这家餐厅提供的寿司总数和计算寿司价格中使用的常数。第二行包含$n$个正整数，其中第$k$个数$a_k$表示第$k$份寿司的代号。接下来$n$行，第$i$行包含$n - i + 1$个整数，其中第$j$个数$d_{i, i+j-1}$表示吃掉寿司能获得的相应的美味度，具体含义见问题描述。 输出格式输出共一行包含一个正整数，表示 Kiana 能获得的总美味度减去花费的总钱数的最大值。 题解注意一下 吃寿司的代价和你吃了多少种有关，而不是吃了多少个。。。 第一眼看是DP 然而很快就发现有时候取重叠的区间可能更优 于是DP就没有了 而且数据范围这么小 怎么看都是网络流 但是蒟蒻不会建图 回头看了一下题解 发现其实还挺套路的。。。 一个经典的最小割模型(好像还叫什么最大权闭合子图？) 我们对于每个寿司区间都建立一个点 如果最小割割完后这个点在源点的联通块就表示我们选了这个区间 如果在汇点的联通块就表示没选 对于有着正美味度的区间$[i,j]$，从源点向它连一条流量为美味度$d_{i,j}$的边，表示不选这个点要付出$d_{i,j}$的代价 对于有着负美味度的区间$[i,j]$，从它向汇点连一条流量为$-d_{i,j}$的边，表示选了这个点要付出$-d_{i,j}$的代价 因为如果选了$[i,j]$，必然选了它的所有子区间，所以我们对于每个区间$[i,j]$： 从$[i,j]$向$[i+1,j]$和$[i,j+1]$分别连一条流量为$inf$的边，表示选了$[i,j]$必须选剩下两个 然后看看每个寿司的选择代价要怎么处理 我们同样对于每个单个的寿司建一个点 对于每个寿司点$i$，向汇点连一条流量为代号$a_i$的边 表示选过这个寿司要付出$a_i$的代价 从区间点$[i,i]$向寿司点$i$连一条流量为$inf$的边 表示选了前者必须选后者 最后看看那个$mx^2$的代价怎么处理： 如法炮制，我们对于每个寿司代号建一个点 对于代号点$x$，向汇点连一条流量为$mx^2$的边 从每个代号为$x$的寿司点 向这个代号点$x$连一条$inf$表示选了那个寿司就要付出代号的$mx^2$代价 最小割等于最大流 用dinic求出 然后我们注意到类型1的边是”不选它会付出$d_{i,j}$”的代价 所以初始时我们把答案设置成所有正的美味度之和 然后最终答案就是 所有正的美味度之和 减去最小割 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;num) &#123; T x = 0, _f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') _f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * _f; &#125;const int inf = 0x7fffffff;int n, m, s, t, c[205], val[205][205], d[12005], ans;int now[12005], head[12005], pre[500005], to[500005], flow[500005], sz = 1;int ind[205][205], indtp[1005], tot;bool vis[1005];inline void addedge(int u, int v, int w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; flow[sz] = w;&#125; bool bfs() &#123; memset(d, 0, sizeof(d)); queue&lt;int&gt; q; q.push(s); d[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (flow[i] &gt; 0 &amp;&amp; d[y] == 0) &#123; d[y] = d[x] + 1; q.push(y); &#125; &#125; &#125; return (d[t] != 0);&#125;int dfs(int x, int cur) &#123; if (x == t || cur &lt;= 0) return cur; int rest = cur; for (int i = now[x]; i; i = pre[i]) &#123; now[x] = i; int y = to[i]; if (flow[i] &gt; 0 &amp;&amp; d[y] == d[x] + 1) &#123; int tmp = dfs(y, min(rest, flow[i])); if (tmp &lt;= 0) d[y] = 0; flow[i] -= tmp; flow[i^1] += tmp; rest -= tmp; if (rest &lt;= 0) break; &#125; &#125; return cur - rest;&#125;int dinic() &#123; int ret = 0; while (bfs()) &#123; memcpy(now, head, sizeof(now)); ret += dfs(s, inf); &#125; return ret;&#125;void preind() &#123; s = 0; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[c[i]]) &#123; indtp[c[i]] = ++tot; vis[c[i]] = 1; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; ind[i][j] = ++tot; &#125; &#125; t = ++tot;&#125;int main() &#123; read(n); read(m); tot = n; for (int i = 1; i &lt;= n; i++) &#123; read(c[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; read(val[i][j]); &#125; &#125; preind(); for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; if (val[i][j] &gt;= 0) &#123; addedge(s, ind[i][j], val[i][j]); //边类型1 addedge(ind[i][j], s, 0); ans += val[i][j]; &#125; else &#123; addedge(ind[i][j], t, -val[i][j]); //边类型2 addedge(t, ind[i][j], 0); &#125; if (i != j) &#123; addedge(ind[i][j], ind[i][j-1], inf); //边类型3 addedge(ind[i][j-1], ind[i][j], 0); addedge(ind[i][j], ind[i+1][j], inf); addedge(ind[i+1][j], ind[i][j], 0); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; addedge(ind[i][i], i, inf); addedge(i, ind[i][i], 0); //边类型5 addedge(i, t, c[i]); addedge(t, i, 0); //边类型4 addedge(i, indtp[c[i]], inf); addedge(indtp[c[i]], i, 0); //边类型7 &#125; for (int i = 1; i &lt;= 1000; i++) &#123; if (vis[i] &amp;&amp; m) &#123; addedge(indtp[i], t, m * i * i); addedge(t, indtp[i], 0); //边类型6 &#125; &#125; printf(\"%d\\n\", ans - dinic()); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://akdream.tk/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"陌上花开[BZOJ3262]","slug":"陌上花开[BZOJ3262]","date":"2020-05-14T14:30:05.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/186b5ecc.html/","link":"","permalink":"http://akdream.tk/post/186b5ecc.html/","excerpt":"","text":"题目描述有$n$朵花,每朵花有三个属性:花形($S$)、颜色($C$)、气味($M$),用三个整数表示。 现在要对每朵花评级,一朵花的级别是它拥有的美丽能超过的花的数量。 定义一朵花A比另一朵花B要美丽,当且仅$S_a&gt;=S_b,C_a&gt;=C_b,M_a&gt;=M_b$。 显然,两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。 输入格式第一行为$N,~K\\ (1 &lt;= N &lt;= 100,000, 1 &lt;= K &lt;= 200,000)$, 分别表示花的数量和最大属性值。 以下$N$行，每行三个整数$S_i,~ C_i, M_i\\ (1 &lt;= S_i, C_i, ~M_i &lt;= K)$，表示第$i$朵花的属性 输出格式包含$N$行，分别表示评级为$0\\dots N-1$的每级花的数量。 题解cdq分治模板题 我对cdq分治的理解是这样的： 有的时候 一些乱序的东西 我们要计算它们两两之间的贡献(或者转移贡献，比如dp)，把它们按照一定的(多维)顺序计算或转移才会比较方便；这时候就可以用cdq分治一维一维地进行处理 比如 此题的思路是这样的： 为了方便 我们把$S$称为$a$，$C$称为$b$，$M$称为$c$。 我们先来看看这道简化版的题： 有两个花的集合 一个是$S$一个是$T$。 求：对于每个$T$中的元素$j$有多少个$S$中的元素$i$满足S[i].a&lt;=T[j].a且S[i].b&lt;=T[j].b 这个问题很好解决 我们分别把$S$和$T$中元素按照$a$排序 然后维护双指针和树状数组 每次枚举到$T$中的一个元素$j$时 就把$S$中所有现在满足了S[i].a&lt;=T[j].a的花放进去 然后再统计$j$的答案 12345678910void solve(int n, int m) &#123; int i, j; for (i = 1, j = 1; j &lt;= m; j++) &#123; while (i &lt;= n &amp;&amp; S[i].a &lt;= T[j].a) &#123; update(S[i].b, 1); //放入树状数组 i++; &#125; T[j].ans = getsum(T[j].b); &#125;&#125; 然后我们把问题扩展到三维 先把所有花按照$a$排序，然后开始进行分治： 首先要理解一点，分治时solve(l,r)实际上就是在计算[l,mid]和[mid+1,r]两组元素两两匹配的贡献 我们看看怎么来solve(l,r)： 第一步是先递归解决solve(l,mid)和solve(mid+1,r) 123if (l == r) return;int mid = (l + r) &gt;&gt; 1;solve(l, mid); solve(mid+1, r); 这个其实是因题而异的 这题因为对[l,r]的后续排序(下面这个排序)可能会影响到这个初始时以$a$为第一关键字的顺序 所以要先把两个子区间计算完 然后我们分别把[l,mid]和[mid+1,r]以$b$为第一关键字排序 1sort(p + l, p + mid + 1, cmp2); sort(p + mid + 1, p + r + 1, cmp2); 注意 这样排序之后 虽然[l,mid]区间内可能不满足$a$单调不降了 但是[l,mid]区间内任意一个$a$仍然是小于等于[mid+1,r]区间内任意一个$a$的(划重点!!!) 所以我们用右半边匹配左半边时是不用考虑$a$的问题的 现在两边都已经按照$b$排序了 且右半边的$a$一定大于等于左半边任意一个$a$所以$a$这一维已经相当于没用了 直接扔了 然后这是不是就变成了上面的”简化版问题”了呢？即由[mid+1,r]中的元素构成的集合$T$去匹配[l,mid]构成的集合$S$ 那么我们就直接用上面的方法进行匹配 12345678int i, j;for (i = l, j = mid + 1; j &lt;= r; j++) &#123; while (i &lt;= mid &amp;&amp; p[j].b &gt;= p[i].b) &#123; update(p[i].c, 1); i++; &#125; p[j].ans += getsum(p[j].c); //注意这里是加算，j的答案不止统计一次&#125; solve完之后记得清空树状数组 123for (j = l; j &lt; i; j++) &#123; update(p[j].c, -1);&#125; 这就是solve的全过程了 不知道我写的易不易懂QAQ 为了方便理解，我们透过现象看看这个事情的本质(不是) 比如说$n=8$我们看看按$a$排序后第8位被统计了几次贡献： 首先 solve(7,8)的时候，计算了[7,7]对8的贡献solve(5,8)时，计算了[5,6]的贡献solve(1,8)时，计算了[1,4]的贡献 所以 实际上 所有$a$值小于第8位的花都有与8尝试匹配过 随便换个数也是这样 所以这个算法是正确的 再来看看时间复杂度$T(n)=2T(n/2)+n\\log n$得到复杂度是$O(n\\log^2 n)$的 然后这题还有一个小细节：会出现一模一样的元素 由于两个一样的元素$x,y$，$x$满足$a_x\\le a_y,~b_x\\le b_y, ~c_x\\le c_y$，反过来也满足，所以没法直接用分治算 我们可以把相同的元素全部合并到一起 像离散化一样 然后记录一下这种元素共有多少个 记为$cnt_i$ 最后统计答案时 某种花的评级应该是(小于它的花的总数量+这种花的数量-1) 因为相同的花会两两相互产生贡献。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, m, ak, ans[100005];struct node&#123; int a, b, c, cnt, ans;&#125; tmp[100005], p[100005];inline bool cmp1(node x, node y) &#123; if (x.a != y.a) return x.a &lt; y.a; else if (x.b != y.b) return x.b &lt; y.b; else return x.c &lt; y.c;&#125;inline bool cmp2(node x, node y) &#123; if (x.b != y.b) return x.b &lt; y.b; else return x.c &lt; y.c;&#125;//树状数组 int tr[200005];inline void update(int x, int v) &#123; for (; x &lt;= 200000; x += x &amp; -x) &#123; tr[x] += v; &#125;&#125;inline int getsum(int x) &#123; int ret = 0; for (; x; x -= x &amp; -x) &#123; ret += tr[x]; &#125; return ret;&#125;void solve(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; solve(l, mid); solve(mid+1, r); sort(p + l, p + mid + 1, cmp2); sort(p + mid + 1, p + r + 1, cmp2); int i, j; for (i = l, j = mid + 1; j &lt;= r; j++) &#123; while (i &lt;= mid &amp;&amp; p[j].b &gt;= p[i].b) &#123; update(p[i].c, p[i].cnt); i++; &#125; p[j].ans += getsum(p[j].c); &#125; for (j = l; j &lt; i; j++) &#123; update(p[j].c, -p[j].cnt); &#125;&#125;int main() &#123; read(n); read(ak); for (int i = 1; i &lt;= n; i++) &#123; read(tmp[i].a), read(tmp[i].b), read(tmp[i].c); &#125; sort(tmp + 1, tmp + n + 1, cmp1); int now = 1; for (int i = 2; i &lt;= n; i++) &#123; //去重 if (tmp[i].a == tmp[i-1].a &amp;&amp; tmp[i].b == tmp[i-1].b &amp;&amp; tmp[i].c == tmp[i-1].c) &#123; now++; &#125; else &#123; p[++m].a = tmp[i-1].a; p[m].b = tmp[i-1].b; p[m].c = tmp[i-1].c; p[m].cnt = now; p[m].ans = 0; now = 1; &#125; &#125; p[++m].a = tmp[n].a; p[m].b = tmp[n].b; p[m].c = tmp[n].c; p[m].cnt = now; p[m].ans = 0; now = 1; solve(1, m); for (int i = 1; i &lt;= m; i++) &#123; ans[p[i].ans + p[i].cnt - 1] += p[i].cnt; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"cdq分治","slug":"cdq分治","permalink":"http://akdream.tk/tags/cdq%E5%88%86%E6%B2%BB/"}]},{"title":"玩具装箱[HNOI2008]","slug":"玩具装箱[HNOI2008]","date":"2020-05-10T14:03:22.000Z","updated":"2020-10-08T12:16:08.618Z","comments":true,"path":"post/1b5a97aa.html/","link":"","permalink":"http://akdream.tk/post/1b5a97aa.html/","excerpt":"","text":"题目描述P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。 P 教授有编号为$1 \\cdots n$的$n$件玩具，第$i$件玩具经过压缩后的一维长度为$C_i$。 为了方便整理，P教授要求： 在一个一维容器中的玩具编号是连续的。 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第$i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为$x=j-i+\\sum\\limits_{k=i}^{j}C_k$ 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$x$，其制作费用为$(x-L)^2$。其中$L$是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望所有容器的总费用最小。 输入格式第一行有两个整数，用一个空格隔开，分别代表$n$和$L$。 第$2$到 第$(n + 1)$行，每行一个整数，第$(i + 1)$行的整数代表第$i$件玩具的长度$C_i$。 输出格式输出一行一个整数，代表所有容器的总费用最小是多少。 补一道斜率优化模板题QWQ 题解设$dp[i]$表示装前$i$个玩具的最小花费，$sum[i]$为前$i$个玩具的$C_i$之和 转移方程非常显然：$dp[i]=\\min_{j=0}^{i-1} dp[j]+(sum[i]-sum[j]+i-j-1-L)^2$ 一个经典的1D/1D动态规划 直接转移是$n^2$的 由于这题转移方程有平方项所以也不能直接用单调队列 看到有二次项的1D/1D动态规划就要考虑使用斜率优化 接下来说说什么是斜率优化 我们给原方程变个形 设$A_i=sum[i]+i,B_i=sum[i]+i+L+1$ 那个$\\min$看着麻烦 先扔掉了 那么现在有$dp[i]=dp[j]+(A_i-B_j)^2$ 拆开完全平方，得到$dp[i]=dp[j]+A_i^2-2*A_i*B_j+B_j^2$ 把只含$j$的全部移到左边，得到$(dp[j]+B_j^2)=(2*A_i)*B_j+(dp[i]-A_i^2)$ 为什么要打上括号？ 看一下直线的斜截式的方程$y=kx+b$我们的转移方程里 让$y=dp[j]+B_j^2, k=(2*A_i), x=B_j, b=(dp[i]-A_i^2)$就是一条直线方程 其中$j&lt;i$，所以$dp[j]$我们已经算出来了 所以$y,k,x$都是已知的 $j&lt;i$的$j$不止一个 所以实际上现在在二维平面上有很多个点 第$j$个点的坐标为$(B_j, dp[j]+B_j^2)$ 由于$A_i^2$已知，我们希望$dp[i]$尽量小就是要让$dp[i]-A_i^2$尽量小 也就是截距要尽量小 所以我们现在需要在二维平面上选一个点$j$过它画一条斜率为$2*A_i$的直线 直线的截距即是$dp[i]-A_i^2$ 比如像是这样？ 这是我们在推$dp[6]$当直线斜率为$2*A_6$时 我们发现让它经过第3个点得到的截距最小 从而我们就能让$dp[6]$的值从$dp[3]$转移过来 然后在图中加入第6个点$(B_6,dp[6]+B_6^2)$ 问题来了 我们怎么快速求得经过哪个点会使得截距最小？ 这题有一个很重要的性质：$x$,即$B_j$; 以及$k$,即$2*A_i$(满足决策单调性!!!); 这两个都是递增的 (没有这个性质就不能用单调队列了 而是用cdq分治之类的算法) 所以第$i$个点一定在第$i-1$个点右边 而且直线的斜率也只会越来越大 我们对于已经存在的点 维护一个下凸壳 放在单调队列里 我们记第$j$个点为$p_j$，记相邻两点连成的直线的斜率为$\\operatorname{slope}(p_{j-1},p_j)$ 假设当前在推$dp[6]$的值 则我们要画一条斜率为$2*A_6$的直线 观察一下 我们发现 找到凸壳上第一个$j$满足$\\operatorname{slope}(p_{j},p_{j+1})&gt;2*A_6$，过这个点画直线就是最优的 这个例子中这个点就是3 而且还有一个之前提到的性质$2*A_i$是单增的 所以如果某个$\\operatorname{slope}(p_{j},p_{j+1})&lt;2*A_6$那么对于之后的$i&gt;6$，也一定是$\\operatorname{slope}(p_{j},p_{j+1})&lt;2*A_i$所以$j$这个点无论如何都不再会被用到 就直接从队列里弹出 ① 最后单调队列的队头就是最优的决策点 我们算出$dp[6]$的值 由于$B_j$是递增的 我们可以直接把$(B_6,dp[6]+B_6^2)$拿去更新这个凸包 更新时$(B_6,dp[6]+B_6^2)$可能在这里 此时$\\operatorname{slope}(p_{4},p_{5})&gt;\\operatorname{slope}(p_{5},p_{6})$ 为了维护凸包的性质 我们把$4\\rightarrow 5$这条边从队列里删掉(即把5弹出) 然后再加入6 ② 实现起来其实很简单 结合注释看看吧 每个点最多出队入队一次 时间复杂度$O(n)$不知道为什么原题数据规模这么小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;int n, head, tail, q[100005]; ll l, c[100005], a[100005], b[100005], dp[100005];struct point&#123; ll x, y; point() &#123;&#125; point(ll xx, ll yy): x(xx), y(yy) &#123;&#125;&#125; p[100005];double slope(point A, point B) &#123; return 1.0 * (A.y - B.y) / (A.x - B.x);&#125;int main() &#123; read(n); read(l); b[0] = l + 1; for (int i = 1; i &lt;= n; i++) &#123; read(c[i]); a[i] = a[i-1] + c[i] + 1; //预处理Ai,Bi b[i] = b[i-1] + c[i] + 1; &#125; head = tail = 1; p[0] = point(b[0], b[0] * b[0]); //开始时队列里只有0号点 q[1] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (head &lt; tail &amp;&amp; slope(p[q[head]], p[q[head+1]]) &lt; 2.0 * a[i] + 1e-8) head++; //文中注释1 dp[i] = dp[q[head]] + (a[i] - b[q[head]]) * (a[i] - b[q[head]]); //q[head]为最佳决策点 直接用原转移方程更新dp[i] p[i] = point(b[i], dp[i] + b[i] * b[i]); //确定i号点的位置 while (head &lt; tail &amp;&amp; slope(p[q[tail-1]], p[q[tail]]) + 1e-8 &gt; slope(p[q[tail]], p[i])) tail--; //文中注释2 q[++tail] = i; &#125; printf(\"%lld\\n\", dp[n]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"任意模数NTT(拆系数FFT)","slug":"任意模数NTT(拆系数FFT)","date":"2020-05-10T12:19:11.000Z","updated":"2020-10-08T12:16:08.213Z","comments":true,"path":"post/b610041.html/","link":"","permalink":"http://akdream.tk/post/b610041.html/","excerpt":"","text":"题目描述给定$2$个多项式$F(x), G(x)$，请求出$F(x) * G(x)$。 系数对$p$取模，且不保证$p$可以分解成$p = a \\cdot 2^k + 1$之形式。 输入/输出不关心 $1 \\leq n \\leq 10^5, 0 \\leq a_i, b_i \\leq 10^9, 2 \\leq p \\leq 10^9 + 9$ 题解主要是记录一下一次FFT同时对两个多项式进行DFT或IDFT这个常数技巧是怎么实现的。。。推式子什么的我也不会 现在这里有两个多项式$A(x),B(x)$，这两个多项式我们都需要做一次DFT 那么我们定义$P(x)=A(x)+i*B(x), Q(x)=A(x)-i*B(x)$ 我们把$P(x)$经过DFT后的第$k$项记为$DFT(P_k)$ (其他的也同理)，经过一些证明我们可以得到这样一个结论：$DFT(P_k)和DFT(Q_{n-k})$互为共轭复数，特殊的，$DFT(P_0)$和$DFT(Q_0)$为共轭复数 所以我们一次正向FFT之后求出所有的$DFT(P_k)$，就可以直接算出$DFT(Q_k)$ 而此时$DFT(A_k)=\\dfrac{DFT(P_k)+DFT(Q_k)}{2}, DFT(B_k)=-i*\\dfrac{DFT(P_k)-DFT(Q_k)}{2}$也是直接算出来就好了 综上 我们只用了一次FFT就对$A(x)$和$B(x)$都进行了DFT 而不用两次 代码实现： 12345678910111213void DFT(Complex *A, Complex *B) &#123; for (int i = 0; i &lt; lim; i++) &#123; p[i] = A[i] + I * B[i]; &#125; FFT(p, 1); for (int i = 0; i &lt; lim; i++) &#123; q[i] = conj(i ? p[lim-i] : p[0]); //conj:共轭复数 &#125; for (int i = 0; i &lt; lim; i++) &#123; A[i] = (p[i] + q[i]) / 2; B[i] = (p[i] - q[i]) * I / -2; &#125;&#125; IDFT也可以一次FFT处理两个多项式 对于两个点值表达的多项式$C(x), D(x)$ 我们让$R(x)=C(x)+i*D(x)$ 然后对$R$进行反向FFT 最后$IDFT(R_k)$的实部就是$IDFT(C_k)$，$IDFT(R_k)$的虚部就是$IDFT(D_k)$ 这个就更好实现了 12345678910void IDFT(Complex *C, Complex *D) &#123; for (int i = 0; i &lt; lim; i++) &#123; r[i] = C[i] + I * D[i]; &#125; FFT(r, -1); for (int i = 0; i &lt; lim; i++) &#123; C[i].x = r[i].x; D[i].x = r[i].y; &#125;&#125; 所以我们又只用了一次FFT就算出两个点值表达式IDFT后的结果 好像有人给这个取了个名字叫MTT 这个技巧的使用没有什么限制，只要有两个多项式都需要进行DFT/IDFT就可以用 不卡时限的题目还是不怎么需要用到这个技巧的。。。但是此题就要用 回到此题当然你可以用三模数NTT 但是蒟蒻我并不会用 所以用FFT 如果直接FFT爆乘的话 肯定会爆出double的范围 但是 如果我们把F(x)拆成两个多项式$F(x)=A(x)*2^{15}+A_2(x)$，把$G(x)$拆成$G(x)=B(x)*2^{15}+B_2(x)$ 然后计算$(A(x)*2^{15}+A_2(x))(B(x)*2^{15}+B_2(x))=A(x)*B(x)*2^{30}+(A(x)*B_2(x)+A_2(x)*B(x))*2^{15}+A_2(x)*B_2(x)$ 这四个式子两两相乘是不会乘爆的 但是这样做需要做8次FFT(为了不乘爆最少也要7次) 时间上接受不了 用上面的那个技巧 我们可以把FFT的次数优化到4次 具体来说 就是$A(x)和A_2(x)$的DFT一起做$B(x)和B_2(x)$的DFT一起做 然后分别算出$A(x)*B(x),A(x)*B_2(x),A_2(x)*B(x),A_2(x)*B_2(x)$，同样两个一组做IDFT 一共4次 完美 时间上还过得去 只比NTT慢一倍左右吧 注意一定要用long double。。。可能是乘积太大了导致精度不够用 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;struct Complex &#123; long double x, y; Complex(long double xx = 0, long double yy = 0): x(xx), y(yy) &#123;&#125;&#125;;inline Complex operator + (Complex p, Complex q) &#123; return Complex(p.x+q.x , p.y+q.y); &#125;inline Complex operator - (Complex p, Complex q) &#123; return Complex(p.x-q.x , p.y-q.y); &#125;inline Complex operator * (Complex p, Complex q) &#123; return Complex(p.x*q.x-p.y*q.y , p.x*q.y+p.y*q.x); &#125;inline Complex operator / (Complex p, long double q) &#123; return Complex(p.x/q, p.y/q); &#125;inline Complex conj(Complex p) &#123; return Complex(p.x, -p.y); &#125;Complex I = Complex(0, 1), p[500005], q[500005], a[500005], a2[500005], b[500005], b2[500005];ll n, m, mod, lim, l, rev[500005], ans[500005];const long double pi = acos(-1.0);void FFT(Complex *c, int tp) &#123; for (int i = 0; i &lt; lim; i++) &#123; if (i &lt; rev[i]) swap(c[i], c[rev[i]]); &#125; for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; Complex wn = Complex(cos(pi / mid), sin(pi / mid) * tp); for (int r = mid&lt;&lt;1, j = 0; j &lt; lim; j += r) &#123; Complex w = Complex(1, 0); for (int k = 0; k &lt; mid; k++, w = w * wn) &#123; Complex x = c[j+k], y = w * c[j+k+mid]; c[j+k] = x + y; c[j+k+mid] = x - y; &#125; &#125; &#125;&#125;void DFT(Complex *A, Complex *B) &#123; //两个一起做DFT for (int i = 0; i &lt; lim; i++) &#123; p[i] = A[i] + I * B[i]; &#125; FFT(p, 1); for (int i = 0; i &lt; lim; i++) &#123; q[i] = conj(i ? p[lim-i] : p[0]); &#125; for (int i = 0; i &lt; lim; i++) &#123; A[i] = (p[i] + q[i]) / 2; B[i] = (p[i] - q[i]) * I / -2; &#125;&#125; int main() &#123; read(n), read(m), read(mod); lim = 1, l = 0; while (lim &lt; n + m) &#123; lim &lt;&lt;= 1; l++; &#125; for (int i = 0; i &lt; lim; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); &#125; for (int i = 0; i &lt;= n; i++) &#123; ll x; read(x); a[i].x = x &gt;&gt; 15; a2[i].x = x &amp; 0x7fff; //(0x7fff == 2^15) &#125; for (int i = 0; i &lt;= m; i++) &#123; ll x; read(x); b[i].x = x &gt;&gt; 15; b2[i].x = x &amp; 0x7fff; &#125; DFT(a, a2); DFT(b, b2); for (int i = 0; i &lt; lim; i++) &#123; p[i] = a[i] * b[i] + a[i] * b2[i] * I; //两个一组做IDFT q[i] = a2[i] * b[i] + a2[i] * b2[i] * I; &#125; FFT(p, -1); FFT(q, -1); for (int i = 0; i &lt; lim; i++) &#123; ll ab, ab2, a2b, a2b2; ab = (ll)(p[i].x / lim + 0.5) % mod; a2b = (ll)(q[i].x / lim + 0.5) % mod; ab2 = (ll)(p[i].y / lim + 0.5) % mod; a2b2 = (ll)(q[i].y / lim + 0.5) % mod; ans[i] = (((ab &lt;&lt; 30) % mod) + ((((ab2 + a2b) % mod) &lt;&lt; 15) % mod) + a2b2) % mod; &#125; for (int i = 0; i &lt;= n + m; i++) &#123; printf(\"%lld \", ans[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://akdream.tk/tags/FFT/"}]},{"title":"树点涂色[SDOI2017]","slug":"树点涂色[SDOI2017]","date":"2020-05-08T09:43:08.000Z","updated":"2020-10-08T12:16:08.556Z","comments":true,"path":"post/22b449ed.html/","link":"","permalink":"http://akdream.tk/post/22b449ed.html/","excerpt":"","text":"【题目描述】 Bob 有一棵$n$个点的有根树，其中$1$号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。 定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。 Bob可能会进行这几种操作： 1 x 表示把点$x$到根节点的路径上所有的点染上一种没有用过的新颜色。 2 x y 求$x$到$y$的路径的权值。 3 x 在以$x$为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。 Bob一共会进行$m$次操作 【输入格式】 第一行两个数$n,m$。 接下来$n-1$行，每行两个数$a,b$，表示$a$与$b$之间有一条边。 接下来$m$行，表示操作，格式见题目描述 【输出格式】 每当出现$2,3$操作，输出一行。 如果是$2$操作，输出一个数表示路径的权值 如果是$3$操作，输出一个数表示权值的最大值 题解想了5分钟就决定去看题解的我这种蒟蒻是屑 看了题解就开始写 居然一次就过了 学数据结构学傻了(确信) 我们先来看一下这个1操作 由于每次都是把到根的路径染一种全新的颜色 所以任意一种颜色的所有点都一定在连续的一条路径上面 然后再看这个 每次都是修改从点$x$到根的路径 有没有想到LCT的access操作 access就是将根到点$x$的路径上的点全部扔到一个splay里面 所以思路就很显然了 我们用LCT来维护点的颜色 也就是把所有颜色相同的点全部都放在一棵splay里面 初始时因为所有点颜色各不相同 所以所有边都是虚边 也就是说每个点都是一棵splay 然后每次1操作直接access即可 再看看两种询问如何回答 先看看2操作 这里有一个性质 记$x$到根路径上的颜色种数为f[x]，那么$x,y$路径上的颜色种数为f[x]+f[y]-2*f[lca]+1 一眼看上去很正常 等等 +1是什么鬼 $lca$那个点的颜色假设是$c$那么$c$这种颜色在f[x]和f[y]被各加了一次 又在-2*f[lca]被减了两次 所以还要加回来 问题是f[x]在access时要怎么维护 从oi-wiki盗了张图 _(:з」∠)_ 有一棵长成这样的树 假设现在它的轻重边划分是这样的 (注意 这棵是原树 不是LCT) 现在我们把$A\\rightarrow N$的点全部染成一种新的颜色 边的虚实要这样修改 那么$N\\rightarrow O$这条边就会从实边变成虚边 因为$N$的颜色不再和$O$一样了 所以我们把$O$子树中所有点的f[x]+1 再往上走的时候$I\\rightarrow K$也从实边变成虚边 一样把$K$子树中所有点f[x]+1 然后我们发现$I\\rightarrow L$这条边由虚变实了 也就是说原来$I$和$L$的颜色不一样 现在一样了 所以把$L$子树中所有点f[x]-1 总而言之 就是虚变实要-1 实变虚要+1 在access里面实现的时候就是每次找到当前这棵splay里面最靠左的点(按定义这个点是原树中深度最浅的点) 把这个点的子树+1或-1 不知道如何解释。。。具体见代码 然后就好办了 子树区间加用线段树就完了 2操作就是找$lca$然后线段树单点查询 直接输出即可 3操作就是线段树区间取$\\text{max}$ 初始时由于每个点的颜色互不相同 所以f[x]就等于$x$在原树上的深度(也就是到根的路径上有多少个点) 码量极大 我写了200行。。。(虽然一遍就过了) 看网上有人说这题是LCT+树剖 但是实际上没有用到树剖的思想。。。顶多用了一下求LCA 但是似乎也有纯树剖切此题的神犇Orz 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;int n, m, head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; &#125;int fa[N], dfn[N], ed[N], rnk[N], tme, d[N], top[N], son[N], siz[N]; //由于还要维护什么深度 dfs序之类的东西 所以直接来一次树剖比较方便 void dfs(int x) &#123; siz[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x]) continue; fa[y] = x; d[y] = d[x] + 1; dfs(y); siz[x] += siz[y]; if (!son[x] || siz[son[x]] &lt; siz[y]) son[x] = y; &#125;&#125;void dfs2(int x, int tp) &#123; top[x] = tp; dfn[x] = ++tme; rnk[tme] = x; if (son[x]) dfs2(son[x], tp); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x] || y == son[x]) continue; dfs2(y, y); &#125; ed[x] = tme;&#125;inline int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) swap(x, y); x = fa[top[x]]; &#125; if (d[x] &gt; d[y]) swap(x, y); return x;&#125;namespace Segtree&#123; struct tree&#123; int l, r, mx, tag; &#125; tr[N&lt;&lt;2]; #define lson ind&lt;&lt;1 #define rson ind&lt;&lt;1|1 void build(int ind, int l, int r) &#123; tr[ind].l = l; tr[ind].r = r; tr[ind].tag = 0; if (l == r) &#123; tr[ind].mx = d[rnk[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); tr[ind].mx = max(tr[lson].mx, tr[rson].mx); &#125; inline void pushdown(int ind) &#123; if (!tr[ind].tag) return; int v = tr[ind].tag; tr[ind].tag = 0; tr[lson].mx += v; tr[lson].tag += v; tr[rson].mx += v; tr[rson].tag += v; &#125; void update(int ind, int x, int y, int v) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].mx += v; tr[ind].tag += v; return; &#125; pushdown(ind); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(lson, x, y, v); if (mid &lt; y) update(rson, x, y, v); tr[ind].mx = max(tr[lson].mx, tr[rson].mx); &#125; int query(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) return tr[ind].mx; pushdown(ind); int mid = (l + r) &gt;&gt; 1, ret = 0; if (x &lt;= mid) ret = max(ret, query(lson, x, y)); if (mid &lt; y) ret = max(ret, query(rson, x, y)); return ret; &#125; #undef lson #undef rson&#125;namespace LCT&#123; int ch[N][2], fa[N], tag[N]; #define lson ch[x][0] #define rson ch[x][1] //并不需要 pushup inline void rev(int x) &#123; swap(lson, rson); tag[x] ^= 1; &#125; inline void pushdown(int x) &#123; if (!tag[x]) return; if (lson) rev(lson); if (rson) rev(rson); tag[x] = 0; &#125; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline void rotate(int x) &#123; int y = fa[x], z = fa[y], k = (ch[y][1]==x); if (!isroot(y)) ch[z][ch[z][1]==y] = x; fa[x] = z; ch[y][k] = ch[x][k^1]; fa[ch[x][k^1]] = y; ch[x][k^1] = y; fa[y] = x; &#125; int q[N], top; inline void splay(int x) &#123; q[top=1] = x; for (int i = x; !isroot(i); i = fa[i]) q[++top] = i; while (!top) pushdown(q[top--]); while (!isroot(x)) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) ((ch[z][1]==y) ^ (ch[y][1]==x)) ? rotate(x) : rotate(y); rotate(x); &#125; &#125; inline int pre(int x) &#123; //找到splay中权值(也就是原树中的深度)最小的点 while (lson) x = lson; return x; &#125; inline void access(int x) &#123; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x); if (ch[x][1]) &#123; int y = pre(ch[x][1]); //原树中 fa[y]-&gt;y 这条边由实变虚 Segtree::update(1, dfn[y], ed[y], 1); &#125; ch[x][1] = i; if (ch[x][1]) &#123; int y = pre(ch[x][1]); //原树中 fa[y]-&gt;y 这条边由虚变实 Segtree::update(1, dfn[y], ed[y], -1); &#125; &#125; &#125; #undef lson #undef rson&#125;int main() &#123; n = read(), m = read(); for (int i = 1, u, v; i &lt; n; i++) &#123; u = read(), v = read(); addedge(u, v); &#125; d[1] = 1; dfs(1); dfs2(1, 1); Segtree::build(1, 1, n); for (int i = 1; i &lt;= n; i++) &#123; LCT::ch[i][0] = LCT::ch[i][1] = LCT::tag[i] = 0; LCT::fa[i] = fa[i]; &#125; for (int i = 1, tp, x, y; i &lt;= m; i++) &#123; tp = read(); if (tp == 1) &#123; x = read(); LCT::access(x); &#125; else if (tp == 2) &#123; x = read(), y = read(); int lca = LCA(x, y); printf(\"%d\\n\", Segtree::query(1, dfn[x], dfn[x]) + Segtree::query(1, dfn[y], dfn[y]) - 2 * Segtree::query(1, dfn[lca], dfn[lca]) + 1); //namespace 的名字一定记得取短点 QAQ &#125; else &#123; x = read(); printf(\"%d\\n\", Segtree::query(1, dfn[x], ed[x])); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"}]},{"title":"文本生成器[JSOI2007]","slug":"文本生成器[JSOI2007]","date":"2020-05-04T06:23:40.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/89dc58e9.html/","link":"","permalink":"http://akdream.tk/post/89dc58e9.html/","excerpt":"","text":"【题目描述】 JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。 该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章$t$包含单词$t$，当且仅当单词$t$是文章$s$的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？ 答案对$10^4 + 7$取模。 【输入格式】 第一行有两个整数，分别表示使用者了解的单词总数$n$和生成的文章长度$m$。 接下来$n$行，每行一个字符串$s_i$，表示一个使用者了解的单词。 【输出格式】 输出一行一个整数表示答案对$10^4 + 7$取模的结果。 题解首先 很容易想到 答案就是总的方案数，也就是$26^m$减去不合法的方案数 不合法的方案数我们可以通过在AC自动机上面DP来求得 先对于那$n$个串建好AC自动机 显然，一个不合法的串在AC自动机上匹配时一定不会经过任何结束节点或者fail链上有结束节点的点 所以我们先预处理哪些是这样的节点 这个是可以在求fail的时候顺便处理的 然后设$dp[x][j]$表示现在在AC自动机上节点$x$处，串长度为$j$的方案数 转移方程：$dp[ch[x][c]][j+1]~ += ~dp[x][j]$ ($ch[x][c]$不为结束节点)，初始状态$dp[0][0]=1$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;const int mod = 10007;int n, m, dp[10005][205], ans;char s[205];struct AC_automaton&#123; int fail[10005], ch[10005][30], tot; bool tag[10005]; inline void insert(char *str, int len) &#123; int x = 0; for (int i = 1; i &lt;= len; i++) &#123; if (!ch[x][str[i]-'A']) ch[x][str[i]-'A'] = ++tot; x = ch[x][str[i]-'A']; &#125; tag[x] = 1; &#125; inline void getfail() &#123; queue&lt;int&gt; q; for (int i = 0; i &lt; 26; i++) if (ch[0][i]) q.push(ch[0][i]); while (!q.empty()) &#123; int x = q.front(); q.pop(); tag[x] |= tag[fail[x]]; for (int i = 0; i &lt; 26; i++) &#123; if (ch[x][i]) fail[ch[x][i]] = ch[fail[x]][i], q.push(ch[x][i]); else ch[x][i] = ch[fail[x]][i]; &#125; &#125; &#125; inline void DP() &#123; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 0; i &lt; m; i++) &#123; for (int x = 0; x &lt;= tot; x++) &#123; for (int c = 0; c &lt; 26; c++) &#123; if (!tag[ch[x][c]]) &#123; dp[ch[x][c]][i+1] = (dp[ch[x][c]][i+1] + dp[x][i]) % mod; &#125; &#125; &#125; &#125; ans = 1; for (int i = 1; i &lt;= m; i++) ans = ans * 26 % mod; for (int x = 0; x &lt;= tot; x++) &#123; ans = (ans - dp[x][m] + mod) % mod; &#125; &#125;&#125; T;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", s + 1); T.insert(s, strlen(s + 1)); &#125; T.getfail(); T.DP(); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"http://akdream.tk/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"糖果公园[WC2013]","slug":"糖果公园[WC2013]","date":"2020-04-30T13:28:52.000Z","updated":"2020-10-08T12:16:08.661Z","comments":true,"path":"post/2a12bc62.html/","link":"","permalink":"http://akdream.tk/post/2a12bc62.html/","excerpt":"","text":"【题目描述】 题目描述太长了。。。建议自行读题 传送门 题意：给你一棵树，每个点有一个颜色$c[x]$，每种颜色有一个权值$v[c]$，还有$n$个参数$w[i]$。 如果一条路径上颜色为$c$的点有$cnt$个，那么产生$v[c]*w[cnt]$的贡献，路径的总权值就是每种颜色产生的贡献和。 每次询问一条路径的权值或者更改一个点的颜色 【输入/输出格式】 不关心 题解这道题就是树上莫队和带修莫队缝合在了一起。。。实际上，如果你两种都会的话，只需要稍微魔改一下代码，拼接在一起就可以了 如果不会的话请看这两篇模板题解： 树上莫队 带修莫队 一些细节： 带修莫队在更新修改操作的时候，不再是判断修改的那个点是不是在当前区间$[l,r]$内，而是直接判断那个点现在是否是选中的状态，即代码中的$vis[x]$ 分块大小取$n^{\\frac{2}{3}}$!!! 要开long long 代码代码比较长 但是其实并不太难写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;typedef long long ll;template&lt;typename T&gt;inline void read(T &amp;num) &#123; T x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); num = x * f;&#125;template&lt;typename T&gt;inline void write(T x) &#123; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int n, m, Q, block, c[N], tmp[N];int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int fa[N], son[N], rnk[N&lt;&lt;1], top[N], dfn[N], out[N], tme, siz[N], d[N];ll val[N], w[N], ans[N];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void dfs(int x) &#123; siz[x] = 1; dfn[x] = ++tme; rnk[tme] = x; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x]) continue; d[y] = d[x] + 1; fa[y] = x; dfs(y); siz[x] += siz[y]; if (!son[x] || siz[son[x]] &lt; siz[y]) son[x] = y; &#125; out[x] = ++tme; rnk[tme] = x;&#125;void dfs2(int x, int tp) &#123; top[x] = tp; if (son[x]) dfs2(son[x], tp); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x] || y == son[x]) continue; dfs2(y, y); &#125;&#125;inline int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) swap(x, y); x = fa[top[x]]; &#125; if (d[x] &gt; d[y]) swap(x, y); return x;&#125;struct query&#123; int l, r, t, lca, id; friend bool operator &lt; (query x, query y) &#123; if (x.l / block != y.l / block) return x.l &lt; y.l; else if (x.r / block != y.r / block) return x.r &lt; y.r; else return x.t &lt; y.t; &#125;&#125; q[N];struct modify&#123; int p, x, y;&#125; q2[N];int qcnt, mcnt, nowl, nowr, nowt, cnt[N];ll nowans;bool vis[N];inline void add(int col) &#123; nowans += val[col] * w[++cnt[col]];&#125;inline void del(int col) &#123; nowans -= val[col] * w[cnt[col]--];&#125;inline void calc(int x) &#123; if (!vis[x]) add(c[x]); else del(c[x]); vis[x] = !vis[x];&#125; inline void updtime(int t, int v) &#123; if (v == 1) &#123; if (vis[q2[t].p]) &#123; del(q2[t].x); add(q2[t].y); &#125; c[q2[t].p] = q2[t].y; &#125; else &#123; if (vis[q2[t].p]) &#123; del(q2[t].y); add(q2[t].x); &#125; c[q2[t].p] = q2[t].x; &#125;&#125;int main() &#123; read(n); read(m); read(Q); block = pow(n, 0.6666666667); for (int i = 1; i &lt;= m; i++) read(val[i]); for (int i = 1; i &lt;= n; i++) read(w[i]); for (int i = 1, u, v; i &lt; n; i++) &#123; read(u); read(v); addedge(u, v); &#125; for (int i = 1; i &lt;= n; i++) &#123; read(c[i]); tmp[i] = c[i]; &#125; dfs(1); dfs2(1, 1); for (int i = 1, tp, u, v; i &lt;= Q; i++) &#123; read(tp); read(u); read(v); if (!tp) &#123; q2[++mcnt] = &#123;u, tmp[u], v&#125;; tmp[u] = v; &#125; else &#123; if (dfn[u] &gt; dfn[v]) swap(u, v); int lca = LCA(u, v); if (lca == u) &#123; q[++qcnt] = &#123;dfn[u], dfn[v], mcnt, 0, qcnt&#125;; &#125; else &#123; q[++qcnt] = &#123;out[u], dfn[v], mcnt, lca, qcnt&#125;; &#125; &#125; &#125; nowl = 1, nowr = 0, nowt = 0; sort(q + 1, q + qcnt + 1); for (int i = 1; i &lt;= qcnt; i++) &#123; while (nowl &lt; q[i].l) calc(rnk[nowl++]); while (nowl &gt; q[i].l) calc(rnk[--nowl]); while (nowr &lt; q[i].r) calc(rnk[++nowr]); while (nowr &gt; q[i].r) calc(rnk[nowr--]); if (q[i].lca) calc(q[i].lca); while (nowt &lt; q[i].t) updtime(++nowt, 1); while (nowt &gt; q[i].t) updtime(nowt--, -1); ans[q[i].id] = nowans; if (q[i].lca) calc(q[i].lca); &#125; for (int i = 1; i &lt;= qcnt; i++) &#123; write(ans[i]); puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"Count on a tree II [SP10707]","slug":"Count on a tree II [SP10707]","date":"2020-04-30T13:19:15.000Z","updated":"2020-10-08T12:16:07.960Z","comments":true,"path":"post/f8579b9b.html/","link":"","permalink":"http://akdream.tk/post/f8579b9b.html/","excerpt":"","text":"【题目描述】 给定一个$n$个节点的树，每个节点表示一个整数，问$u$到$v$的路径上有多少个不同的整数。 【输入格式】 第一行有两个整数$n$和$m$（$n＝40000，m＝100000$）。 第二行有$n$个整数。第$i$个整数表示第$i$个节点表示的整数。 在接下来的$n-1$行中，每行包含两个整数$u,v$，描述一条边（$u,v$）。 在接下来的$m$行中，每一行包含两个整数$u,v$，询问$u$到$v$的路径上有多少个不同的整数。 【输出格式】 对于每个询问，输出结果。 题解树上莫队的模板题 原先莫队是在线性结构上进行的，现在我们要把它挪到树上 很容易想到要用dfs序之类的东西来处理 但是这里dfs序并不方便处理 因为树上一条路径上的点的dfs序不是连续一段的 我们考虑一下这棵树的欧拉序 dfs序是节点第一次被经过的时间戳，也就是每个点第一次进入搜索栈的时间戳而欧拉序则是每个节点出栈时还要被算一次(也就是dfs回溯时再算一次) 举个例子 盗一张洛谷题解的图 这棵树 dfs序可以是1,2,4,6,7,5,3 则欧拉序是1,2,4,6,6,7,7,5,5,4,2,3,3,1 我们把一个点入栈的时间戳记为$dfn[x]$，出栈时间戳记为$out[x]$(个人习惯，当然也有人是用$st[x]$和$ed[x]$) 现在树上的一条路径能不能被表示成一段连续区间了呢？ 假设询问的是$x,y$间的路径 第一种情况$x$是$y$的直接祖先(反过来也一样，直接把$x,y$交换一下) 假设问的是$2\\rightarrow 7$的路径吧 我们看一下$dfn[2]\\sim dfn[7]$之间的欧拉序是什么样的： 是2,4,6,6,7 但是$6$并不在$2\\rightarrow 7$的路径里 注意到只有$6$出现了两次 出现了两次就说明先加上了它的贡献 然后又删掉了 所以有贡献的实际上只有$2,4,7$ 实现的时候可以记录一下当前区间里某个数$i$有没有出现 如果出现了就删掉 反之就加上 第二种情况$x$不是$y$的直接祖先假设是$7\\rightarrow 3$，看一下$out[7]\\sim dfn[3]$之间的欧拉序： 7,5,5,4,2,3 $5$出现了两次 所以实际上没产生贡献 但是路径上应该还有一个节点$1$啊 这里我们需要判断一下 如果是第二种情况，即$x,y$的最近公共祖先不是$x$那么统计答案是要额外加上lca的贡献 到此就和普通莫队没有差别了 分块大小取$\\sqrt{n}$(其实严格来说是$\\sqrt{2n}$，不过差别不大) p.s. 怎么保证一定是$x$是$y$的祖先 而不是$y$是$x$的祖先？如果$dfn[x]&gt;dfn[y]$那么$swap(x,y)$即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;#define N 200005using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;inline void write(int x) &#123; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int n, m, a[N], srt[N], block;int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int ans[N], nowl, nowr, nowans, cnt[N];bool vis[N];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;int fa[N], son[N], rnk[N], top[N], dfn[N], out[N], tme, siz[N], d[N];void dfs(int x) &#123; siz[x] = 1; dfn[x] = ++tme; rnk[tme] = x; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x]) continue; d[y] = d[x] + 1; fa[y] = x; dfs(y); siz[x] += siz[y]; if (!son[x] || siz[son[x]] &lt; siz[y]) son[x] = y; &#125; out[x] = ++tme; rnk[tme] = x;&#125;void dfs2(int x, int tp) &#123; top[x] = tp; if (son[x]) dfs2(son[x], tp); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x] || y == son[x]) continue; dfs2(y, y); &#125;&#125;inline int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) swap(x, y); x = fa[top[x]]; &#125; if (d[x] &gt; d[y]) swap(x, y); return x;&#125;struct query&#123; int l, r, lca, id; inline friend bool operator &lt; (query x, query y) &#123; if (x.l / block != y.l / block) return x.l &lt; y.l; else return x.r &lt; y.r; &#125;&#125; q[N];inline void del(int c) &#123; if (--cnt[c] == 0) nowans--;&#125;inline void add(int c) &#123; if (++cnt[c] == 1) nowans++;&#125;inline void calc(int x) &#123; if (vis[x]) &#123; del(a[x]); vis[x] = 0; &#125; else &#123; add(a[x]); vis[x] = 1; &#125;&#125;int main() &#123; n = read(), m = read(); block = sqrt(n); for (int i = 1; i &lt;= n; i++) a[i] = srt[i] = read(); sort(srt + 1, srt + n + 1); int mx = unique(srt + 1, srt + n + 1) - srt - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(srt + 1, srt + mx + 1, a[i]) - srt; for (int i = 1, u, v; i &lt; n; i++) &#123; u = read(), v = read(); addedge(u, v); &#125; dfs(1); dfs2(1, 1); for (int i = 1, u, v; i &lt;= m; i++) &#123; u = read(), v = read(); if (dfn[u] &gt; dfn[v]) swap(u, v); int lca = LCA(u, v); if (lca == u) &#123; q[i] = &#123;dfn[u], dfn[v], 0, i&#125;; &#125; else &#123; q[i] = &#123;out[u], dfn[v], lca, i&#125;; &#125; &#125; sort(q + 1, q + m + 1); nowl = 1, nowr = 0; for (int i = 1; i &lt;= m; i++) &#123; while (nowl &lt; q[i].l) calc(rnk[nowl++]); while (nowl &gt; q[i].l) calc(rnk[--nowl]); while (nowr &lt; q[i].r) calc(rnk[++nowr]); while (nowr &gt; q[i].r) calc(rnk[nowr--]); if (q[i].lca) calc(q[i].lca); ans[q[i].id] = nowans; if (q[i].lca) calc(q[i].lca); &#125; for (int i = 1; i &lt;= m; i++) &#123; write(ans[i]); puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"数颜色[国家集训队2011]","slug":"数颜色[国家集训队2011]","date":"2020-04-30T10:28:53.000Z","updated":"2020-10-08T12:16:08.473Z","comments":true,"path":"post/5e9bcfe7.html/","link":"","permalink":"http://akdream.tk/post/5e9bcfe7.html/","excerpt":"","text":"【题目描述】 墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1.Q L R代表询问你从第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。 2.R P Col 把第$P$支画笔替换为颜色$Col$。为了满足墨墨的要求，你知道你需要干什么了吗？ 【输入格式】 第$1$行两个整数$N,M$，分别代表初始画笔的数量以及墨墨会做的事情的个数。 第$2$行$N$个整数，分别代表初始画笔排中第$i$支画笔的颜色。 第$3$行到第$2+M$行，每行分别代表墨墨会做的一件事情，格式见题干部分。 【输出格式】 对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。 题解来补一道带修莫队的模板题 什么情况下用带修莫队？ 当询问是询问一段区间，并且修改操作可以$O(1)$进行并更新答案时 带修莫队相当于是在基本莫队上加了个时间维度$t$，表示这次询问之前一共有$t$次修改。 在转移询问区间的时候，$t$也一样从上一个询问的$t$向下一个询问的$t$进行/撤回修改。 带修莫队的块大小就不是取$\\sqrt{n}$了，而是取$n^{\\frac{2}{3}}$，也就是$\\sqrt[3]{n^2}$ 我们把每个询问表示成这种形式${l,r,t}$，其中$l,r$是询问区间，$t$表示这次询问之前一共有$t$次修改。 然后按照先比$l$再比$r$最后比$t$的顺序来进行排序(当然是比较所在的块) 然后暴力转移修改 可以证明这样做的时间复杂度约为$O(n^{\\frac{5}{3}})$，跑$50000\\sim 100000$应该问题不大 对$l,r$的修改就和普通莫队一样，$t$的修改则有些不同： 如果某次要进行/撤销的修改操作对当前区间$[l,r]$有影响，就需要更新答案，否则只需要改动原数组的元素 总之也很容易写就是了 这题具体怎么写就不用多说了吧。。。 吐槽一下 洛谷上面这题太卡常了 2s时限卡了半天勉强过了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;inline void write(int x) &#123; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int n, m, a[140005], b[140005], sz, tot, tme, nowans, ans[140005], cnt[1000005];int nowl, nowr, nowt;char s[5];struct query&#123; int l, r, t, id; friend bool operator &lt; (query x, query y) &#123; if (x.l / sz == y.l / sz) &#123; if (x.r / sz == y.r / sz) return x.t &lt; y.t; else return x.r / sz &lt; y.r / sz; &#125; else return x.l / sz &lt; y.l / sz; &#125;&#125; q[140005];struct modify&#123; int p, x, y;&#125; q2[140005];inline void upd(int x, int v) &#123; cnt[x] += v; if (cnt[x] == 0 &amp;&amp; v == -1) nowans--; if (cnt[x] == 1 &amp;&amp; v == 1) nowans++;&#125;inline void updtime(int t, int v) &#123; if (v == 1) &#123; if (nowl &lt;= q2[t].p &amp;&amp; q2[t].p &lt;= nowr) &#123; upd(q2[t].x, -1); upd(q2[t].y, 1); &#125; a[q2[t].p] = q2[t].y; &#125; else &#123; if (nowl &lt;= q2[t].p &amp;&amp; q2[t].p &lt;= nowr) &#123; upd(q2[t].y, -1); upd(q2[t].x, 1); &#125; a[q2[t].p] = q2[t].x; &#125;&#125;int main() &#123; n = read(), m = read(); sz = pow(n, 2.0 / 3); for (int i = 1; i &lt;= n; i++) &#123; a[i] = b[i] = read(); &#125; for (int i = 1, x, y; i &lt;= m; i++) &#123; scanf(\"%s\", s); x = read(), y = read(); if (s[0] == 'Q') &#123; q[++tot] = &#123;x, y, tme, tot&#125;; &#125; else &#123; q2[++tme] = &#123;x, b[x], y&#125;; b[x] = y; &#125; &#125; sort(q + 1, q + tot + 1); nowl = 1, nowr = nowt = 0; for (int i = 1; i &lt;= tot; i++) &#123; while (nowt &lt; q[i].t) updtime(++nowt, 1); while (nowt &gt; q[i].t) updtime(nowt--, -1); while (nowl &lt; q[i].l) upd(a[nowl++], -1); while (nowl &gt; q[i].l) upd(a[--nowl], 1); while (nowr &lt; q[i].r) upd(a[++nowr], 1); while (nowr &gt; q[i].r) upd(a[nowr--], -1); ans[q[i].id] = nowans; &#125; for (int i = 1; i &lt;= tot; i++) &#123; write(ans[i]); puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"魔法森林[NOI2014]","slug":"魔法森林[NOI2014]","date":"2020-04-26T12:12:53.000Z","updated":"2020-04-26T12:13:42.000Z","comments":true,"path":"post/5684a8d5.html/","link":"","permalink":"http://akdream.tk/post/5684a8d5.html/","excerpt":"","text":"【题目描述】 题目描述又臭又长 简单来说 有一个有$n$个点，$m$条边的无向图，每条边有两个权值$a,b$，从点$u$走到任意一个点$v$的代价是途经的边中最大的$a$加上最大的$b$ 求从点$1$到点$n$的最小代价 【输入格式】 rt，给你一张图 【输出格式】 输出最小代价。如果无法到达，输出-1。 题解如果边权只有一个，那么显然就是建出最小生成树 但是这里有两个 我们可以先以$a$为关键字给所有边从小到大排序 然后依次把每条边加入 这里就和最小生成树有些异曲同工之妙相似 假设加入的这条边是$(u,v)$，如果$u,v$还未联通就直接给它连上 如果已经联通了 我们就检查一下现在的$u\\rightarrow v$这条链上面$b$最大的一条边 如果那条边的$b$比$(u,v)$的$b$大 那就把那条边割掉 把$(u,v)$这条边给连上 这个就可以用LCT来维护 求$b$最大的边只需要在splay上维护一下 然后split(u,v)就能找到 每次加完边后 如果$1$与$n$联通 就更新一下答案 $1\\rightarrow n$路径上最大的$b$已知 那最大的$a$呢？ 最大的$a$直接用这次加入的边的$a$即可 因为如果这次加入的边不在$1\\rightarrow n$的路径上 那么在这条路径第一次在树上出现时就应该已经用正确的$a$更新过了 复杂度$O(n\\log n)$ 这道题可以不用findroot来判联通。。。但是懒得写了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#define N 200005 using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;struct edge&#123; int u, v, a, b; friend bool operator &lt; (edge x, edge y) &#123; return x.a &lt; y.a; &#125;&#125; e[N];int ch[N][2], fa[N], mx[N], val[N], tag[N];#define lson ch[x][0]#define rson ch[x][1]inline void pushup(int x) &#123; mx[x] = x; if (val[mx[lson]] &gt; val[mx[x]]) mx[x] = mx[lson]; if (val[mx[rson]] &gt; val[mx[x]]) mx[x] = mx[rson];&#125;inline void rev(int x) &#123; swap(lson, rson); tag[x] ^= 1;&#125;inline void pushdown(int x) &#123; if (tag[x]) &#123; if (lson) rev(lson); if (rson) rev(rson); tag[x] = 0; &#125;&#125;inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;&#125;inline void rotate(int x) &#123; int y = fa[x], z = fa[y], k = (ch[y][1] == x); if (!isroot(y)) ch[z][ch[z][1]==y] = x; fa[x] = z; ch[y][k] = ch[x][k^1]; fa[ch[x][k^1]] = y; ch[x][k^1] = y; fa[y] = x; pushup(y); pushup(x);&#125;int q[N], top;inline void splay(int x) &#123; q[top=1] = x; for (int i = x; !isroot(i); i = fa[i]) q[++top] = fa[i]; while (top) pushdown(q[top--]); while (!isroot(x)) &#123; int y = fa[x], z = fa[y]; if (!isroot(y)) &#123; ((ch[z][0] == y) ^ (ch[y][0] == x)) ? rotate(x) : rotate(y); &#125; rotate(x); &#125;&#125;inline void access(int x) &#123; for (int i = 0; x; i = x, x = fa[x]) &#123; splay(x), ch[x][1] = i, pushup(x); &#125;&#125; inline void makeroot(int x) &#123; access(x), splay(x), rev(x);&#125;inline void link(int x, int y) &#123; makeroot(x); fa[x] = y;&#125; inline void split(int x, int y) &#123; makeroot(x), access(y), splay(y);&#125;inline int findroot(int x) &#123; access(x), splay(x); while (lson) pushdown(x), x = lson; splay(x); return x;&#125; inline void cut(int x, int y) &#123; split(x, y); if (ch[y][0] == x &amp;&amp; !ch[x][1]) &#123; ch[y][0] = fa[x] = 0; &#125;&#125;int n, m, ans;int main() &#123; n = read(), m = read(); ans = 0x7fffffff; for (int i = 1; i &lt;= m; i++) &#123; e[i].u = read(), e[i].v = read(); e[i].a = read(), e[i].b = read(); &#125; sort(e + 1, e + m + 1); for (int i = 1; i &lt;= m; i++) &#123; val[n + i] = e[i].b; &#125; for (int i = 1; i &lt;= m; i++) &#123; bool lk = 1; if (findroot(e[i].u) == findroot(e[i].v)) &#123; split(e[i].u, e[i].v); int mxnow = mx[e[i].v]; if (val[mxnow] &gt; e[i].b) &#123; cut(e[mxnow-n].u, mxnow); cut(e[mxnow-n].v, mxnow); &#125; else lk = 0; &#125; if (lk) &#123; link(e[i].u, i + n); link(e[i].v, i + n); &#125; if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, e[i].a + val[mx[n]]); &#125; &#125; printf(\"%d\\n\", ans == 0x7fffffff ? -1 : ans); return 0;&#125;","categories":[],"tags":[{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"}]},{"title":"力[ZJOI2014]","slug":"力[ZJOI2014]","date":"2020-04-26T10:47:39.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/e8568f51.html/","link":"","permalink":"http://akdream.tk/post/e8568f51.html/","excerpt":"","text":"【题目描述】 给出$n$个数$q_1,q_2, \\dots q_n$，定义 $F_j=\\sum\\limits_{i = 1}^{j - 1} \\frac{q_i \\times q_j}{(i - j)^2}-\\sum\\limits_{i = j + 1}^{n} \\frac{q_i \\times q_j}{(i - j)^2}$ $E_i=\\frac{F_i}{q_i}$ 对$1 \\leq i \\leq n$，求$E_i$的值。 【输入格式】 第一行输入一个整数$n$。 以下$n$行，每行有一个实数。第$i+1$行的数代表$q_i$。 【输出格式】 输出$n$行每行一个实数，第$i$行的数字代表$E_i$。 当你的输出与标准答案相差不超过$10^{-2}$即为正确。 题解$E_i=\\frac{F_i}{q_i}$上下都有$q_i$直接扔掉即可 $E_i=\\sum\\limits_{j = 1}^{i - 1} \\frac{q_j}{(i - j)^2}-\\sum\\limits_{j = i + 1}^{n} \\frac{q_j}{(i - j)^2}$ $E_i=\\sum\\limits_{j = 1}^{i} \\frac{q_j}{(i - j)^2}-\\sum\\limits_{j = i}^{n} \\frac{q_j}{(i - j)^2}$ 令$f[j]=q[j],~g[j]=\\frac{1}{j^2}$，特殊地，$f[0]=g[0]=0$ $E_i=\\sum\\limits_{j = 0}^{i} f[j]*g[i-j]-\\sum\\limits_{j = i}^{n} f[j]*g[j-i]$ $E_i=\\sum\\limits_{j = 0}^{i} f[j]*g[i-j]-\\sum\\limits_{j = 0}^{n-i} f[j+i]*g[j]$ 令$h[j]=f[n-j]$， $E_i=\\sum\\limits_{j = 0}^{i} f[j]*g[i-j]-\\sum\\limits_{j = 0}^{n-i} h[(n-i)-j]*g[j]$ 这样两个$\\sum$都是卷积形式了 FFT乱搞即可 注意细节和精度。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const double pi = acos(-1.0);int n, m, lim, l, rev[1000005];struct comp &#123; double x,y; comp(double xx = 0, double yy = 0): x(xx), y(yy) &#123;&#125;&#125; a[1000005], b[1000005], cc[1000005];inline comp operator + (comp p, comp q) &#123; return comp(p.x+q.x , p.y+q.y); &#125;inline comp operator - (comp p, comp q) &#123; return comp(p.x-q.x , p.y-q.y); &#125;inline comp operator * (comp p, comp q) &#123; return comp(p.x*q.x-p.y*q.y , p.x*q.y+p.y*q.x); &#125;void FFT(comp *c, int tp) &#123; for (int i = 0; i &lt; lim; i++) &#123; if (i &lt; rev[i]) swap(c[i], c[rev[i]]); &#125; for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; comp wn = comp(cos(pi / mid), sin(pi / mid) * tp); for (int r = mid&lt;&lt;1, j = 0; j &lt; lim; j += r) &#123; comp w = comp(1, 0); for (int k = 0; k &lt; mid; k++, w = w * wn) &#123; comp x = c[j+k], y = w * c[j+k+mid]; c[j+k] = x + y; c[j+k+mid] = x - y; &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lf\", &amp;a[i].x); cc[n-i].x = a[i].x; b[i].x = (double)(1.0 / i / i); &#125; lim = 1; while (lim &lt;= n + n) &#123; lim &lt;&lt;= 1; l++; &#125; for (int i = 0; i &lt; lim; i++) &#123; rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); &#125; FFT(a, 1); FFT(b, 1); FFT(cc, 1); for (int i = 0; i &lt; lim; i++) &#123; a[i] = a[i] * b[i]; cc[i] = cc[i] * b[i]; &#125; FFT(a, -1); FFT(cc, -1); for (int i = 0; i &lt; lim; i++) &#123; a[i].x /= lim; cc[i].x /= lim; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf(\"%.3lf\\n\", a[i].x - cc[n-i].x); &#125; return 0;&#125;","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://akdream.tk/tags/FFT/"}]},{"title":"Query on a tree VI [SP16549]","slug":"Query on a tree VI [SP16549]","date":"2020-04-26T10:46:10.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/7c1f5344.html/","link":"","permalink":"http://akdream.tk/post/7c1f5344.html/","excerpt":"","text":"【题目描述】 给你一棵$n$个点的树，编号$1\\sim n$。每个点可以是黑色，可以是白色。初始时所有点都是黑色。下面有两种操作： 0 u：询问有多少个节点$v$满足路径$u$到$v$上所有节点（包括$u$）都拥有相同的颜色。 1 u：翻转$u$的颜色。 【输入/输出格式】 不关心 $n,m\\le 10^5$ 最近不知道为什么一直在敲数据结构。。。感觉要换换题型了 题解随便找个点当根吧 如果有两个点$u,v$满足查询操作那个条件 我们就说$u,v$联通 注意到我们只需要维护一个点子树里有多少点和它联通 对于查询操作只需要找到深度最浅的和查询点联通的祖先就可以了 为了方便操作 我们让$cnt[x][0]$表示如果$x$是黑点 那么子树里有多少点和它联通$cnt[x][1]$表示白点 那么对于修改操作 我们假设是把$x$从黑改成白 我们只需要找到那个深度最浅的和$x$联通的祖先$p$然后把$fa[p]\\sim fa[x]$这条链上所有点的$cnt[i][0]$减掉$cnt[x][0]$然后更改$x$的颜色再找到此时深度最浅的和$x$联通的祖先$p_2$(注意$x$的颜色变了 所以和祖先的联通也已经变了) 把$fa[p_2]\\sim fa[x]$这条链上所有点的$cnt[i][1]$加上$cnt[x][1]$ 因为$x$变白点之后子树里的黑点就不和外面联通了 而子树里的白点就会和外面联通 (实际上你会发现$p$和$p_2$中有一个肯定就是$x$因为$x$的父亲要么是白点要么是黑点 但是无所谓) 白改黑同理 区间修改树剖就可以了 问题在于如何快速找到深度最浅的和$x$联通的祖先？ 还是树剖 线段树再维护一下区间内有多少个黑点白点 那么从$fa[x]$开始一直往上跳重链 如果整段都和$x$颜色一样就继续跳 否则一定可以线段树二分找到第一个和$x$颜色不一样的点 但是这里写起来就会比较麻烦。。。这题估计还是LCT简单点 时间复杂度$O(n\\log^2 n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;int n, m, col[N];int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], sz;int dfn[N], rnk[N], tme, d[N], siz[N], top[N], son[N], fa[N];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;void dfs(int x) &#123; siz[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x]) continue; d[y] = d[x] + 1; fa[y] = x; dfs(y); siz[x] += siz[y]; if (!son[x] || siz[son[x]] &lt; siz[y]) son[x] = y; &#125;&#125;void dfs2(int x, int _top) &#123; top[x] = _top; dfn[x] = ++tme; rnk[tme] = x; if (son[x]) dfs2(son[x], _top); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x] || y == son[x]) continue; dfs2(y, y); &#125;&#125;struct segtree&#123; int l, r, cnt[2], tag[2], sum[2]; //0:black 1:white &#125; tr[N&lt;&lt;2];#define lson ind&lt;&lt;1#define rson ind&lt;&lt;1|1inline void pushup(int ind) &#123; tr[ind].cnt[0] = tr[lson].cnt[0] + tr[rson].cnt[0]; tr[ind].cnt[1] = tr[lson].cnt[1] + tr[rson].cnt[1]; tr[ind].sum[0] = tr[lson].sum[0] + tr[rson].sum[0]; tr[ind].sum[1] = tr[lson].sum[1] + tr[rson].sum[1];&#125;void build(int ind, int l, int r) &#123; tr[ind].l = l; tr[ind].r = r; tr[ind].tag[0] = tr[ind].tag[1] = 0; if (l == r) &#123; tr[ind].cnt[0] = siz[rnk[l]]; tr[ind].cnt[1] = 1; tr[ind].sum[0] = 1; tr[ind].sum[1] = 0; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); pushup(ind);&#125;void pushdown(int ind) &#123; if (tr[ind].tag[0]) &#123; int v = tr[ind].tag[0]; tr[ind].tag[0] = 0; tr[lson].cnt[0] += v; tr[lson].tag[0] += v; tr[rson].cnt[0] += v; tr[rson].tag[0] += v; &#125; if (tr[ind].tag[1]) &#123; int v = tr[ind].tag[1]; tr[ind].tag[1] = 0; tr[lson].cnt[1] += v; tr[lson].tag[1] += v; tr[rson].cnt[1] += v; tr[rson].tag[1] += v; &#125;&#125;void update(int ind, int x, int y, int v, int c) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].cnt[c] += (r - l + 1) * v; tr[ind].tag[c] += v; return; &#125; pushdown(ind); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(lson, x, y, v, c); if (mid &lt; y) update(rson, x, y, v, c); pushup(ind);&#125;int query(int ind, int pos, int c) &#123; int l = tr[ind].l, r = tr[ind].r; if (l == r) return tr[ind].cnt[c]; pushdown(ind); int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return query(lson, pos, c); else return query(rson, pos, c);&#125;void change(int ind, int pos, int c) &#123; int l = tr[ind].l, r = tr[ind].r; if (l == r) &#123; tr[ind].sum[c^1] = 0; tr[ind].sum[c] = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) change(lson, pos, c); else change(rson, pos, c); pushup(ind);&#125;int find(int ind, int x, int y, int c) &#123; int l = tr[ind].l, r = tr[ind].r; if (l == r) &#123; if (tr[ind].sum[c]) return l; else return 0; &#125; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (!tr[ind].sum[c]) return 0; &#125; int mid = (l + r) &gt;&gt; 1; if (mid &gt;= y) return find(lson, x, y, c); if (x &gt; mid) return find(rson, x, y, c); int ret = find(rson, x, y, c); if (!ret) return find(lson, x, y, c); else return ret;&#125;void Update(int x) &#123; int c = col[x], tmp[2] = &#123;query(1, dfn[x], 0), query(1, dfn[x], 1)&#125;; col[x] ^= 1; int xx = fa[x]; while (xx) &#123; //边找边修改 int lst = find(1, dfn[top[xx]], dfn[xx], c^1); if (lst) &#123; update(1, lst, dfn[xx], -tmp[c], c); break; &#125; else &#123; update(1, dfn[top[xx]], dfn[xx], -tmp[c], c); xx = fa[top[xx]]; &#125; &#125; xx = fa[x]; while (xx) &#123; int lst = find(1, dfn[top[xx]], dfn[xx], c); if (lst) &#123; update(1, lst, dfn[xx], tmp[c^1], c^1); break; &#125; else &#123; update(1, dfn[top[xx]], dfn[xx], tmp[c^1], c^1); xx = fa[top[xx]]; &#125; &#125; change(1, dfn[x], col[x]);&#125;int Query(int x) &#123; int c = col[x], xx = fa[x], lstson = x; while (xx) &#123; int lst = find(1, dfn[top[xx]], dfn[xx], c^1); if (lst) &#123; if (lst == dfn[xx]) &#123; return query(1, dfn[lstson], c); &#125; else &#123; return query(1, lst + 1, c); &#125; &#125; lstson = top[xx]; xx = fa[top[xx]]; &#125; return query(1, dfn[1], c); &#125;int main() &#123; n = read(); for (int i = 1, u, v; i &lt; n; i++) &#123; u = read(), v = read(); addedge(u, v); &#125; dfs(1); dfs2(1, 1); build(1, 1, n); m = read(); for (int i = 1, tp, x; i &lt;= m; i++) &#123; tp = read(), x = read(); if (!tp) &#123; printf(\"%d\\n\", Query(x)); &#125; else &#123; Update(x); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://akdream.tk/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"A simple simulation problem [HDU4973]","slug":"A simple simulation problem [HDU4973]","date":"2020-04-26T10:44:52.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/9dd4bb73.html/","link":"","permalink":"http://akdream.tk/post/9dd4bb73.html/","excerpt":"","text":"【题目描述】翻译：初始时按顺序排着一排细胞 第$i$个的种类是$i$ 两种操作 第一种是把当前的第$l\\sim r$个细胞原地翻倍第二种是查询当前第$l\\sim r$个细胞中 数量最多的同种细胞有多少个 $n\\le 5*10^4$，任何时候细胞总数不超过$5*10^{12}$ 举个例子 原来的细胞序列是${1,2,3,3,4,5}$把$[2,5]$翻倍 得到${1,2,2,3,3,3,3,4,4,5}$ 题解大概1min就想到正解了QAQ(可能是因为这个是线段树专题 所以明示要用线段树) 但是调了1h才AC 非常显然 不管怎么超级加倍这个细胞序列肯定都是一个不降的序列 同种细胞全部都在连续的一段里面 那我们用线段树维护一下每种细胞有多少个 然后不管是修改还是查询 都先在线段树上二分找到第$l$个及第$r$个位置是什么细胞 不妨设第$l$个是$x$，第$r$个是$y$ 然后我们还要查出来$[l,r]$中有多少个$x$多少个$y$这个其实在线段树二分的时候就可以顺便查到了 我实现的比较毒瘤 用了个pair。。。 那么种类为$x+1\\sim y-1$的那些细胞肯定全部都被包含在$[l,r]$之间了 对于修改操作直接区间给乘个$2$就好 查询也就是查一下区间最大值 然后把$x,y$单独处理一下 修改操作的话就现在$[l,r]$区间里有多少个$x$(我们刚才已经求过了)就给$x$加上多少 查询就比一下大小。。。 完事啦 时间复杂度$O(n \\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pii;inline ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f; &#125;ll ttt, n, m;char s[5];struct segtree&#123; ll l, r, mx, sum, tag;&#125; tr[200005];void build(ll ind, ll l, ll r) &#123; tr[ind].l = l; tr[ind].r = r; tr[ind].tag = 1; if (l == r) &#123; tr[ind].mx = tr[ind].sum = 1; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(ind&lt;&lt;1, l, mid); build(ind&lt;&lt;1|1, mid+1, r); tr[ind].mx = max(tr[ind&lt;&lt;1].mx, tr[ind&lt;&lt;1|1].mx); tr[ind].sum = tr[ind&lt;&lt;1].sum + tr[ind&lt;&lt;1|1].sum;&#125;inline void pushdown(ll ind) &#123; ll v = tr[ind].tag; tr[ind].tag = 1; tr[ind&lt;&lt;1].tag *= v; tr[ind&lt;&lt;1].mx *= v; tr[ind&lt;&lt;1].sum *= v; tr[ind&lt;&lt;1|1].tag *= v; tr[ind&lt;&lt;1|1].mx *= v; tr[ind&lt;&lt;1|1].sum *= v;&#125;void update(ll ind, ll pos, ll v) &#123; ll l = tr[ind].l, r = tr[ind].r; if (l == r) &#123; tr[ind].mx += v; tr[ind].sum += v; return; &#125; pushdown(ind); ll mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(ind&lt;&lt;1, pos, v); else update(ind&lt;&lt;1|1, pos, v); tr[ind].mx = max(tr[ind&lt;&lt;1].mx, tr[ind&lt;&lt;1|1].mx); tr[ind].sum = tr[ind&lt;&lt;1].sum + tr[ind&lt;&lt;1|1].sum;&#125;void update2(ll ind, ll x, ll y, ll v) &#123; if (x &gt; y) return; ll l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].tag *= v; tr[ind].mx *= v; tr[ind].sum *= v; return; &#125; pushdown(ind); ll mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update2(ind&lt;&lt;1, x, y, v); if (mid &lt; y) update2(ind&lt;&lt;1|1, x, y, v); tr[ind].mx = max(tr[ind&lt;&lt;1].mx, tr[ind&lt;&lt;1|1].mx); tr[ind].sum = tr[ind&lt;&lt;1].sum + tr[ind&lt;&lt;1|1].sum;&#125;pii find(ll ind, ll k, ll tp) &#123; ll l = tr[ind].l, r = tr[ind].r; if (l == r) &#123; if (!tp) return make_pair(l, tr[ind].sum - k + 1); else return make_pair(l, k); &#125; pushdown(ind); if (k &lt;= tr[ind&lt;&lt;1].sum) return find(ind&lt;&lt;1, k, tp); else return find(ind&lt;&lt;1|1, k - tr[ind&lt;&lt;1].sum, tp);&#125;ll query(ll ind, ll x, ll y) &#123; if (x &gt; y) return 0ll; ll l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return tr[ind].mx; &#125; pushdown(ind); ll mid = (l + r) &gt;&gt; 1, ret = 0; if (x &lt;= mid) ret = max(ret, query(ind&lt;&lt;1, x, y)); if (mid &lt; y) ret = max(ret, query(ind&lt;&lt;1|1, x, y)); return ret;&#125;int main() &#123; ttt = read(); for (ll kkk = 1; kkk &lt;= ttt; kkk++) &#123; printf(\"Case #%lld:\\n\", kkk); n = read(); m = read(); build(1, 1, n); for (ll i = 1, x, y; i &lt;= m; i++) &#123; scanf(\"%s\", s); x = read(); y = read(); if (s[0] == 'Q') &#123; ll ans = 0; pii l = find(1, x, 0), r = find(1, y, 1); if (l.first == r.first) &#123; ans = y - x + 1; &#125; else &#123; ans = max(l.second, r.second); ans = max(ans, query(1, l.first+1, r.first-1)); &#125; printf(\"%lld\\n\", ans); &#125; else &#123; pii l = find(1, x, 0), r = find(1, y, 1); if (l.first == r.first) &#123; update(1, l.first, y - x + 1); &#125; else &#123; update(1, l.first, l.second); update(1, r.first, r.second); update2(1, l.first + 1, r.first - 1, 2); &#125; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"逃亡「GDOI2017」","slug":"逃亡「GDOI2017」","date":"2020-04-26T08:14:27.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/d1488e33.html/","link":"","permalink":"http://akdream.tk/post/d1488e33.html/","excerpt":"","text":"【题目描述】兔兔和蛋蛋是一对cp，她们的国家目前正发生战乱，所以她们正在决定是否一起逃离这个国家。 该国家有$n$个城市，城市之间的道路形成一棵有向树。只能从父节点城市走到子节点城市。$1$号城市是首都，从城市$1$可以到达所有城市。每个城市都有一支军队，编号为$i$的城市其军队的攻击力为$b_i$，如果城市$i$能到达城市$j$，且$b_i &gt; b_j$（城市 i 军队的攻击力大于城市 j 军队的攻击力），则城市$i$会向城市$j$发动$a_i$次战争。 兔兔和蛋蛋这对cp决定当战争发生次数之和多于$k$的时候一起逃离这个国家，但是他们现在不知道各个城市的攻击力$b_i$，只知道$0 \\leq b_i \\leq m$。她们想知道该国家发生战争次数恰好为$0, 1,\\dots, k$的方案数（两个方案不同当且仅当存在一个城市$i$，$b_i$的值不同），你能帮助她们吗？ 【输入格式】第一行三个整数$n,m,k$，意义如上所述。 第二行$n$个数$a_i$，意义如上所述。 第三行$n-1$个数，第$i$个数表示第$i + 1$个城市的父节点城市编号。 【输出格式】共$k + 1$行，第$i$行表示战争发生次数为$i-1$的方案数，答案可能很大，你只需要输出答案模$10^9 + 7$之后的值就可以了。 $0 &lt; n \\leq 14, k \\leq 20, 0 \\leq m \\leq 100000000, 0 \\leq a_i, b_i \\leq m$ 题解看到$n\\le 14$就八成是状压DP了 容易发现我们只关心$n$个点之间的大小关系，至于$m$的限制最后乘上组合数即可 所以我们可以考虑这样一种DP策略 开始时所有点都没有被赋值(指$b_i$) 然后我们按照值从小到大的顺序一个一个地给它们赋值 这样每次赋值的点都比之前赋了值的所有点要大(或等于) 这样的话就方便进行转移 我们设$g[i][S]$表示$S$为已赋值的点的集合 此时将$i$点赋值 会新产生多少战争 由于是按照从小到大的顺序赋值的 所以$b_i$肯定比$S$中所有点都大 所以$g[i][S]$就等于$S$中在$i$子树里的点的数目 乘$a_i$ 但是还存在一个问题 万一两个点的值一样怎么办？这个其实也不难解决 我们设$f[i][j][S]$表示已赋值的点有$i$个不同的值 有$j$场战争 已赋值的点集是$S$的方案数 最外层循环是$i$然后按照dfs序来枚举一个要赋值的点$x$我们打算把$x$赋值为$i$ 然后枚举加入$x$后有多少场战争以及一个包含$x$的集合$S$那么去掉$x$后就是$S_0=S-2^x$ 首先$b_x$可以比之前的所有点都大 即$f[i][j][S] += f[i-1][j-g[x][S_0]][S_0]$ 然后 也可能前面已经加入了值也是$i$的点 所以$f[i][j][S] += f[i][j-g[x][S_0]][S_0]$ 由于我们是按照dfs序枚举的 所以第二种情况中一定没有$x$子树中的点先被赋值成$i$所以这个转移是没有问题的 最后统计答案 发动$k$次战争的方案数就是$\\sum\\limits_{i=1}^{n} f[i][k][2^n-1] * C(m,i)$$C(m,i)$就是我们要从$m$个可选的值里取$i$个来用 时间复杂度$O(n^22^nk)$ 更新：忘记放代码了QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f; &#125;const ll mod = 1000000007;int n, m, mx;int head[20], pre[40], to[40], sz;int dfn[20], rnk[20], out[20], a[20], tme;int f[15][21][(1&lt;&lt;15)], g[20][(1&lt;&lt;15)]; ll fac[20], inv[20];//\"点x\"表示dfs序第x位的点 //f[i][j][k] 共有i个不同的b[x] 会发动j次战争 k为已经确定b[x]的点的状压 //g[i][k] k为已经确定b[x]的点的状压 确定b[i]会新增加多少战争void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;ll calc(int l, int r) &#123; ll ret = 1; for (int i = l; i &lt;= r; i++) ret = ret * i % mod; return ret;&#125;inline ll C(int _n, int _m) &#123; return calc(_n - _m + 1, _n) * inv[_m] % mod;&#125;inline ll fpow(ll x, ll t) &#123; ll ret = 1; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;void dfs(int x, int fa) &#123; //确定dfs序 dfn[x] = ++tme; rnk[tme] = x; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] != fa) dfs(to[i], x); &#125; out[x] = tme;&#125;int main() &#123; fac[0] = inv[0] = 1; for (int i = 1; i &lt;= 14; i++) fac[i] = fac[i-1] * i % mod; for (int i = 1; i &lt;= 14; i++) inv[i] = fpow(fac[i], mod - 2); n = read(); m = read()+1; mx = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 2; i &lt;= n; i++) &#123; addedge(read(), i); &#125; dfs(1, 0); for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int x = rnk[j]; if (!(i &amp; (1 &lt;&lt; (j-1)))) &#123; for (int k = dfn[x] + 1; k &lt;= out[x]; k++) &#123; if (i &amp; (1 &lt;&lt; (k-1))) g[j][i] += a[x]; &#125; &#125; &#125; &#125; f[0][0][0] = 1; for (int i = 1; i &lt;= min(n, m); i++) &#123; //枚举有i个不同的b[x]的取值 for (int x = 1; x &lt;= n; x++) &#123; //枚举要确定b[x]的值 for (int j = 0; j &lt;= mx; j++) &#123; //将会有j场战争 for (int k = (1 &lt;&lt; (x-1)); k &lt;= (1 &lt;&lt; n) - 1; k = ((k + 1) | (1 &lt;&lt; (x-1)))) &#123; //枚举一个包含j的状态压缩 int now = j - g[x][k-(1&lt;&lt;(x-1))]; //加入x前有now场战争 if (now &lt; 0) continue; f[i][j][k] = (f[i][j][k] + f[i-1][now][k-(1&lt;&lt;(x-1))]) % mod; f[i][j][k] = (f[i][j][k] + f[i][now][k-(1&lt;&lt;(x-1))]) % mod; &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= mx; i++) &#123; ll ans = 0; for (int j = 1; j &lt;= min(n, m); j++) &#123; ans = (ans + f[j][i][(1&lt;&lt;n)-1] * C(m, j) % mod) % mod; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://akdream.tk/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"三角形面积并「CQOI2005」","slug":"三角形面积并「CQOI2005」","date":"2020-04-13T12:12:40.000Z","updated":"2020-10-08T12:16:08.144Z","comments":true,"path":"post/587421bf.html/","link":"","permalink":"http://akdream.tk/post/587421bf.html/","excerpt":"","text":"【题目描述】给出$n$个三角形，求它们并的面积。 【输入格式】第一行为$n(n \\leq 100)$，即三角形的个数以下$n$行，每行$6$个整数$x_1, y_1, x_2, y_2, x_3, y_3$，代表三角形的顶点坐标。坐标均为不超过$10^6$ 【输出格式】输出并的面积$u$, 保留两位小数。 题解 我们把三角形的所有顶点和所有交点全部抠出来 然后过每一个点作一条平行于y轴的直线 容易发现 任意相邻两条直线之间的有效面积都是一个(也可能是多个)三角形或矩形的面积 所以 只要我们求出左边那条直线穿过三角形的长度$ld$和右边那条直线的$rd$，那么总面积就加上$\\frac{(ld+rd)*(x_r-x_l)}{2}$就好啦！ 怎么求？具体来说 就是对于每个三角形分别求出这条线$x=k$穿过它的范围$[a,b]$，然后区间求并即可 怎么求？对于每个三角形 算出这条线和它的三边有几个交点 如果是3个交点就说明这条线过它的一个顶点 如果2个就说明穿过了两条边 如果0个或1个就不用管这个三角形了 万一有一个三角形有一条边也平行于y轴 与某条直线产生了无数个交点呢？ 注意到答案保留两位小数就可以了 我们可以用一些奇技♂淫巧 把那种与y轴平行的三角形边稍稍倾斜一个小角度即可 对面积的影响微乎其微 至于求交点那些建议用计算几何算 避免被卡精度 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;inline int sgn(double x) &#123; if (fabs(x) &lt; eps) return 0; return (x &lt; 0) ? -1 : 1;&#125;struct point&#123; double x, y; point(double xx = 0.0, double yy = 0.0): x(xx), y(yy) &#123;&#125;&#125;;typedef point vec;struct edge&#123; point a, b; edge(point aa = point(), point bb = point()): a(aa), b(bb) &#123;&#125;&#125;;inline vec operator + (vec A, vec B) &#123; return vec(A.x + B.x, A.y + B.y);&#125;inline vec operator - (point A, point B) &#123; return vec(A.x - B.x, A.y - B.y);&#125;inline vec operator * (vec A, double p) &#123; return vec(A.x * p, A.y * p);&#125;inline vec operator / (vec A, double p) &#123; return vec(A.x / p, A.y / p);&#125;inline bool operator &lt; (const point A, const point B) &#123; return A.x &lt; B.x || (sgn(A.x - B.x) == 0 &amp;&amp; A.y &lt; B.y);&#125;inline double dot(vec A, vec B) &#123; return A.x * B.x + A.y * B.y;&#125;inline double cross(vec A, vec B) &#123; return A.x * B.y - A.y * B.x;&#125;inline point line_intersection(point P, point P2, point Q, point Q2) &#123; //求交点 vec v = P - P2, w = Q - Q2; vec u = P - Q; double t = cross(w, u) / cross(v, w); return P + v * t;&#125;inline bool GFXJ(point A, point B, point P, point Q) &#123; //规范相交 double c1 = cross(B - A, P - A), c2 = cross(B - A, Q - A); double c3 = cross(Q - P, A - P), c4 = cross(Q - P, B - P); if (sgn(cross(B - A, P - A)) == 0) return 0; return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(c3) * sgn(c4) &lt; 0;&#125;inline bool BGFXJ(point A, point B, point P, point Q) &#123; //不规范相交 double c1 = cross(B - A, P - A), c2 = cross(B - A, Q - A); double c3 = cross(Q - P, A - P), c4 = cross(Q - P, B - P); if (sgn(cross(B - A, P - A)) == 0) return 0; return sgn(c1) * sgn(c2) &lt;= 0 &amp;&amp; sgn(c3) * sgn(c4) &lt;= 0;&#125;int n, tot, ee;double ans;point p[100005];edge e[305];vector&lt;pair&lt;double, double&gt; &gt; sol;double solve(double x) &#123; sol.clear(); point pp = point(x, -2e6); point q = point(x, 2e6); for (int i = 1; i &lt;= ee; i += 3) &#123; if (BGFXJ(pp, q, e[i].a, e[i].b) + BGFXJ(pp, q, e[i+1].a, e[i+1].b) + BGFXJ(pp, q, e[i+2].a, e[i+2].b) &lt; 2) &#123; continue; &#125; pair&lt;double, double&gt; tmp; tmp.first = 2e6, tmp.second = -2e6; for (int j = 0; j &lt;= 2; j++) &#123; if (BGFXJ(pp, q, e[i+j].a, e[i+j].b)) &#123; double now = line_intersection(pp, q, e[i+j].a, e[i+j].b).y; tmp.first = min(tmp.first, now); tmp.second = max(tmp.second, now); &#125; &#125; sol.push_back(tmp); &#125; sort(sol.begin(), sol.end()); if (!sol.size()) return 0; double lst = sol[0].first, ret = 0; for (int i = 0; i &lt; sol.size(); i++) &#123; if (sol[i].second &lt;= lst) continue; if (sol[i].first &gt; lst) ret += sol[i].second - sol[i].first; else ret += sol[i].second - lst; lst = sol[i].second; &#125; return ret;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lf %lf %lf %lf %lf %lf\", &amp;p[tot+1].x, &amp;p[tot+1].y, &amp;p[tot+2].x, &amp;p[tot+2].y, &amp;p[tot+3].x, &amp;p[tot+3].y); if (p[tot+1].x == p[tot+2].x) p[tot+2].x += 0.001; else if (p[tot+1].x == p[tot+3].x) p[tot+3].x += 0.001; else if (p[tot+2].x == p[tot+3].x) p[tot+3].x += 0.001; e[++ee] = edge(p[tot+1], p[tot+2]); e[++ee] = edge(p[tot+2], p[tot+3]); e[++ee] = edge(p[tot+3], p[tot+1]); tot += 3; &#125; for (int i = 1; i &lt;= ee; i++) &#123; for (int j = i + 1; j &lt;= ee; j++) &#123; if (GFXJ(e[i].a, e[i].b, e[j].a, e[j].b)) &#123; p[++tot] = line_intersection(e[i].a, e[i].b, e[j].a, e[j].b); &#125; &#125; &#125; sort(p + 1, p + tot + 1); double lst = 0, lstx = 114514, now = 0; for (int i = 1; i &lt;= tot; i++) &#123; now = solve(p[i].x); if (sgn(lstx - 114514) != 0) &#123; ans += (p[i].x - lstx) * (now + lst) / 2; &#125; lstx = p[i].x; lst = now; while (p[i+1].x == p[i].x) i++; &#125; printf(\"%.2lf\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://akdream.tk/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"领导集团问题「FJOI2018」","slug":"领导集团问题「FJOI2018」","date":"2020-04-13T11:26:40.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/c8636109.html/","link":"","permalink":"http://akdream.tk/post/c8636109.html/","excerpt":"","text":"【题目描述】一个公司的组织领导架构可以用一棵领导树来表示。公司的每个成员对应于树中一个结点$v_i$，且每个成员都有响应的级别$w_i$。越高层的领导，其级别值$w_i$越小。树中任何两个结点之间有边相连，则表示与结点相应的两个成员属于同一部门。领导集团问题就是根据公司的领导树确定公司的最大部门。换句话说，也就是在领导树中寻找最大的部门结点子集，使得的结点$v_i$和$v_j$，如果$v_i$是$v_j$的子孙结点，则$w_i \\ge w_j$。编程任务：对于任意对于给定的领导树，计算出领导树中最大的部门结点子集。 【输入格式】第一行有一个正整数$n$，表示领导树的结点数。接下来的一行中有$n$个整数。第$i$个数表示$w_i$。再接下来的$n - 1$行中，第$i$行有一个整数$v_i$表示$v_i$是$i + 1$的双亲结点。$n$为正整数，$n \\le 200000$，$0 &lt; w_i \\le 10^9$ 【输出格式】输出找到的最大的部门的成员数。 这题目描述故弄玄虚。。。害我看半天 简单来说就是选出树上一个点集(不一定要相连的点) 满足点集中任意两点$i,j$，如果$i$是$j$的直接祖先，一定有$w_i\\le w_j$。 题解设计一个DP方程$dp[i][j]$表示 在$i$的子树中(这棵树是有根树！)，选择的所有点的权值全部大于等于$j$时 最多选多少个点。 如果要选当前节点$u$那么在子树里选的点的权值就必须全部$\\ge w_u$所以转移方程十分显然(并不)，如下： 由于$u$的两个不同儿子的子树中怎么选点是互不影响的 所以在转移到$u$之前我们先把$u$所有儿子的$dp[v][j]$对应的加在一起(就是对于每一个$j$把所有儿子的$dp[?][j]$累加起来) 我们再看看$dp[i][j]$的定义 容易发现对于一个点$x$随着$j$的增大$dp[x][j]$肯定是不断减小的 所以转移方程直接写成$dp[u][j]=dp[v][j]+\\triangle$ 这个$\\triangle$是什么？意思是说如果可以取$u$这个点 那么就是$1$否则为$0$ 关于能不能取$u$这个点其实不太好考虑 为什么不好考虑呢？首先 如果你取了$u$那么一定要$j\\le w_u$其次 如果$j\\le w_u$那么有可能$dp[v][j]$里面已经取了权值小于$w_u$的点了！所以我们先放在一边 稍后再来考虑 把所有儿子的$dp$值累加总时间是$O(n^2)$的 这就不太行 发现转移是在树上的 我们可以用线段树合并来操作这个DP转移 具体地说 线段树的每一个叶子的位置上存着$dp[i][j]$ 对于儿子的$dp$值累加 直接把所有儿子的线段树合并就行了 然后关于那个$\\triangle$肯定是有一段$dp[u][j\\sim k]$需要加$1$但是线段树合并不支持区间修改 因为我们刚才提到的那个 “随着$j$的增大$dp[x][j]$肯定是不断减小的” 的性质 我们可以让叶子节点存$dp$值的后缀差分数组 这样每次只用改两个点了 到底哪一段要$+1$？后缀差分数组的第$w_u$项肯定是要$+1$的 然后$-1$的位置则是在 从后缀差分数组$w_u$项往前找第一个大于$0$的位置 如果那个位置大于零了 就意味着在$u$的子树里已经取了一个权值小于$w_u$的点了(请自行理解) 这个位置可以用线段树上二分找到(但是这个二分会显得比较抽搐 蒟蒻调半天调不出来只好去参考标程) 答案就是最终的$dp[1][1]$也就是你把$1$号节点那个差分线段树整个加起来 时间复杂度$O(n\\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;int n, w[200005], srt[200005], mx, ans;int head[200005], pre[400005], to[400005], sz; bool ok;inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;struct tree&#123; int lc, rc, cnt;&#125; tr[4000005];int rt[200005], tot;#define lson tr[ind].lc#define rson tr[ind].rcint merge(int x, int y) &#123; if (!x) return y; if (!y) return x; tr[x].lc = merge(tr[x].lc, tr[y].lc); tr[x].rc = merge(tr[x].rc, tr[y].rc); tr[x].cnt += tr[y].cnt; return x;&#125;void update(int &amp;ind, int l, int r, int pos, int v) &#123; if (!ind) ind = ++tot; tr[ind].cnt += v; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(lson, l, mid, pos, v); else update(rson, mid+1, r, pos, v);&#125;void del(int ind) &#123; //这个还是二分 tr[ind].cnt--; if (tr[rson].cnt) del(rson); else if (tr[lson].cnt) del(lson);&#125;void del(int ind, int l, int r, int pos) &#123; //线段树上二分 if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) &#123; del(lson, l, mid, pos); &#125; else &#123; del(rson, mid + 1, r, pos); if (!ok &amp;&amp; tr[lson].cnt) &#123; del(lson); ok = 1; &#125; &#125; if (ok) tr[ind].cnt--;&#125; void dfs(int x, int fa) &#123; for (int i = head[x]; i; i = pre[i]) &#123; if (to[i] == fa) continue; dfs(to[i], x); rt[x] = merge(rt[x], rt[to[i]]); &#125; update(rt[x], 1, n, w[x], 1); ok = 0; del(rt[x], 1, n, w[x]);&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]), srt[i] = w[i]; sort(srt + 1, srt + n + 1); mx = unique(srt + 1, srt + n + 1) - srt - 1; for (int i = 1; i &lt;= n; i++) w[i] = lower_bound(srt + 1, srt + mx + 1, w[i]) - srt; for (int i = 2, fa; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;fa); addedge(fa, i); &#125; dfs(1, 0); printf(\"%d\\n\", tr[rt[1]].cnt); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"树的旋转「POI 2011」","slug":"树的旋转「POI 2011」","date":"2020-04-06T14:35:43.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/927200fa.html/","link":"","permalink":"http://akdream.tk/post/927200fa.html/","excerpt":"","text":"【题目描述】现在有一棵二叉树，所有非叶子节点都有两个孩子。在每个叶子节点上有一个权值(有$n$个叶子节点，满足这些权值为$1\\dots n$的一个排列)。可以任意交换每个非叶子节点的左右孩子。 要求进行一系列交换，使得最终所有叶子节点的权值按照遍历序写出来，逆序对个数最少。 【输入格式】第一行n下面每行，一个数x 如果$x=0$，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息， 如果$x\\ne 0$，表示这个节点是叶子节点，权值为$x$ 【输出格式】一行，最少逆序对个数。 题解此题输入稍微有点毒瘤啊。。。但是反正是按照dfs序给的 就边dfs边读入好了 如果我们把所有的叶子节点从左到右编号为$1\\sim n$，那么某个节点$x$的子树中必定含有编号连续的一段叶子节点$[l,r]$，也就是说叶子节点$l$到叶子节点$r$都在$x$的子树里 方便起见我们再把叶子节点$i$的权值定义为$v_i$ 现在考虑一个非叶子节点$x$它的左儿子是$a$，右儿子是$b$我们记$a$子树里含有$[l_a, r_a]$的叶子节点，$b$子树里有$[l_b, r_b]$的叶子节点 我们让$f(x)$等于 满足$l_a\\le i\\le r_a,\\ l_b\\le j\\le r_b,\\ v_i&gt;v_j$的所有逆序对$(i,j)$的数量 那么如果没有交换操作的话 答案就是所有的$f(i)$之和 这个我也不知道怎么解释。。。似乎挺显然的 因为左右儿子内部的逆序对之前已经统计完了嘛 那么如果我们交换了$a,b$的位置$f(x)$会有什么变化呢 $f(x)$就会变成满足$l_a\\le i\\le r_a,\\ l_b\\le j\\le r_b,\\ v_i&lt;v_j$的$(i,j)$的数量 因为左右交换了 所以原来的顺序对全部变成了逆序对 逆序对全部变成了顺序对 怎么求逆序对？ 因为此题给出的二叉树不一定是完全二叉树 所以不能用归并排序 树状数组则不方便我们快速统计上面要求的那个东西，也不好合并 所以我们用权值线段树 我们要求的是这个：满足$l_a\\le i\\le r_a,\\ l_b\\le j\\le r_b,\\ v_i&gt;v_j$的所有$(i,j)$的数量 这个可以在合并左儿子和右儿子的线段树时顺便统计出来 我们依然把左儿子叫做$a$，右儿子叫做$b$ 具体来说 对于权值线段树的一个节点代表的区间$[l,r]$令$cnt1$等于$a$的线段树在$[mid+1,r]$区间的元素个数（就是说左儿子的子树里的叶子节点$i$有多少个$mid+1\\le v_i\\le r$）$cnt2$等于$b$的线段树在$[l,mid]$区间的元素个数 那么$cnt1$的节点和$cnt2$的节点两两匹配都一定满足$l_a\\le i\\le r_a,\\ l_b\\le j\\le r_b,\\ v_i&gt;v_j$所以$f(x)$加上$cnt1*cnt2$ 对于权值线段树上每个节点都算一次 注意 这样统计一定是不重不漏的 很好理解 但是我并不知道怎么解释。。。 反过来也同理 因为你要么交换 要么不交换 所以答案就加上两种$f(x)$中较小的那一个 这篇题解真难写 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, m, son[1000005][2], out[1000005];struct segtree&#123; int lc, rc, cnt;&#125; tr[4000005];int tot;int rt[1000005];ll ans;//权值线段树 ↓void update(int &amp;ind, int l, int r, int p) &#123; if (!ind) ind = ++tot; tr[ind].cnt++; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) update(tr[ind].lc, l, mid, p); else update(tr[ind].rc, mid+1, r, p);&#125;int query(int ind, int l, int r, int x, int y) &#123; if (x &gt; y || !ind) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) return tr[ind].cnt; int mid = (l + r) &gt;&gt; 1, ret = 0; if (x &lt;= mid) ret += query(tr[ind].lc, l, mid, x, y); if (mid &lt; y) ret += query(tr[ind].rc, mid+1, r, x, y); return ret;&#125;//权值线段树 ↑int merge(int x, int y, ll &amp;mn, ll &amp;mx) &#123; if (!x) return y; if (!y) return x; mn += 1ll * tr[tr[x].lc].cnt * tr[tr[y].rc].cnt; mx += 1ll * tr[tr[y].lc].cnt * tr[tr[x].rc].cnt; tr[x].cnt += tr[y].cnt; tr[x].lc = merge(tr[x].lc, tr[y].lc, mn, mx); tr[x].rc = merge(tr[x].rc, tr[y].rc, mn, mx); return x;&#125;int dfs() &#123; int ind = ++m; int val; scanf(\"%d\", &amp;val); if (val) &#123; update(rt[ind], 1, n, val); &#125; else &#123; int lc = dfs(), rc = dfs(); ll mn = 0, mx = 0; rt[ind] = merge(rt[lc], rt[rc], mn, mx); ans += min(mn, mx); &#125; return ind;&#125;int main() &#123; scanf(\"%d\", &amp;n); dfs(); printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"SvT[BZOJ3879]","slug":"SvT[BZOJ3879]","date":"2020-03-29T10:36:21.000Z","updated":"2020-10-08T12:16:08.092Z","comments":true,"path":"post/38b643db.html/","link":"","permalink":"http://akdream.tk/post/38b643db.html/","excerpt":"","text":"【题目描述】有一个长度为n的仅包含小写字母的字符串$S$,下标范围为$[1,n]$. 现在有若干组询问,对于每一个询问,我们给出若干个后缀(以其在$S$中出现的起始位置来表示),求这些后缀两两之间的LCP(LongestCommonPrefix)的长度之和.一对后缀之间的LCP长度仅统计一遍. 【输入格式】第一行两个正整数$n,m$,分别表示$S$的长度以及询问的次数. 接下来一行有一个字符串$S$. 接下来有$m$组询问,对于每一组询问,均按照以下格式在一行内给出: 首先是一个整数$t$,表示共有多少个后缀.接下来$t$个整数分别表示$t$个后缀在字符串$S$中的出现位置. 【输出格式】对于每一组询问,输出一行一个整数,表示该组询问的答案.由于答案可能很大,仅需要输出这个答案对于$23333333333333333$(一个巨大的质数)取模的余数 题解这不是和 差异「AHOI2013」 几乎一模一样吗。。。那题就相当于询问是$1\\sim n$的所有后缀 然后式子稍微变变形 传送门 这题也是一样 先建好后缀数组 对于每组询问 先按照后缀数组的$rnk$进行排序 然后去重 然后用ST表来求出排序后相邻两个后缀的LCP 剩下的单调栈DP就跟上面那题一样了 不想再敲一遍了 请点上面传送门 看解法一：后缀数组 唯一的区别就是多个ST表。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;#define N 500005using namespace std;typedef long long ll;const ll mod = 23333333333333333;int n, m, t;char s[500005];int sa[N], sum[N], rnk[N], sa2[N], key[N], height[N], q[N], tmp[N], stk[N], top;ll f[N], ans;inline bool check(int *num, int a, int b, int l) &#123; return num[a] == num[b] &amp;&amp; num[a+l] == num[b+l];&#125;inline void DA(int _m) &#123; int i, j, p; for (i = 1; i &lt;= _m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[rnk[i]=s[i]]++; for (i = 2; i &lt;= _m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[rnk[i]]--] = i; for (j = 1, p = 0; j &lt;= n; j &lt;&lt;= 1, _m = p) &#123; p = 0; for (i = n - j + 1; i &lt;= n; i++) sa2[++p] = i; for (i = 1; i &lt;= n; i++) if (sa[i] &gt; j) sa2[++p] = sa[i] - j; for (i = 1; i &lt;= n; i++) key[i] = rnk[sa2[i]]; for (i = 1; i &lt;= _m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[key[i]]++; for (i = 2; i &lt;= _m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[key[i]]--] = sa2[i]; for (swap(rnk, sa2), p = 2, rnk[sa[1]] = 1, i = 2; i &lt;= n; i++) &#123; rnk[sa[i]] = check(sa2, sa[i-1], sa[i], j) ? p - 1 : p++; &#125; &#125;&#125;inline void geth() &#123; ll p = 0; for (int i = 1; i &lt;= n; i++) rnk[sa[i]] = i; for (int i = 1; i &lt;= n; i++) &#123; if (p) p--; int j = sa[rnk[i]-1]; while (s[i + p] == s[j + p]) p++; height[rnk[i]] = p; &#125;&#125;int st[N][21];void preST() &#123; for (int i = 1; i &lt;= n; i++) st[i][0] = height[i]; for (int l = 1; (1 &lt;&lt; l) &lt;= n; l++) &#123; for (int i = 1; i &lt;= n - (1 &lt;&lt; l) + 1; i++) &#123; st[i][l] = min(st[i][l-1], st[i+(1&lt;&lt;(l-1))][l-1]); &#125; &#125;&#125;inline int query(int x, int y) &#123; int l = log2(y - x + 1); return min(st[x][l], st[y - (1 &lt;&lt; l) + 1][l]);&#125;inline bool cmp(int x, int y) &#123; return rnk[x] &lt; rnk[y];&#125;int main() &#123; scanf(\"%d %d %s\", &amp;n, &amp;m, s + 1); DA(128); geth(); preST(); for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;t); ans = 0; for (int j = 1; j &lt;= t; j++) scanf(\"%d\", &amp;q[j]); sort(q + 1, q + t + 1, cmp); t = unique(q + 1, q + t + 1) - q - 1; for (int j = 2; j &lt;= t; j++) &#123; tmp[j] = query(rnk[q[j-1]] + 1, rnk[q[j]]); &#125; stk[top=1] = 1; for (int j = 2; j &lt;= t; j++) &#123; while (top &amp;&amp; tmp[stk[top]] &gt; tmp[j]) top--; f[j] = f[stk[top]] + (j - stk[top]) * tmp[j]; stk[++top] = j; ans += f[j]; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"Siano[BZOJ4293]","slug":"Siano[BZOJ4293]","date":"2020-03-25T13:36:58.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/16e80e56.html/","link":"","permalink":"http://akdream.tk/post/16e80e56.html/","excerpt":"","text":"【题目描述】农夫Byteasar买了一片$n$亩的土地，他要在这上面种草。 他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a[i]$厘米。 Byteasar一共会进行$m$次收割，其中第$i$次收割在第$d[i]$天，并把所有高度大于等于$b[i]$的部分全部割去。Byteasar想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？ 【输入格式】第一行包含两个正整数$n,m(1\\leq n,m\\leq 500000)$，分别表示亩数和收割次数。 第二行包含$n$个正整数，其中第$i$个数为$a[i]$，依次表示每亩种植的草的生长能力。 接下来$m$行，每行包含两个正整数$d[i],b[i]$，依次描述每次收割。 数据保证$d[1]&lt;d[2]&lt;…&lt;d[m]$，并且任何时刻没有任何一亩草的高度超过$10^{12}$。 【输出格式】输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。 我们发现 如果$a[i]\\ge a[j]$那么任一时刻 第$i$亩草的高度都一定大于等于第$j$亩草 并不难证明吧 如果没有收割 那么结论显然成立 如果有收割 那要么是第$i$亩草和第$j$亩草都被割成$b$了 要么是第$i$亩草被割成$b$了 第$j$亩草还没长到$b$ 所以我们把$n$亩草按生长速度从小到大排序 由于此时草的高度在任一时刻都是单调递增的 那么每次割草都一定是一段后缀能被收割 既然每次都是连续的一段被收割 我们就可以用线段树来维护这个东西 首先看看我们需要用线段树进行哪些操作 由于要查询割去的高度和 而割去的高度和就等于总高度和-区间长度$\\times b$所以肯定要支持查询区间和 但是草的长度每天都在更新 不可能一天一天地更新 所以我们对于每个区间记录两个值$day$表示该区间从第$day$天开始就再没有草被割过了(就是最后一次有草被割的天数+1)$sum$表示第$day$天开始前草的总高度$spd$表示区间内草生长速度的总和 那么我们查询第$k$天区间草的高度和 就是$sum+(k-day+1)*spd$ 有区间修改(把$i\\sim n$区间内的草全部割成$b$) 要维护两个懒标记$tagd$和$tagb$ 查询每次割草割的是从哪里开始的后缀需要在线段树上二分 所以我们多维护一循区间左端点那一亩草的$day,sum,spd$，这样方便进行二分 其实代码也没有很长。。。具体细节在代码中有注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; T f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); x *= f;&#125;int n, m;ll a[500005], ans;struct segtree&#123; struct tree&#123; int l, r; ll sum, spd, day, mn, mnspd; ll tagd, tagb; &#125; tr[2000005]; #define lson ind&lt;&lt;1 #define rson ind&lt;&lt;1|1 inline void pushup(int ind) &#123; tr[ind].day = tr[rson].day; //每次修改的是一段后缀 所以右儿子的day肯定大于等于左儿子 tr[ind].spd = tr[lson].spd + tr[rson].spd; //其实不用每次都更新 因为懒得改了 tr[ind].mnspd = tr[lson].mnspd; //这个也不用更新。。。 tr[ind].sum = tr[lson].sum + (tr[ind].day - tr[lson].day) * tr[lson].spd + tr[rson].sum + (tr[ind].day - tr[rson].day) * tr[rson].spd; //当前节点的sum等于左儿子和右儿子在第day-1天的草长度和 代到我文章上面那个算第k天草长度的式子里就是这个 tr[ind].mn = tr[lson].mn + (tr[rson].day - tr[lson].day) * tr[lson].mnspd; //单独维护一下左端点 &#125; inline void add(int ind, ll d, ll b) &#123; tr[ind].day = d + 1; //第d天被割了 所以day=d+1 tr[ind].sum = 1ll * (tr[ind].r - tr[ind].l + 1) * b; //全部草长度变为b tr[ind].mn = b; tr[ind].tagd = d; tr[ind].tagb = b; &#125; inline void pushdown(int ind) &#123; if (!tr[ind].tagd) return; add(lson, tr[ind].tagd, tr[ind].tagb); add(rson, tr[ind].tagd, tr[ind].tagb); tr[ind].tagd = tr[ind].tagb = 0; &#125; void build(int ind, int l, int r) &#123; tr[ind].l = l, tr[ind].r = r, tr[ind].sum = tr[ind].mn = 0, tr[ind].day = 1; if (l == r) &#123; tr[ind].spd = a[l]; tr[ind].mnspd = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(ind); &#125; int find(int ind, ll d, ll b) &#123; int l = tr[ind].l, r = tr[ind].r; if (l == r) &#123; if (tr[ind].mn + (d - tr[ind].day + 1) * tr[ind].mnspd &gt; b) return l; else return l + 1; &#125; pushdown(ind); if (tr[rson].mn + (d - tr[rson].day + 1) * tr[rson].mnspd &gt; b) return find(lson, d, b); else return find(rson, d, b); &#125; ll query(int ind, int x, int y, ll d, ll b) &#123; if (x &gt; y) return 0ll; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return tr[ind].sum + (d - tr[ind].day + 1) * tr[ind].spd - 1ll * (r - l + 1) * b; &#125; pushdown(ind); int mid = (l + r) &gt;&gt; 1; ll ret = 0; if (x &lt;= mid) ret += query(lson, x, y, d, b); if (mid &lt; y) ret += query(rson, x, y, d, b); return ret; &#125; void update(int ind, int x, int y, ll d, ll b) &#123; if (x &gt; y) return; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; add(ind, d, b); return; &#125; pushdown(ind); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(lson, x, y, d, b); if (mid &lt; y) update(rson, x, y, d, b); pushup(ind); &#125;&#125; T;int main() &#123; read(n); read(m); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); &#125; sort(a + 1, a + n + 1); T.build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; ll d, b; read(d); read(b); int st = T.find(1, d, b); ans = T.query(1, st, n, d, b); printf(\"%lld\\n\", ans); T.update(1, st, n, d, b); &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Optimal Milking[USACO2013 Dec]","slug":"Optimal Milking[USACO2013 Dec]","date":"2020-03-23T14:18:32.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/6bb32afa.html/","link":"","permalink":"http://akdream.tk/post/6bb32afa.html/","excerpt":"","text":"【题目描述】Farmer John最近购买了$N(1 \\leq N \\leq 40000)$台挤奶机，编号为$1 \\sim N$，并排成一行。第$i$台挤奶机每天能够挤$M(i)$单位的牛奶$(1 \\leq M(i) \\leq 100,000)$。由于机器间距离太近，使得两台相邻的机器不能在同一天使用。Farmer John可以自由选择不同的机器集合在不同的日子进行挤奶。 在$D(1 \\leq D \\leq 50,000)$天中，每天Farmer John对某一台挤奶机进行维护，改变该挤奶机的产量。 Farmer John希望设计一个挤奶方案，使得挤奶机能够在D天后获取最多的牛奶。 【输入格式】第$1$行：两个整数$N$和$D$ 第$2\\dots N+1$行：每台挤奶机的$M(i)$ 第$N+2\\dots N+D+1$行：两个整数$i$和$m$，表示每天对机器$i$进行维护，机器$i$的产量为$m$。 【输出格式】输出最大产量。 题解不知道这种题目能不能叫区间DP。。。在线段树上区间DP? 对于线段树的每个节点 我们维护一个$f[2][2]$ 其中$f[0][0]$表示区间左端点不选 右端点也不选时的最大区间和$f[0][1]$表示左端点不选 右端点选 剩下两个也类似 那么我们要把一个节点的左右儿子合并来更新当前节点 怎么来合并这个$f[2][2]$呢？ 为了方便起见 我们这里假设当前节点$x$的左儿子是$l$，右儿子是$r$ 那么$x.f[0][0] = max(l.f[0][0]+r.f[0][0],l.f[0][1]+r.f[0][0],l.f[0][0]+r.f[1][0])$ 感觉是不是少了什么？为什么没有$l.f[0][1]+r.f[1][0]$？ 这个是不合法的 因为题目要求相邻两个不能同时选择 而左儿子区间的右端点和右儿子区间的左端点当然是相邻的 剩下3个转移也同理 为了更清楚一点这里还是写出来 $x.f[0][1] = max(l.f[0][0]+r.f[0][1],l.f[0][1]+r.f[0][1],l.f[0][0]+r.f[1][1])$ $x.f[1][0] = max(l.f[1][0]+r.f[0][0],l.f[1][1]+r.f[0][0],l.f[1][0]+r.f[1][0])$ $x.f[1][1] = max(l.f[1][0]+r.f[0][1],l.f[1][1]+r.f[0][1],l.f[1][0]+r.f[1][1])$ ok 对于叶子节点$f[0][0]=0$$f[1][1]=M(i)$$f[0][1]$和$f[1][0]$都是不合法的(因为叶子节点的区间就只有一个元素) 所以设成负无穷 单点修改只需要改叶子的$f[1][1]$就可以了 那么此题就做完了 ps.合并$f$数组时注意如果转移得到某个$f[i][j]$比负无穷还小了 就把$f[i][j]$重新设为负无穷 防止负无穷加爆了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; const ll inf = 0x3f3f3f3f3f3f3f3f;int n, d;ll a[40005], ans;struct segtree&#123; struct tree&#123; int l, r; ll f[2][2]; &#125; tr[400005]; #define lson ind&lt;&lt;1 #define rson ind&lt;&lt;1|1 inline void pushup(int ind) &#123; //合并f数组 tr[ind].f[0][0] = max(max(tr[lson].f[0][1] + tr[rson].f[0][0], tr[lson].f[0][0] + tr[rson].f[1][0]), tr[lson].f[0][0] + tr[rson].f[0][0]); tr[ind].f[0][1] = max(max(tr[lson].f[0][1] + tr[rson].f[0][1], tr[lson].f[0][0] + tr[rson].f[1][1]), tr[lson].f[0][0] + tr[rson].f[0][1]); tr[ind].f[1][0] = max(max(tr[lson].f[1][1] + tr[rson].f[0][0], tr[lson].f[1][0] + tr[rson].f[1][0]), tr[lson].f[1][0] + tr[rson].f[0][0]); tr[ind].f[1][1] = max(max(tr[lson].f[1][1] + tr[rson].f[0][1], tr[lson].f[1][0] + tr[rson].f[1][1]), tr[lson].f[1][0] + tr[rson].f[0][1]); for (int i = 0; i &lt;= 1; i++) for (int j = 0; j &lt;= 1; j++) tr[ind].f[i][j] = max(tr[ind].f[i][j], -inf); //防止爆long long &#125; void build(int ind, int l, int r) &#123; tr[ind].l = l, tr[ind].r = r; for (int i = 0; i &lt;= 1; i++) for (int j = 0; j &lt;= 1; j++) tr[ind].f[i][j] = -inf; if (l == r) &#123; tr[ind].f[0][0] = 0; tr[ind].f[1][1] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); pushup(ind); &#125; void update(int ind, int pos, ll x) &#123; int l = tr[ind].l, r = tr[ind].r; if (l == r) &#123; tr[ind].f[1][1] = x; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(lson, pos, x); else update(rson, pos, x); pushup(ind); &#125;&#125; T;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;d); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); &#125; T.build(1, 1, n); for (int i = 1; i &lt;= d; i++) &#123; int pos, v; ll nowans = 0; scanf(\"%d %d\", &amp;pos, &amp;v); T.update(1, pos, v); nowans = max(nowans, T.tr[1].f[0][0]); nowans = max(nowans, T.tr[1].f[0][1]); nowans = max(nowans, T.tr[1].f[1][0]); nowans = max(nowans, T.tr[1].f[1][1]); ans += nowans; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"蒟蒻的数列[BZOJ4636]","slug":"蒟蒻的数列[BZOJ4636]","date":"2020-03-22T15:04:13.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/ce9a7b8e.html/","link":"","permalink":"http://akdream.tk/post/ce9a7b8e.html/","excerpt":"","text":"在毒瘤的bzoj上似乎是道权限题。。。但是这不影响我们用一些奇奇怪怪的途径找到这道题 【题目描述】DCrusher有一个数列，初始值均为$0$，他进行$N$次操作，每次将数列$[a,b)$这个区间中所有比$k$小的数改为$k$，他想知道$N$次操作后数列中所有元素的和。他还要玩其他游戏，所以这个问题留给你解决。 【输入格式】第一行一个整数$N$，然后有$N$行，每行三个正整数$a,b,k$。 $N\\leq 40000 , a,b,k\\leq 10^9$ 【输出格式】一个数，数列中所有元素的和。 题解我们把所有修改操作按照$k$从大到小排序 那么每次修改操作实际上就变成了 把$[a,b)$区间内所有的$0$(即之前没有修改过的元素)改成$k$因为之前就修改过的元素肯定是大于$k$的 那用线段树每次查询$[a,b)$有多少个$0$记为$cnt$实际上$cnt$就等于 区间长度减去区间内有多少个非$0$元素 由于询问按$k$从大到小排序 所以现在区间内的$0$在$N$次操作结束后肯定都会是$k$所以$ans$加上$cnt*k$ 再把$[a,b)$中所有的$0$改成$k$注意 不用真的去改 因为我们实际上只关心每个区间内有多少个非$0$元素 所以我们只需要查询完后把整个区间都填成$1$就可以了 询问也就变成了区间内有多少个$1$ 所以现在我们需要支持两个操作 查询区间内有多少个$1$ 把整个区间修改成$1$ 就正常打标记 都很好实现吧 $a,b\\le 10^9$怎么办？动态开点 ps.我一般都是单点修改的时候用到动态开点 这种区间修改打标记能不能动态开点呢? 注意到修改一段区间$[l,r]$在线段树上可以通过修改不超过$\\log n$个节点实现 每个节点的深度又最多是$\\log n$所以极限情况下每次修改新创建的节点数也不会超过$\\log^2 n$个 这题是$\\log^2 10^9 \\approx 1000$但是这个上限根本达不到 更别说修改区间还会有交集 所以不用担心内存不够 缺点是常数略大。。。应该有更简单的方法 但是这个方法好就好在它十分的模板 注意一下修改的区间是$[a,b)$。。。左闭右开 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct query&#123; int l, r; ll v;&#125; q[40005];inline bool cmp(query x, query y) &#123; return x.v &gt; y.v;&#125;int n;ll ans;struct segtree&#123; struct tree&#123; int lc, rc, tag; ll cnt; &#125; tr[1000005]; int tot; #define lson tr[ind].lc #define rson tr[ind].rc inline void pushdown(int ind, int l, int r) &#123; if (!tr[ind].tag) return; tr[ind].tag = 0; int mid = (l + r) &gt;&gt; 1; if (!lson) lson = ++tot; tr[lson].cnt = mid - l + 1; tr[lson].tag = 1; if (!rson) rson = ++tot; tr[rson].cnt = r - mid; tr[rson].tag = 1; &#125; ll query(int ind, int l, int r, int x, int y) &#123; if (!ind) return 0; if (x &lt;= l &amp;&amp; r &lt;= y) return tr[ind].cnt; pushdown(ind, l, r); int mid = (l + r) &gt;&gt; 1; ll ret = 0; if (x &lt;= mid) ret += query(lson, l, mid, x, y); if (mid &lt; y) ret += query(rson, mid+1, r, x, y); return ret; &#125; void update(int &amp;ind, int l, int r, int x, int y) &#123; if (!ind) ind = ++tot; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].cnt = (r - l + 1); tr[ind].tag = 1; return; &#125; pushdown(ind, l, r); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(lson, l, mid, x, y); if (mid &lt; y) update(rson, mid+1, r, x, y); tr[ind].cnt = tr[lson].cnt + tr[rson].cnt; &#125;&#125; T;int rt;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d %d %lld\", &amp;q[i].l, &amp;q[i].r, &amp;q[i].v); q[i].r--; &#125; sort(q + 1, q + n + 1, cmp); for (int i = 1; i &lt;= n; i++) &#123; ll cnt = T.query(rt, 1, 1e9, q[i].l, q[i].r); ans += (q[i].r - q[i].l + 1 - cnt) * q[i].v; T.update(rt, 1, 1e9, q[i].l, q[i].r); &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"遗产「CF 787D」","slug":"遗产「CF 787D」","date":"2020-03-22T13:34:29.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/e870169a.html/","link":"","permalink":"http://akdream.tk/post/e870169a.html/","excerpt":"","text":"【题目描述】Rick和他的同事制作了一种新的放射性配方，很多坏人都跟着他们。所以Rick想要在坏人抓住他们之前将他的遗产交给Morty。他们的宇宙中有$n$个行星从$1$到$n$编号。Rick在行星编号$s$（地球），他不知道Morty在哪里。众所周知，里克拥有一支门卫枪。有了这把枪，他就可以打开从他所在行星到任何其他星球（包括那个星球）的单向门。但这支枪有一些限制，因为他仍在使用免费试用版。 默认情况下，他不能用这把枪打开任何门。网站上有q个这些枪支的商品。每次购买时，您只能使用一次，但如果您想再使用它，可以再次购买。网站上的出售的枪有三种类型： 1.通过这种类型的枪，您可以打开从行星$v$到行星$u$的门户。 2.通过这种类型的枪，您可以打开从行星$v$到任何行星的入口，其范围为$[l,r]$。 3.通过这种类型的枪，您可以从任何行星打开门，其索引范围为$[l,r]$到行星$v$。 Rick不知道Morty在哪里，但Unity会告诉他，他希望在他找到并立即开始他的旅程时做好准备。因此，对于每个行星（包括地球本身），他想知道从地球到这个星球所需的最低金额。 【输入格式】第一行包含三个整数$n,q,s(1\\leq","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"相关分析[SDOI2017]","slug":"相关分析[SDOI2017]","date":"2020-03-15T03:58:00.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/bf8c4327.html/","link":"","permalink":"http://akdream.tk/post/bf8c4327.html/","excerpt":"","text":"【题目描述】Frank对天文学非常感兴趣，他经常用望远镜看星星，同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离，半径等等。 Frank不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间（比如亮度和半径）是否存在某种关系。 现在Frank要分析参数$X$与$Y$之间的关系。他有$n$组观测数据，第$i$组观测数据记录了$x_i,y_i$。他需要以下几种操作： 1 L R 用直线拟合第$L$组到底$R$组观测数据。用$\\overline{x}$表示这些观测数据中$x$的平均数，用$\\overline{y}$表示这些观测数据中$y4的平均数，即 $\\overline{x}={1 \\over R-L+1} \\sum\\limits _{i=L} ^R x_i$ $\\overline{y}={1 \\over R-L+1} \\sum\\limits _{i=L} ^R y_i$ 如果直线方程是$y=ax+b$，那么$a$应当这样计算： $a={\\sum\\limits_{i=L} ^R (x_i-\\overline{x})(y_i-\\overline{y}) \\over \\sum\\limits _{i=L} ^R (x_i -\\overline{x})^2}$ 你需要帮助Frank计算$a$。 2 L R S T Frank发现测量数据第$L$组到底$R$组数据有误差，对每个$i$满足$L \\leq i \\leq R$，$x_i$需要加上$S$，$y_i$需要加上$T$。 3 L R S T Frank发现第$L$组到第$R$组数据需要修改，对于每个$i$满足$L \\leq i \\leq R$，$x_i$需要修改为$(S+i)$，$y_i$需要修改为$(T+i)$。 【输入格式】第一行两个数$n,m$，表示观测数据组数和操作次数。 接下来一行$n$个数，第$i$个数是$x_i$。 接下来一行$n$个数，第$i$个数是$y_i$。 接下来$m$行，表示操作，格式见题目描述。 【输出格式】对于每个1操作，输出一行，表示直线斜率$a$。选手输出与标准输出的绝对误差或相对误差不超过$10^{-5}$即为正确。 题解$a={\\sum\\limits_{i=L} ^R (x_i-\\overline{x})(y_i-\\overline{y}) \\over \\sum\\limits _{i=L} ^R (x_i -\\overline{x})^2}$ $={\\sum\\limits_{i=L} ^R (x_i*y_i-\\overline{x}*y_i-x_i*\\overline{y}+\\overline{x}*\\overline{y}) \\over \\sum\\limits _{i=L} ^R (x_i^2 -2*\\overline{x}*x_i+\\overline{x}^2)}$ 操作3可以看作先将$x_i,y_i\\in [l,r]$全部置为$i$然后再进行一次2操作 显然是等价的 用线段树维护4个值：$\\sum x, \\sum y, \\sum x*y, \\sum x^2$ ###细节：这里用$sumx$表示$\\sum x$，$sumy$表示$\\sum y$，$xy$表示$\\sum x*y$，$xx$表示$\\sum x^2$。 操作2将每个$x_i$加上$S$，每个$y_i$加上$T$ $sumx = sumx + (r-l+1) * S$ $sumy = sumy + (r-l+1) * T$ $xy = xy + (r-l+1)*S*T + sumx * T + sumy * S$ $xx = xx + (r-l+1)*S*S+2*sumx*S$ 对于操作2 懒标记就正常地打 上面的4个式子都是可以通过暴力拆括号得到的 不推了 操作3将每个$x_i,y_i$都置为$i$ $sumx = sumy = (r-l+1)*(l+1)/2$就是从$l$加到$r$。。。 $xx = xy = l^2+(l+1)^2+(l+2)^2+\\dots +r^2$这个可以用平方和公式$O(1)$算 平方和公式是$1^2+2^2+\\dots +n^2=\\frac{n(n+1)(2n+1)}{6}$ 注意 打操作3的tag时 因为这个是直接修改类的操作 要把操作2的tag清零 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double db;int n, m;db a[100005], b[100005];int tp, l, r;db s, t;namespace Segtree&#123; struct tree&#123; int l, r; db sumx, sumy, xy, xx; int tagi; db tagx, tagy; &#125; tr[400005]; #define lson ind&lt;&lt;1 #define rson ind&lt;&lt;1|1 inline void pushup(int ind) &#123; tr[ind].sumx = tr[lson].sumx + tr[rson].sumx; tr[ind].sumy = tr[lson].sumy + tr[rson].sumy; tr[ind].xx = tr[lson].xx + tr[rson].xx; tr[ind].xy = tr[lson].xy + tr[rson].xy; &#125; inline db getsum(int la, int ra) &#123; db l = la, r = ra; return (r - l + 1) \\* (l + r) / 2; &#125; inline db getsqr(int la, int ra) &#123; db l = la, r = ra; return (r \\* (r + 1) \\* (2 \\* r + 1) - (l-1) \\* l \\* (2 \\* (l-1) + 1)) / 6; &#125; inline void addxy(int ind, db vx, db vy) &#123; db len = (tr[ind].r - tr[ind].l + 1); tr[ind].tagx += vx; tr[ind].tagy += vy; tr[ind].xx += 2 \\* tr[ind].sumx \\* vx + vx \\* vx \\* len; tr[ind].xy += len \\* vx \\* vy + tr[ind].sumx \\* vy + tr[ind].sumy \\* vx; tr[ind].sumx += vx \\* len; tr[ind].sumy += vy \\* len; &#125; inline void addi(int ind) &#123; tr[ind].tagx = tr[ind].tagy = 0; tr[ind].tagi = 1; tr[ind].sumx = tr[ind].sumy = getsum(tr[ind].l, tr[ind].r); tr[ind].xx = tr[ind].xy = getsqr(tr[ind].l, tr[ind].r); &#125; inline void pushdown(int ind) &#123; if (tr[ind].tagi) &#123; tr[ind].tagi = 0; addi(lson); addi(rson); &#125; if (tr[ind].tagx || tr[ind].tagy) &#123; int vx = tr[ind].tagx, vy = tr[ind].tagy; tr[ind].tagx = tr[ind].tagy = 0; addxy(lson, vx, vy); addxy(rson, vx, vy); &#125; &#125; void build(int ind, int l, int r) &#123; tr[ind].l = l, tr[ind].r = r; tr[ind].tagi = tr[ind].tagx = tr[ind].tagy = 0; if (l == r) &#123; tr[ind].sumx = a[l]; tr[ind].sumy = b[l]; tr[ind].xy = a[l] \\* b[l]; tr[ind].xx = a[l] \\* a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(ind&lt;&lt;1, l, mid); build(ind&lt;&lt;1|1, mid+1, r); pushup(ind); &#125; void update2(int ind, int x, int y, db vx, db vy) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addxy(ind, vx, vy); return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) update2(lson, x, y, vx, vy); if (mid &lt; y) update2(rson, x, y, vx, vy); pushup(ind); &#125; void update3(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; addi(ind); return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) update3(lson, x, y); if (mid &lt; y) update3(rson, x, y); pushup(ind); &#125; inline tree merge(tree a, tree b) &#123; a.sumx += b.sumx; a.sumy += b.sumy; a.xx += b.xx; a.xy += b.xy; return a; &#125; tree query(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return tr[ind]; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); tree a, b; a.sumx = a.sumy = a.xx = a.xy = 0; b.sumx = b.sumy = b.xx = b.xy = 0; if (x &lt;= mid) a = query(lson, x, y); if (mid &lt; y) b = query(rson, x, y); return merge(a, b); &#125;&#125;using namespace Segtree;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%Lf\", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%Lf\", &amp;b[i]); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;tp); if (tp == 1) &#123; scanf(\"%d %d\", &amp;l, &amp;r); tree ans = query(1, l, r); db sumx = ans.sumx \\* 1.0, sumy = ans.sumy \\* 1.0, xx = ans.xx \\* 1.0, xy = ans.xy \\* 1.0; db ax = sumx / (r - l + 1), ay = sumy / (r - l + 1); db up = ax \\* ay \\* (r - l + 1) + xy - ay \\* sumx - ax \\* sumy; db down = xx \\* 1.0 - 2.0 \\* ax \\* sumx + (r - l + 1) \\* ax \\* ax; printf(\"%.10Lf\\n\", up / down); &#125; else if (tp == 2) &#123; scanf(\"%d %d %Lf %Lf\", &amp;l, &amp;r, &amp;s, &amp;t); update2(1, l, r, s, t); &#125; else &#123; scanf(\"%d %d %Lf %Lf\", &amp;l, &amp;r, &amp;s, &amp;t); update3(1, l, r); update2(1, l, r, s, t); &#125; &#125; return 0;&#125; 如何一遍写对线段树？ 单点修改$pos$ 123456789if (l == r) &#123; //进行修改 return;&#125;int mid = (l + r) &gt;&gt; 1;pushdown(ind);if (pos &lt;= mid) //向左儿子递归else //向右儿子递归//在最后要更新当前节点信息 区间修改$[x,y]$ 123456789if (x &lt;= l &amp;&amp; r &lt;= y) &#123; //修改+打标记 return;&#125;int mid = (l + r) &gt;&gt; 1;pushdown(ind);if (x &lt;= mid) //向左儿子递归if (mid &lt; y) //向右儿子递归//在最后要更新当前节点信息 pushdown记得清空父节点的tag很模板的一个东西 查询的函数也差不多 但是最后不需要更新当前节点信息了","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"排序[HEOI2016/TJOI2016]","slug":"排序[HEOI2016 TJOI2016]","date":"2020-03-13T02:01:53.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/5db47744.html/","link":"","permalink":"http://akdream.tk/post/5db47744.html/","excerpt":"","text":"【题目描述】在$2016$年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。 这个难题是这样子的：给出一个$1$到$n$的排列，现在对这个排列序列进行$m$次局部排序，排序分为两种： 0 l r 表示将区间$[l,r]$的数字升序排序 1 l r 表示将区间$[l,r]$的数字降序排序 注意，这里是对下标在区间$[l,r]$内的数排序。最后询问第$q$位置上的数字。 【输入格式】输入数据的第一行为两个整数$n$和$m$，$n$表示序列的长度，$m$表示局部排序的次数。 第二行为$n$个整数，表示$1$到$n$的一个排列。 接下来输入$m$行，每一行有三个整数$\\text{op},l,r$，$\\text{op}$为$0$代表升序排序，$\\text{op}$为$1$代表降序排序,$l,r$表示排序的区间。 最后输入一个整数$q$，表示排序完之后询问的位置。 【输出格式】输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第$q$位置上的数字。 $n,m≤10_5$，$1\\leq q\\leq n$ 题解发现$m$非常大 用一般的排序肯定会超时 有什么东西处理区间操作比较快呢 当然是线段树啦 但是线段树并不支持区间排序 所以我们把问题转换一下： 如果要我们用线段树排序一个只由0和1组成的序列 显然是可以通过区间求和以及区间修改做到的 我们可以二分答案$mid$然后把输入排列中所有大于等于$mid$的置为1 其余的置为0 然后用线段树来进行这$m$次对于01序列的排序 排好后 如果位置$q$上的数字为1 则表示$mid$大于等于答案 否则则是$mid$小于答案 时间复杂度$O(n \\log n + m \\log^2 n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define lson ind&lt;&lt;1#define rson ind&lt;&lt;1|1using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int n, m, k, a[100005], tp[100005], le[100005], ri[100005], tmp[100005]; namespace Segtree&#123; struct segtree&#123; int l, r, sum, tag; &#125; tr[400005]; void build(int ind, int l, int r) &#123; tr[ind].l = l; tr[ind].r = r; tr[ind].tag = -1; if (l == r) &#123; tr[ind].sum = tmp[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); tr[ind].sum = tr[lson].sum + tr[rson].sum; &#125; inline void pushdown(int ind) &#123; if (tr[ind].tag == -1) return; int v = tr[ind].tag; tr[ind].tag = -1; tr[lson].tag = v; tr[lson].sum = (tr[lson].r - tr[lson].l + 1) * v; tr[rson].tag = v; tr[rson].sum = (tr[rson].r - tr[rson].l + 1) * v; &#125; void update(int ind, int x, int y, int v) &#123; if (x &gt; y) return; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].tag = v; tr[ind].sum = (r - l + 1) * v; return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) update(lson, x, y, v); if (mid &lt; y) update(rson, x, y, v); tr[ind].sum = tr[lson].sum + tr[rson].sum; &#125; int query(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return tr[ind].sum; &#125; int mid = (l + r) &gt;&gt; 1, ret = 0;; pushdown(ind); if (x &lt;= mid) ret += query(lson, x, y); if (mid &lt; y) ret += query(rson, x, y); return ret; &#125;&#125;using namespace Segtree;bool check(int x) &#123; for (int i = 1; i &lt;= n; i++) tmp[i] = (a[i] &gt;= x); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; int num = query(1, le[i], ri[i]); if (!tp[i]) &#123; update(1, le[i], ri[i]-num, 0); update(1, ri[i] - num + 1, ri[i], 1); &#125; else &#123; update(1, le[i], le[i] + num - 1, 1); update(1, le[i] + num, ri[i], 0); &#125; &#125; return query(1, k, k) == 1;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= m; i++) tp[i] = read(), le[i] = read(), ri[i] = read(); k = read(); int l = 1, r = n, mid, ans = 0; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"二分答案","slug":"二分答案","permalink":"http://akdream.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]},{"title":"逆序对[AHOI2008]","slug":"逆序对[AHOI2008]","date":"2020-03-12T05:08:19.000Z","updated":"2020-10-08T12:16:08.763Z","comments":true,"path":"post/11afeb75.html/","link":"","permalink":"http://akdream.tk/post/11afeb75.html/","excerpt":"","text":"【题目描述】小可可和小卡卡想到Y岛上旅游，但是他们不知道Y岛有多远。好在，他们找到一本古老的书，上面是这样说的： 下面是$N$个正整数，每个都在$1\\sim K$之间。如果有两个数$A$和$B$，$A$在$B$左边且$A$大于$B$，我们就称这两个数为一个“逆序对”。你数一数下面的数字里有多少个逆序对，你就知道Y岛离这里的距离是多少千米了。 比如说，$4,2,1,3,3$里面包含了$5$个逆序对：$(4, 2), (4, 1), (4, 3), (4, 3), (2, 1)$。 可惜的是，由于年代久远，这些数字里有一部分已经模糊不清了，为了方便记录，小可可用$-1$表示它们。比如说，$4,2,-1,-1,3$可能原来是$4,2,1,3,3$，也可能是$4,2,4,4,3$，也可能是别的样子。小可可希望知道，根据他们看清楚的这部分数字，能不能推断出这些数字里最少能有多少个逆序对。 【输入格式】第一行两个正整数$N$和$K$。第二行$N$个整数，每个都是$-1$或是一个在$1\\sim K$之间的数。$N\\le 10000, K\\le 100$ 【输出格式】一个正整数，即这些数字里最少的逆序对个数。 ###题解 首先证明一下$-1$的地方填的数一定是单调不降的 假设$A\\le B$那么现在的逆序对数是$a+b+y$如果交换$a,b$那么逆序对数会变成$a+b+x$或者$a+b+x+1$(取决于$A=B$) 由于$A\\le B$所以$y\\le x$所以$a+b+y\\le a+b+x&lt;a+b+x+1$在$A,B$右边小于$A,B$的也同理 不证了 所以肯定是不交换，即$A\\le B$比较优 我们完全可以先把那些不是$-1$的元素之间的逆序对先算出来 然后我们就只用计算每个$-1$位置产生的逆序对数了 预处理出$sumfr[i][j]$表示$a[1\\sim i]$除$-1$外有多少个大于$j$的数，$sumbk[i][j]$表示$a[i\\sim n]$除$-1$外有多少个小于$j$的数 子状态：$dp[i][j]$表示前$i$个$-1$最后一个填了$j$的最小逆序对数$pos[i]$表示第$i$个$-1$在原数组中的下标 由于我们刚才推出了那个单调不降的性质 转移方程就很简单了：$dp[i][j]=\\min\\limits_{k=1}^{j}dp[i-1][k]+sumfr[pos[i]-1][j]+sumbk[pos[i]+1][j]$ 时间复杂度$O(nk)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define lowbit(x) x&amp;(-x)#define N 20005#define K 205using namespace std;typedef long long ll;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int n, m, a[N];ll sumfr[N][K], sumbk[N][K];ll dp[N][K];ll tr[N], ans;int q[N], tot;inline void update(int ind, int v) &#123; for (; ind &lt;= m; ind += lowbit(ind)) &#123; tr[ind] += v; &#125;&#125;inline ll getsum(int ind) &#123; ll ret = 0; for (; ind; ind -= lowbit(ind)) &#123; ret += tr[ind]; &#125; return ret;&#125;inline void getans() &#123; ans = 0; memset(tr, 0, sizeof(tr)); for (int i = 1; i &lt;= n; i++) &#123; if (a[i] == -1) continue; ans += getsum(m) - getsum(a[i]); update(a[i], 1); &#125;&#125; inline void init() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; sumfr[i][j] = sumfr[i-1][j]; if (a[i] != -1) sumfr[i][j] += (a[i] &gt; j); &#125; &#125; for (int i = n; i; i--) &#123; for (int j = 1; j &lt;= m; j++) &#123; sumbk[i][j] = sumbk[i+1][j]; if (a[i] != -1) sumbk[i][j] += (a[i] &lt; j); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] == -1) &#123; q[++tot] = i; &#125; &#125;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); getans(); init(); memset(dp, 0x3f, sizeof(dp)); for (int j = 1; j &lt;= m; j++) dp[0][j] = 0; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] = min(dp[i][j-1], dp[i-1][j]); &#125; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] += sumfr[q[i]-1][j] + sumbk[q[i]+1][j]; &#125; &#125; ll mn = 0x3f3f3f3f3f3f3f3f; for (int j = 1; j &lt;= m; j++) &#123; mn = min(mn, dp[tot][j]); &#125; printf(\"%lld\\n\", ans + mn); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"逆序对数列[HAOI2009]","slug":"逆序对数列[HAOI2009]","date":"2020-03-12T05:08:08.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/76a7cc19.html/","link":"","permalink":"http://akdream.tk/post/76a7cc19.html/","excerpt":"","text":"【题目描述】对于一个数列$a$，如果有$a_i&gt;a_j$且$i&lt;j$，那么我们称$a_i$与$a_j$为一对逆序对数。若对于任意一个由$1\\sim n$自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为$k$的这样自然数数列到底有多少个？ 【输入格式】第一行为两个整数$n,k$。 【输出格式】写入一个整数，表示符合条件的数列个数，由于这个数可能很大，你只需输出该数对$10000$求余数后的结果。 题解挺水的吧。。。简单推一下DP方程 $dp[i][j]$表示$1\\sim i$的全排列中逆序对数量为$j$的有多少个 边界：$dp[2][0]=dp[2][1]=1$特别注意$dp[1][0]=1$ 下面是转移方程 举个栗子吧：$3,1,2$现在把$4$加进去 如果加在第$k$个数后面$(0\\le k\\le 3)$逆序对就会多$3-k$个 那就完事啦$dp[i][j]=\\sum\\limits_{k=0}^{i-1}dp[i-1][j-k]$ 就比如推$dp[4][3]$吧$4$在排列第一位，且逆序对数量为$3$的方案数就是$dp[3][0]$因为你把$4$放第一个就一定会多产生$3$个逆序对嘛 那原来$3$个数就只能是没有逆序对了 前缀和$O(1)$转移 $dp$数组第一维可以去掉然后离线做 虽然这个数据很水 不去掉也没事 但是有一年ACM/ICPC好像考了原题 但是卡空间 然后离线给询问从小到大排个序 边DP边存答案 时间复杂度$O(n^2)$ ###代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;const ll mod = 1000000007;int tot, now;ll dp[5005], sum[5005], ans[5005];struct question&#123; int n, m, ind;&#125; q[5005];inline bool cmp(question a, question b) &#123; return a.n &lt; b.n;&#125;inline void DP() &#123; dp[0] = dp[1] = 1; for (ll j = 0; j &lt;= 5000; j++) &#123; sum[j] = j == 0 ? 1 : 2; &#125; while (now &lt;= tot &amp;&amp; q[now].n == 2) &#123; ans[q[now].ind] = dp[q[now].m]; now++; &#125; for (ll i = 3; i &lt;= 5000; i++) &#123; memset(dp, 0, sizeof(dp)); for (ll j = 0; j &lt;= min(i * (i - 1) / 2, 5000ll); j++) &#123; if (j - i &lt; 0) &#123; dp[j] = sum[j]; &#125; else &#123; dp[j] = (sum[j] - sum[j - i] + mod) % mod; &#125; &#125; memset(sum, 0, sizeof(sum)); sum[0] = dp[0]; for (ll j = 1; j &lt;= 5000; j++) &#123; sum[j] = (sum[j-1] + dp[j]) % mod; &#125; while (now &lt;= tot &amp;&amp; q[now].n == i) &#123; ans[q[now].ind] = dp[q[now].m]; now++; &#125; &#125; &#125;int main() &#123; tot = read(); for (int i = 1, n, m; i &lt;= tot; i++) &#123; n = read(); m = read(); q[i] = question&#123;n, m, i&#125;; &#125; sort(q + 1, q + tot + 1, cmp); now = 1; while (now &lt;= tot &amp;&amp; q[now].n == 1) &#123; ans[q[now].ind] = q[now].m == 0 ? 1 : 0; now++; &#125; DP(); for (int i = 1; i &lt;= tot; i++) &#123; printf(\"%lld\\n\", ans[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"小Z的袜子「2009国家集训队」","slug":"小Z的袜子「2009国家集训队」","date":"2020-03-12T01:56:32.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/f3561216.html/","link":"","permalink":"http://akdream.tk/post/f3561216.html/","excerpt":"","text":"【题目描述】作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z把这$N$只袜子从$1$到$N$编号，然后从编号$L$到$R$选择两只袜子。尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个$(L,R)$以方便自己选择。 【输入格式】输入文件第一行包含两个正整数$N$和$M$。$N$为袜子的数量，$M$为小Z所提的询问的数量。接下来一行包含$N$个正整数$C_i$，其中$C_i$表示第$i$只袜子的颜色，相同的颜色用相同的数字表示。再接下来$M$行，每行两个正整数$L,R$表示一个询问。 【输出格式】包含$M$行，对于每个询问在一行中输出分数$A/B$表示从该询问的区间$[L,R]$中随机抽出两只袜子颜色相同的概率。若该概率为$0$则输出$0/1$，否则输出的$A/B$必须为最简分数。 题解莫队算法，简单来说就是暴力维护双指针指向当前查询区间的左右端点 每次左或右指针可以向左或向右移动一格 同时更新当前区间的答案 我们通过离线处理 给询问排序 如果直接先按询问左端点排再按右端点排 依然容易被卡掉 比如询问$[2,2],[3,1000],[4,4],[5,2000],[6,6]$如果按照$[2,2],[4,4],[6,6],[3,1000],[5,2000]$的顺序查询 显然右指针会少移动很多次 所以这个暴力的思路就是给左端点分块 左端点在同一个$\\sqrt{n}$块中的询问优先按右端点排序 否则才是优先按左端点排序 这样做每一次左右指针只会移动大概$\\sqrt{n}$次 这个复杂度是大约$O(q\\sqrt{n})$的 足以通过此题 还有一种对询问排序的方法叫做什么奇偶块优化 似乎还要更快 可以背下板子 至于这道题具体怎么做。。。假设要加入一个颜色$x$加入后当前区间有$cnt[x]$个颜色$x$那么合法答案数就加上$cnt[x]-1$如果移除一个颜色$x$那么就减去$cnt[x]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;struct query&#123; ll l, r, id;&#125; q[50005];ll n, m, bl;ll c[50005];ll cnt[50005], ans, nl, nr;ll ansx[50005], ansy[50005];inline bool cmp(query a, query b) &#123; //奇偶块排序 if (a.l / bl == b.l / bl) &#123; if ((a.l / bl) &amp; 1) return a.r &gt; b.r; else return a.r &lt; b.r; &#125; else return a.l &lt; b.l;&#125;inline bool cmp2(query a, query b) &#123; //普通按块排序 if (a.l / bl == b.l / bl) &#123; return a.r &lt; b.r; &#125; else return a.l &lt; b.l;&#125;inline void add(ll x) &#123; cnt[x]++; if (cnt[x] &gt; 1) ans = ans + (cnt[x]-1);&#125;inline void del(ll x) &#123; cnt[x]--; if (cnt[x] &gt; 0) ans = ans - cnt[x]; &#125;inline void update(ll l, ll r) &#123; while (nl &lt; l) del(c[nl++]); while (nl &gt; l) add(c[--nl]); while (nr &lt; r) add(c[++nr]); while (nr &gt; r) del(c[nr--]);&#125;inline void getans(ll x, ll y, ll id) &#123; if (x == 0) &#123; ansx[id] = 0; ansy[id] = 1; return; &#125; ll gcd = __gcd(x, y); x /= gcd; y /= gcd; ansx[id] = x; ansy[id] = y;&#125;int main() &#123; n = read(); m = read(); bl = sqrt(n); for (ll i = 1; i &lt;= n; i++) &#123; c[i] = read(); &#125; for (ll i = 1; i &lt;= m; i++) &#123; q[i].l = read(); q[i].r = read(); q[i].id = i; &#125; sort(q+1, q+m+1, cmp); nl = q[1].l, nr = q[1].r; for (ll i = q[1].l; i &lt;= q[1].r; i++) &#123; add(c[i]); &#125; getans(ans, (nr-nl+1)*(nr-nl)/2, q[1].id); for (ll i = 2; i &lt;= m; i++) &#123; update(q[i].l, q[i].r); getans(ans, (nr-nl+1)*(nr-nl)/2, q[i].id); &#125; for (ll i = 1; i &lt;= m; i++) &#123; printf(\"%lld/%lld\\n\", ansx[i], ansy[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"Race[IOI2011]","slug":"Race[IOI2011]","date":"2020-03-11T14:12:26.000Z","updated":"2020-10-08T12:16:08.053Z","comments":true,"path":"post/aa883590.html/","link":"","permalink":"http://akdream.tk/post/aa883590.html/","excerpt":"","text":"【题目描述】给一棵树,每条边有权.求一条简单路径,权值和等于$k$,且边的数量最小。 【输入格式】第一行包含两个整数$n,k$，表示树的大小与要求找到的路径的边权和。 接下来$n-1$行，每行三个整数$u_i,v_i,w_i$，代表有一条连接$u_i$与$v_i$，边权为$w_i$ 【输出格式】输出一个整数，表示最小边数量。 如果不存在这样的路径，输出 -1。 题解点分治 见 https://akdream.tk/post/a082c72e.html/ 统计答案就是开一个桶$buc[i]$存储 当前子树中 到根路径的边权和为$i$的路径中最少的边数 那么 统计以$x$为根的子树的答案时 依次枚举$x$的每一个儿子 由于在同一个儿子子树中的两个点不能配对 所以我们把这个儿子的子树里的所有点 都拿去($x$的所有前面枚举过的儿子 的子树)组成的桶里匹配 设当前儿子子树中的某个点为$y$那么更新答案$ans=\\min(ans,q[y]+buc[k-p[y]])$，$q[y]$表示$y$到$x$经过多少条边，$p[y]$表示$y$到$x$路径的边权和 吐槽一下 断句难题 组织语言困难综合征 然后把这个儿子的子树放到桶里 也是枚举子树中的所有点$buc[p[y]]=\\min(buc[p[y]],q[y])$ ps：$buc[0]$是一直等于$0$的 因为这个调了10分钟ps2：如果在dfs求当前子树中每个点到重心距离时 发现当前节点到重心的距离已经大于$k$了 就直接return 否则容易REps3：每次统计完一次答案后 把桶清空时 不能暴力memset 不然时间复杂度会退化 把这次统计答案更改过的一个个改回$inf$就可以了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 200005using namespace std;typedef long long ll;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;const int inf = 0x3f3f3f3f;int n, k, rt, nowsz, mx;int head[N], pre[N&lt;&lt;1], to[N&lt;&lt;1], val[N&lt;&lt;1], sz; int tot[N], dis[N], dis2[N];int ans;bool vis[N];int p[N], q[N], buc[1000005], top, lst;inline void init() &#123; buc[0] = 0; for (int i = 1; i &lt;= k; i++) buc[i] = inf; ans = inf;&#125;inline void addedge(int u, int v, int w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w; &#125;void getrt(int x, int fa) &#123; tot[x] = 1; int nowmx = -inf; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa || vis[y]) continue; getrt(y, x); tot[x] += tot[y]; nowmx = max(nowmx, tot[y]); &#125; nowmx = max(nowmx, nowsz - tot[x]); if (nowmx &lt; mx) &#123; mx = nowmx, rt = x; &#125;&#125;void getdis(int x, int fa) &#123; if (dis[x] &gt; k) return; //如果x到当前重心的距离已经大于k了 就没必要再搜下去了 p[++top] = dis[x]; q[top] = dis2[x]; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa || vis[y]) continue; dis[y] = dis[x] + val[i]; dis2[y] = dis2[x] + 1; getdis(y, x); &#125;&#125;void calc(int x) &#123; dis[x] = dis2[x] = 0; top = 0; buc[0] = 0; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (vis[y]) continue; lst = top + 1; dis[y] = dis[x] + val[i]; dis2[y] = dis2[x] + 1; getdis(y, x); //dis[i],p[]: 节点i到x路径的边权和 //dis2[i],q[]: 节点i到x路径的边数 for (int j = lst; j &lt;= top; j++) &#123; //把y子树中的节点拿去和前面枚举过的的匹配 ans = min(ans, q[j] + buc[k - p[j]]); &#125; for (int j = lst; j &lt;= top; j++) &#123; //把y子树中的所有节点放进桶里 buc[p[j]] = min(buc[p[j]], q[j]); &#125; &#125; for (int i = 1; i &lt;= top; i++) &#123; buc[p[i]] = inf; &#125;&#125;void divide(int x) &#123; calc(x); vis[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (vis[y]) continue; mx = inf; nowsz = tot[y]; getrt(y, 0); divide(rt); &#125; &#125;int main() &#123; n = read(); k = read(); init(); for (int i = 1; i &lt; n; i++) &#123; int u = read() + 1, v = read() + 1, w = read(); //注意输入中节点编号从0开始 不过似乎不影响 addedge(u, v, w); &#125; mx = inf; nowsz = n; getrt(1, 0); divide(rt); printf(\"%d\\n\", ans == inf ? -1 : ans); return 0;&#125;","categories":[],"tags":[{"name":"点/边分治","slug":"点-边分治","permalink":"http://akdream.tk/tags/%E7%82%B9-%E8%BE%B9%E5%88%86%E6%B2%BB/"}]},{"title":"Tree[POJ1741]","slug":"Tree[POJ1741]","date":"2020-03-11T12:12:11.000Z","updated":"2020-10-08T12:16:08.123Z","comments":true,"path":"post/a082c72e.html/","link":"","permalink":"http://akdream.tk/post/a082c72e.html/","excerpt":"","text":"【题目描述】给你一棵数,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于$K$ 【输入格式】第一行 一个整数$n$ 表示树上有多少个点接下来$n-1$行 每行三个整数 表示一条无向边的两端和权值最后一行一个整数$k$ 【输出格式】一个整数 表示有多少对点之间的距离小于等于$K$ 题解 点分治模板题 什么情况下可以用点分治？当询问形如这种形式：树上所有路径中最…的/所有路径有多少条满足…就可以使用点分治将暴力枚举两点的那个$O(n^2)$优化到$O(n\\log n)$ 假如此题只需要你求**经过点$1$**的距离小于等于$K$的路径有多少条我们可以这么做：把所有点(包括$1$)到$1$的距离全部存进一个数组$q$里，然后计算$q$中有多少对数字两两加起来小于等于$k$这个是可以通过双指针$O(n)$解决的这么做显然是正确的当然是有问题的了！看下面这个例子： $q$数组里有$0,2,5$，那么$0+2,0+5,2+5$都小于等于$k$，求得的答案有三个，但是实际上合法的经过$1$的路径只有$1$到$2$，$1$到$3$两条我们注意到$2+5$是不合法的 你不能这么走2-&gt;1-&gt;3 所以只有(不在$1$的同一个儿子的子树中)的两个点才能相加配对怎么办？也很简单 按上面的方法处理完后 再分别处理$1$的每一个儿子 把儿子的子树里的所有点进行配对 这些配对都是不合法的 将答案减去这些配对的贡献即可 这个显然也是$O(n)$的 就可以求出正确的答案了 至此我们已经把此题的答案统计方法讲完了 下面讲淀粉质 点分治的思想是这样的：看这个分叉的菊花图 显然它的重心是$1$我们先用上面的方法 计算出经过点$1$的路径的贡献然后递归进$1$的每个儿子的子树 对于每个子树找到它的重心$x$然后如法炮制计算该子树内经过$x$的路径的贡献 注意是该子树内 也就是说 点$1$已经和我们无关了然后再继续往下递归这里有一个示意图先统计$1$的贡献 这是第一层 然后找到子树${2,3,4}$的重心 这里也就是$2$然后递归进入$2$继续统计 这就是第二层由于树的重心的性质：它每个儿子的子树大小都不会超过$\\frac{n}{2}$所以这里最多有$\\log n$层 再加上上面统计答案的方法是$O(n)$的 此题复杂度$O(n\\log n)$ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ '0'); return x * f;&#125;const int inf = 0x7fffffff;int n, k, rt, nowsz, mx;int head[40005], pre[80005], to[80005], val[80005], sz; int tot[40005], dis[40005];ll ans;bool vis[40005];void init() &#123; memset(head, 0, sizeof(head)); memset(vis, 0, sizeof(vis)); sz = 0; ans = 0;&#125;inline void addedge(int u, int v, int w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w; pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w; &#125;void getrt(int x, int fa) &#123; //找到当前子树的重心 tot[x] = 1; int nowmx = -inf; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa || vis[y]) continue; getrt(y, x); tot[x] += tot[y]; nowmx = max(nowmx, tot[y]); &#125; nowmx = max(nowmx, nowsz - tot[x]); if (nowmx &lt; mx) &#123; mx = nowmx, rt = x; &#125;&#125;int l, r, q[40005];void getdis(int x, int fa) &#123; //统计答案部分：找到当前子树中每个点到重心的距离 q[++r] = dis[x]; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa || vis[y]) continue; dis[y] = dis[x] + val[i]; getdis(y, x); &#125;&#125;ll calc(int x, int d) &#123; //统计答案的函数 l = 1, r = 0; dis[x] = d; getdis(x, 0); //计算当前子树中每个点到重心的距离 sort(q + 1, q + r + 1); //双指针算出多少对数字满足q[i]+q[j]&lt;=k ll ret = 0; while (l &lt; r) &#123; if (q[l] + q[r] &lt;= k) &#123; ret += r - l, l++; &#125; else r--; &#125; return ret;&#125;void divide(int x) &#123; //点分治函数 ans += calc(x, 0); //这是在统计x的答案 vis[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (vis[y]) continue; ans -= calc(y, val[i]); //这是在减去x的答案中不合法的部分 mx = inf; nowsz = tot[y]; getrt(y, 0); //这是在找y的子树的重心 divide(rt); //递归进入y &#125; &#125;int main() &#123; n = read(); init(); for (int i = 1; i &lt; n; i++) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w); &#125; k = read(); mx = inf; nowsz = n; getrt(1, 0); divide(rt); printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"点/边分治","slug":"点-边分治","permalink":"http://akdream.tk/tags/%E7%82%B9-%E8%BE%B9%E5%88%86%E6%B2%BB/"}]},{"title":"单调栈[Luogu P6198]","slug":"单调栈[Luogu P6198]","date":"2020-03-09T05:49:09.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/7c996915.html/","link":"","permalink":"http://akdream.tk/post/7c996915.html/","excerpt":"","text":"【题目描述】有一个长度为$n$的排列$p_0, p_1, \\cdots, p_{n-1}$，通过这个排列生成了一个长度为$n$的序列$S$，其中$S_i$表示由$p_0, p_1, \\cdots, p_i$组成的递增单调栈的大小。 换一种说法，序列$S$是由如下代码生成的： 12345678stack&lt;int&gt; stk;int n = p.size();vector&lt;int&gt; S;for (int i = 0; i &lt; n; i++) &#123; while (!stk.empty() &amp;&amp; p[i] &lt;= p[stk.top()]) stk.pop(); stk.push(i); S.push_back((int)stk.size());&#125; 现在给你序列$S$的一部分，没有给出的部分可以取任意值。请你根据给出的$S$复原出排列$p$。如果有多种可能，输出字典序最小的。保证一定有解。 【输入格式】第一行一个整数$n$。表示排列的长度。 接下来一行$n$个整数，表示序列$S$。其中部分项为$-1$，表示可以取任意值。 【输出格式】一行$n$个整数，一个排列。 没有打洛谷月赛。。。但是此题似乎很可做 于是就花了半个多小时切掉了 题解这题整体是一个贪心+递推的思路 假设我们已经确定了 由$S_1\\sim S_{i-1}$推出的 字典序最小的 由$1\\sim i-1$构成的排列$p$，以及$p$当前的递增单调栈$stk$注意这里的栈里存的是元素的值而不是下标 那么考虑一下怎么在$p$中插入$i$这个元素使得字典序最小 但是插入$i$这个操作我们并不好处理 不妨这样考虑 将原来$p$中所有$\\ge x$的元素全部+1 然后在$p$的末尾加上一个$x$容易证明这样得到的$p$序列对应的$S_1\\sim S_{i-1}$仍与原来一样 那么$x$要满足什么条件才能使得$S_i$恰好为要求的值呢 考虑一下$i-1$的递增单调栈$stk$必须要有$stk[S_i-1]&lt;x\\le stk[S_i]$这样$stk[S_i]\\sim stk[top]$都会被弹出 为了使字典序最小 显然我们这里就让$x=stk[S_i]$于是我们就得到了转移 所以算法流程如下： 已知：字典序最小的 由$1\\sim i-1$构成的 满足$S_1\\sim S_{i-1}$要求的排列$p$以及$p$当前的递增单调栈$stk$大小为$top$ 取$x=stk[S_i]$将当前$p$中所有$\\ge x$的元素+1 然后将$x$放到$p$的末尾 更新单调栈 $S_i=-1$或者$S_i&gt;top$的时候直接把$i$扔到$p$的末尾就可以了 但是大家应该都发现了 这个是$O(n^2)$的 无非就是 将所有$\\ge x$的元素+1 这一步耗费了太多时间 怎么$O(1)$或$O(\\log n)$解决呢？ 不用什么数据结构 这里有一个奇技♂淫巧 1.如果我们要把$i$放到$p$的末尾 我们不放$i$我们放一个$i*1000005$(或者乘上任意一个大于$n$的数) 2.如果我们要令$x=stk[S_i]$然后将当前$p$中所有$\\ge x$的元素+1 我们不用去一个个+1 只需要让$x=stk[S_i]-1$然后放到末尾就完事了 最后把这么做得到的答案排个序离散化一下就得到正确答案了 就算极限情况下 符合条件的$p$是一个$n\\sim 1$的倒序排列 由于我们乘的数大于$n$也不会出错 时间复杂度$O(n\\log n)$不知道有没有$O(n)$做法 但是由于代码中带$\\log$的只有一个sort 所以跑过$1e6$还是毫无压力的 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int n, a[1000005], top;ll stk[1000005], ans[1000005], srt[1000005], mx;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); &#125; for (ll i = 1; i &lt;= n; i++) &#123; if (a[i] == -1) &#123; ans[i] = i * 1000005; stk[++top] = ans[i]; &#125; else &#123; if (a[i] &gt; top) &#123; ans[i] = i * 1000005; stk[++top] = ans[i]; &#125; else &#123; ans[i] = stk[a[i]] - 1; stk[top = a[i]] = ans[i]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) srt[i] = ans[i]; sort(srt + 1, srt + n + 1); for (int i = 1; i &lt;= n; i++) ans[i] = lower_bound(srt + 1, srt + n + 1, ans[i]) - srt; for (int i = 1; i &lt;= n; i++) printf(\"%lld \", ans[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"Small Multiple[ARC084 B]","slug":"Small Multiple[ARC084 B]","date":"2020-03-06T14:23:12.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/5520b7f7.html/","link":"","permalink":"http://akdream.tk/post/5520b7f7.html/","excerpt":"","text":"【题目描述】给定一个整数$k$.求一个$k$的整数倍$sum$,使得$sum$的数字和最小 题解 考试的时候想尽一切办法枚举，卡时 最多卡到70pts 其实如果把那几个最毒瘤的数放上去完全可以把暴力卡掉 正解是要建图跑最短路 考虑$sum$在模$k$意义下的值 我们建立$k$个节点 编号为$0\\sim n-1$ 对于每个$i$连一条$i$到$(i+1)\\operatorname{mod} k$的边 边权为$1$表示$sum+1$数字和也$+1$ 再连一条$i$到$i* 10\\operatorname{mod} k$的边 边权为$0$表示$sum* 10$数字和不变 然后从节点$0$开始 因为第一步肯定走$0$到$1$的边(你让$0* 10$也没有意义) 所以跑一次节点$1$到节点$0$的最短路即可 到节点$0$时$sum$肯定是被$k$整除的 满足题意 有人可能会问 万一连续走了$10$次第一类边 导致加法进位了怎么办 由于我们是在图上跑最短路 连续走$10$次第一类边($sum+1+1+1\\dots +1$) 边权和为$10$一定是不如走一次第一类边再走一次第二类边($(sum+1)* 10$) 到达的是图上的同一个点 但是第二种走法边权和仅为$1$所以$1$到$0$的最短路中一定不会有连续走$10$次第一类边的情况 所以此题的答案就是$0$号节点到$1$号节点的最短路长度+1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int n, ans;int head[100005], pre[2000005], to[2000005], val[2000005], sz;int dis[100005];bool vis[100005];inline void addedge(int u, int v, int w) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w;&#125;priority_queue&lt;pii, vector&lt;pii&gt; , greater&lt;pii&gt; &gt; q;inline void dijkstra(int st) &#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis)); q.push(make_pair(0, st)); dis[st] = 1; while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (vis[x]) continue; else vis[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (dis[x] + val[i] &lt; dis[y]) &#123; dis[y] = dis[x] + val[i]; q.push(make_pair(dis[y], y)); &#125; &#125; &#125;&#125;int main() &#123; #ifdef ONLINE_JUDGE freopen(\"K.in\", \"r\", stdin); freopen(\"K.out\", \"w\", stdout); #endif n = read(); for (int i = 0; i &lt; n; i++) &#123; addedge(i, (i + 1) % n, 1); addedge(i, (i * 10) % n, 0); &#125; dijkstra(1); printf(\"%d\\n\", dis[0]); return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"选课[luogu P2014]","slug":"选课[Luogu P2014]","date":"2020-03-05T04:25:12.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/344cbb83.html/","link":"","permalink":"http://akdream.tk/post/344cbb83.html/","excerpt":"","text":"【题目描述】在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有$N$门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程$a$是课程$b$的先修课即只有学完了课程$a$，才能学习课程$b$）。一个学生要从这些课程里选择$M$门课程学习，问他能获得的最大学分是多少？ 【输入格式】第一行有两个整数$N$,$M$用空格隔开。($1 \\leq N \\leq 300$,$1 \\leq M \\leq 300$) 接下来的$N$行,第$I+1$行包含两个整数$k_i$和$s_i$,$k_i$表示第$I$门课的直接先修课，$s_i$表示第$I$门课的学分。若$k_i=0$表示没有直接先修课（$1 \\leq {k_i} \\leq N$,$1 \\leq {s_i} \\leq 20$)。 【输出格式】只有一行，选$M$门课程的最大得分。 题解 可以看出如果将课程向它的先修课连边 会形成一棵树 其中$0$号节点就是根 显然是一个背包问题。。。外面再套一个树形DP 先令$f[x][i][j]$表示$x$的子树中 枚举到$x$的第$i$个儿子 在$x$的子树中一共选了$j$个节点 的最大学分 从一个儿子的子树里按规则取$k$个节点出来就相当于一个重量为$k$，权值为$f[son][子树大小][k]$的物品 显然你从一个儿子那里只能选择一个这样的物品 你不可能既从这个儿子的子树中选取3个节点 又再选取重复的2个节点 所以实际上就是一个分组背包 一个组就是一个儿子的子树 那么转移方程是$f[x][i][j]=\\min_{k=1}^{j-1}(f[x][i-1][j],f[x][i-1][j-k]+f[son[i]][tot][k])$$son[i]$就是$x$的第$i$个儿子$tot$就当是$son[i]$的子树大小吧 初始状态：$dp[x][0][1] = s_x$其他的都设成$-inf$ 根据背包DP的尿性$i$那一维是可以通过倒着枚举来优化掉，降低空间复杂度的(虽然不优化也没事)。。。 时间复杂度大大低于$O(n^3)$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int n, m;int head[305], pre[605], to[605], sz;int a[305], f[305][305];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; to[sz] = v; head[u] = sz; pre[++sz] = head[v]; to[sz] = u; head[v] = sz;&#125; void dfs(int x, int fa) &#123; f[x][1] = a[x]; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; dfs(y, x); for (int j = m; j &gt;= 1; j--) &#123; for (int k = 0; k &lt; j; k++) &#123; f[x][j] = max(f[x][j], f[y][k] + f[x][j-k]); &#125; &#125; &#125;&#125;int main() &#123; n = read(); m = read() + 1; for (int i = 1; i &lt;= n; i++) &#123; addedge(read(), i); a[i] = read(); &#125; memset(f, -0x3f, sizeof(f)); dfs(0, 0); printf(\"%d\\n\", f[0][m]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"字符串[BZOJ3277]","slug":"字符串[BZOJ3277]","date":"2020-03-04T13:51:20.000Z","updated":"2020-10-08T12:16:08.377Z","comments":true,"path":"post/5f78fe4f.html/","link":"","permalink":"http://akdream.tk/post/5f78fe4f.html/","excerpt":"","text":"对于字符串$x$和$y$，假设字符串$y$在字符串$x$中若干的匹配位置，我们用$(l_i,r_i)$来表示。二元组代表$x$中$x_{l_i}\\sim x_{r_i}$的字符串和$y_1\\sim y_{len(y)}$完全一致。这些二元组根据第一关键字从小到大排序后形成一个序列，定义一个函数$F(x,y)$的值为该序列的非空连续序列的数量。以$F(babbabbababbab, babb) = 6$为例子，匹配的二元组序列为：$(1, 4), (4, 7), (9, 12)$ 非空连续序列为$(1, 4)$$(4, 7)$$(9, 12)$$(1, 4), (4, 7)$$(4, 7), (9, 12)$$(1, 4), (4, 7), (9, 12)$ 现在给你一个字符串$s$，请求出$F(s,x)$的和，其中$x$为$s$的全部子串。 【输入格式】输入一个字符串$s$。 【输出格式】输出题目要求的$F$值。 题解 比模板更模板 建好后缀自动机 我们把代表原串前缀的那几个节点称作关键节点(即建自动机的时候每次添加一个新字符得到的那个新节点) 那么对于一个子串$t$，我们把$t$在后缀自动机中所在的节点称作$x$，在parent树中，$x$为根的子树中的 关键节点的数量 就是$t$在原串中出现的次数 把它记为$cnt[x]$ 这个从每个关键节点开始暴力向上跳father 沿路数量++ 就能统计出来 然后这个“非空连续序列数量”其实就是$\\frac{a(a+1)}{2}$ 然后自动机中每个节点$x$含有的原串的子串数量就是$len[x]-len[fa[x]]$ 那每个节点的答案就是$cnt[x]*(cnt[x]+1)/2*(len[x]-len[fa[x]])$把所有节点的答案加起来就可以了 时间复杂度$O(n*26)$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, key[100005];char s[100005];ll ans;struct SAM&#123; struct node&#123; ll nxt[30], link, len, cnt; &#125; tr[2000010]; ll tot, lst; inline void init() &#123; tot = lst = 0; tr[0].link = -1; tr[0].len = 0; &#125; inline void build(char *str, ll len) &#123; init(); for (ll i = 1; i &lt;= len; i++) &#123; ll ind = ++tot, c = str[i] - 'a'; tr[ind].len = tr[lst].len + 1; ll p = lst; while (p != -1 &amp;&amp; !tr[p].nxt[c]) &#123; tr[p].nxt[c] = ind; p = tr[p].link; &#125; if (p == -1) &#123; tr[ind].link = 0; &#125; else &#123; ll q = tr[p].nxt[c]; if (tr[p].len + 1 == tr[q].len) &#123; tr[ind].link = q; &#125; else &#123; ll clone = ++tot; tr[clone].len = tr[p].len + 1; tr[clone].link = tr[q].link; for (ll j = 0; j &lt; 26; j++) tr[clone].nxt[j] = tr[q].nxt[j]; while (p != -1 &amp;&amp; tr[p].nxt[c] == q) &#123; tr[p].nxt[c] = clone; p = tr[p].link; &#125; tr[q].link = tr[ind].link = clone; &#125; &#125; lst = ind; key[i] = ind; //ind是一个关键节点 &#125; &#125; inline void getans() &#123; for (int i = 1; i &lt;= n; i++) &#123; int p = key[i]; while (p != -1) &#123; tr[p].cnt++; p = tr[p].link; &#125; &#125; for (ll i = 1; i &lt;= tot; i++) &#123; ll x = tr[i].len - tr[tr[i].link].len, y = tr[i].cnt; ans += y * (y + 1) / 2 * x; &#125; &#125;&#125;T;int main() &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); T.build(s, n); T.getans(); printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"差异「AHOI2013」","slug":"差异「AHOI2013」","date":"2020-03-04T13:25:33.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/e30f498c.html/","link":"","permalink":"http://akdream.tk/post/e30f498c.html/","excerpt":"","text":"【题目描述】给定一个长度为$n$的字符串$S$，令$T_i$表示它从第$i$个字符开始的后缀，求： $\\sum\\limits_{1\\le i&lt;j\\le n}\\operatorname{len}(T_i)+\\operatorname{len}(T_j)-2*\\operatorname{lcp}(T_i,T_j)$ 其中，$\\operatorname{len}(a)$表示字符串$a$的长度，$\\operatorname{lcp}(a,b)$表示字符串$a$和字符串$b$的最长公共前缀。 【输入格式】一行，一个字符串$S$。 【输出格式】一行，一个整数，表示所求值。 题解 解法一：后缀数组 $\\sum\\limits_{1\\le i","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"中学生数学题[GDOI2016]","slug":"中学生数学题[GDOI2016]","date":"2020-03-02T14:43:34.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/503d6d7.html/","link":"","permalink":"http://akdream.tk/post/503d6d7.html/","excerpt":"","text":"【题目描述】小明上初中了，他对数学有着很强烈的兴趣。 在小明学完一次函数之后，老师留了一道应用题： 商品的销量和商品的价格构成一个一次函数。假如商品的价格为$p$，愿意购买此商品的人数为$n$，他们之间满足$n=\\lfloor n_0-kp\\rfloor$,其中$p,k$为实数，$n,n_0$为整数，$\\lfloor x\\rfloor$表示不超过$x$的最大整数。 每个商品的成本为$p_0$，则销售利润为$n(p-p_0)$。请你选择一个合适的价格，使得销售利润最大。假设商品的数量无限制，未售出的商品对利润没有影响。 小明很快就做出来这道题，于是在哥哥大明面前表现的很得意。大明想了想，问小明：“如果你可以设置两个价格$p_1$和$p_2$$(p_1 &gt; p_2)$，有$n_1 = \\lfloor n_0-kp_1\\rfloor$的人按价格$p_1$购买，$n_2 = \\lfloor n_0-kp_2\\rfloor - n_1$的人按价格$p_2$购买，此时如何设置这两个价格使得利润最大？” 小明想了想，很快又想出做法了，就跑去告诉哥哥大明。大明没时间检查小明的做法，于是找到了聪明的你。你能否帮大明写一个程序验证小明的答案？ 【输入格式】输入文件只有一行：一个整数$n_0$和两个实数$p_0$,$k$，具体含义见题目描述。 【输出格式】输出文件一行：两个实数，分别表示设置一个价格的最大利润和设置两个价格的最大利润。 题解 一道友好的数学题 先看第一问 在$n$不变的条件下$p$显然是越大越好 所以$\\lfloor n_0-kp\\rfloor$会尽量小 那我们就可以把那个下取整丢掉了 奇妙变换一下 得到$p=\\frac{n_0-n}{k}$ 利润是$Y=n(p-p_0)$把$p=\\frac{n_0-n}{k}$代入，得到$Y=-\\frac{1}{k}n^2+(\\frac{n0}{k}-p_0)n$这显然是一个关于$n$的二次函数 于是用三分法搞一下就可以了 第二问 假设$n_1$确定 那么第二件商品的利润也是个关于$n_2$的二次函数 然后总利润和$n_1$也会是个单峰函数的关系 具体就不证了 所以三分里再套个三分就行了 据说有$O(1)$解法 反正我太蒻了 代码 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n0;double k, p0;inline double calc(int n2, int n1) &#123; double p = (n1 - n2) * 1.0 / k; return n2 * (p - p0);&#125;inline double solve(int n1) &#123; double p = (n0 - n1) * 1.0 / k; int l = 1, r = n0 - n1; while (l &lt; r) &#123; int m1 = l + (r - l) / 3, m2 = m1 + (r - l) / 3 + 1; if (calc(m1, n0 - n1) &lt; calc(m2, n0 - n1)) l = m1 + 1; else r = m2 - 1; &#125; return n1 * (p - p0) + calc(l, n0 - n1);&#125;int main() &#123; scanf(\"%d %lf %lf\", &amp;n0, &amp;p0, &amp;k); printf(\"%.3lf \", solve(0)); int l = 1, r = n0; while (l &lt; r) &#123; int m1 = l + (r - l) / 3, m2 = m1 + (r - l) / 3 + 1; if (solve(m1) &lt; solve(m2)) l = m1 + 1; else r = m2 - 1; &#125; printf(\"%.3lf\", solve(l)); return 0;&#125;","categories":[],"tags":[]},{"title":"Crash的数字表格","slug":"Crash的数字表格","date":"2020-02-25T14:26:32.000Z","updated":"2020-10-08T12:16:07.972Z","comments":true,"path":"post/382e2bdd.html/","link":"","permalink":"http://akdream.tk/post/382e2bdd.html/","excerpt":"","text":"【题目描述】今天的数学课上，Crash小朋友学习了最小公倍数(Least Common Multiple)。对于两个正整数$a$和$b$，$\\operatorname{lcm}(a,b)$表示能同时被$a$和$b$整除的最小正整数。例如，$\\operatorname{lcm}(6,8)$=$24$。回到家后，Crash还在想着课上学的东西，为了研究最小公倍数，他画了一张$N\\times M$的表格。每个格子里写了一个数字，其中第i行第j列的那个格子里写着数为$\\operatorname{lcm}(i,j)$。一个$4\\times 5$的表格如下：$\\begin{matrix}1&amp;2&amp;3&amp;4&amp;5\\2&amp;2&amp;6&amp;4&amp;10\\3&amp;6&amp;3&amp;12&amp;15\\4&amp;4&amp;12&amp;4&amp;20\\ \\end{matrix}$看着这个表格，Crash想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当N和M很大时，Crash就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，Crash只想知道表格里所有数的和$\\operatorname{mod} 20101009$的值。 【输入格式】输入的第一行包含两个正整数，分别表示$N$和$M$。 【输出格式】输出一个正整数，表示表格中所有数的和$\\operatorname{mod} 20101009$的值。 $n \\le 10^7$万幸20101009是个质数 题解 不妨设$n\\le m$ 那就直接开始推式子吧。。。 懵逼警告 需要求的是$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}\\operatorname{lcm}(i,j)$ $=\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}\\frac{i*j}{\\gcd(i,j)}$ 枚举$\\gcd(i,j)$的值 $=\\sum\\limits_{g=1}^{n}\\frac{1}{g}*\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}[\\gcd(i,j)=g]*i*j$ 把后半部分提出来一个$g^2$ $=\\sum\\limits_{g=1}^{n}g*\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{g}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{g}\\rfloor}[\\gcd(i,j)=1]*i*j$ 套用公式$[n=1]=\\sum\\limits_{d|n}\\mu(d)$ $=\\sum\\limits_{g=1}^{n}g*\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{g}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{g}\\rfloor}i*j*\\sum\\limits_{d|\\gcd(i,j)}\\mu(d)$ 如法炮制 枚举$d$的值 $=\\sum\\limits_{g=1}^{n}g*\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{g}\\rfloor}\\mu(d)*\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{g*d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{g*d}\\rfloor}d^2*i*j$ 提出$d^2$ $=\\sum\\limits_{g=1}^{n}g*\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{g}\\rfloor}\\mu(d)*d^2*\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{g*d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{g*d}\\rfloor}i*j$ 后面的两个$\\sum$可以用等差数列求和的方式表示 $=\\sum\\limits_{g=1}^{n}g*\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{g}\\rfloor}\\mu(d)*d^2*\\frac{\\lfloor\\frac{n}{g*d}\\rfloor*(\\lfloor\\frac{n}{g*d}\\rfloor+1)}{2}*\\frac{\\lfloor\\frac{m}{g*d}\\rfloor*(\\lfloor\\frac{m}{g*d}\\rfloor+1)}{2}$ 好了 这个式子就是最终的形式了 观察一下 枚举$g$我们只需要知道$\\frac{n}{g}$及$\\frac{m}{g}$是多少，$\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{g}\\rfloor}\\mu(d)*d^2*\\frac{\\lfloor\\frac{n}{g*d}\\rfloor*(\\lfloor\\frac{n}{g*d}\\rfloor+1)}{2}*\\frac{\\lfloor\\frac{m}{g*d}\\rfloor*(\\lfloor\\frac{m}{g*d}\\rfloor+1)}{2}$这一串就能算出来 所以用数论分块来枚举$g$就可以了 记$\\lfloor\\frac{n}{g}\\rfloor =n_0,\\lfloor\\frac{m}{g}\\rfloor =m_0$ 同理 只需要知道$\\frac{n_0}{d}$和$\\frac{m_0}{d}$， 里面那串$\\frac{\\lfloor\\frac{n}{g*d}\\rfloor*(\\lfloor\\frac{n}{g*d}\\rfloor+1)}{2}*\\frac{\\lfloor\\frac{m}{g*d}\\rfloor*(\\lfloor\\frac{m}{g*d}\\rfloor+1)}{2}$也就能算出来了 所以$d$也可以用数论分块枚举 处理一下$\\mu(d)*d^2$这个东西的前缀和就可以了 时间复杂度是$O(\\sqrt{n}^2)=O(n)$，很完美 注意处理负数$\\mu(d)*d^2$的前缀和会有负数 推导很冗长 代码很简洁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;const ll mod = 20101009;const ll div2 = mod / 2 + 1;ll n, m, ans;bool np[10000005];ll prime[1000005], mob[10000005], sum[10000005], tot;inline void getprime() &#123; mob[1] = 1; for (ll i = 2; i &lt;= max(n, m); i++) &#123; if (!np[i]) prime[++tot] = i, mob[i] = -1; for (ll j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= max(n, m); j++) &#123; np[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; mob[i * prime[j]] = 0; break; &#125; else mob[i * prime[j]] = -mob[i]; &#125; &#125; for (ll i = 1; i &lt;= max(n, m); i++) &#123; sum[i] = (sum[i-1] + i * i % mod * mob[i] % mod) % mod; &#125;&#125;inline ll calc(ll n0, ll m0) &#123; ll ret = 0; for (ll l = 1, r; l &lt;= min(n0, m0); l = r + 1) &#123; r = min(n0 / (n0 / l), m0 / (m0 / l)); ll s = (sum[r] - sum[l-1] + mod) % mod; ll s1 = (n0 / l) * (n0 / l + 1) % mod * div2 % mod, s2 = (m0 / l) * (m0 / l + 1) % mod * div2 % mod; ret = ((ret + s * s1 % mod * s2 % mod) % mod + mod) % mod; &#125; return ret;&#125;int main() &#123; n = read(); m = read(); getprime(); for (ll l = 1, r; l &lt;= min(n, m); l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans = (((r - l + 1) * (r + l) % mod * div2 % mod * calc(n / l, m / l) % mod + ans) % mod + mod) % mod; &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[],"tags":[{"name":"莫比乌斯函数","slug":"莫比乌斯函数","permalink":"http://akdream.tk/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"}]},{"title":"诗人小G[NOI2009]","slug":"诗人小G[NOI2009]","date":"2020-02-25T13:34:34.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/19c5fc9e.html/","link":"","permalink":"http://akdream.tk/post/19c5fc9e.html/","excerpt":"","text":"【题目描述】小 G 是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。 一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 G 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 G 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 G 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的$P$次方，而一个排版的不协调度为所有行不协调度的总和。 小 G 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。 【输入格式】 展开题目描述小 G 是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。 一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 G 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 G 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 G 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的 PP 次方，而一个排版的不协调度为所有行不协调度的总和。 小 G 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。 【输入格式】输入文件中的第一行为一个整数$T$，表示诗的数量。 接下来为$T$首诗，这里一首诗即为一组测试数据。每组测试数据中的第一行为三个由空格分隔的正整数$N,L,P$，其中：$N$表示这首诗句子的数目，$L$表示这首诗的行标准长度，$P$的含义见问题描述。 从第二行开始，每行为一个句子，句子由英文字母、数字、标点符号等符号组成（ASCII 码$33～127$，但不包含 -）。 【输出格式】于每组测试数据，若最小的不协调度不超过$10^{18}$，则第一行为一个数，表示不协调度。接下来若干行，表示你排版之后的诗。注意：在同一行的相邻两个句子之间需要用一个空格分开。 如果有多个可行解，它们的不协调度都是最小值，则输出任意一个解均可。若最小的不协调度超过$10^{18}$，则输出 Too hard to arrange。每组测试数据结束后输出 --------------------，共20个 -，- 的 ASCII 码为 45，请勿输出多余的空行或者空格。 $n\\le 10^5, l\\le 3*10^6, p\\le 10$ 题解 记$sum[i]$为前$i$句的长度和，$dp[i]$为前$i$句的最小不协调度。 有一个显而易见的DP方程： $dp[i]=\\min\\limits_{j=1}^{i-1}(dp[j]+|sum[i]-sum[j]+(i-j-1)-l|^p)$ 直接DP显然是$O(n^2)$的 对于这道题我们实际上可以使用决策单调性优化复杂度。 注意到上面的那个转移方程 每个$dp[i]$通过枚举前面的$i-1$个$j$取最小得到 我们把$dp[i]$取到最小的那个$j$记为$p[i]$，这个东西就叫决策。 如果一个DP满足决策单调性，这就是说这个DP满足$p[1]\\le p[2]\\le \\cdots \\le p[n]$。 怎么证明一个DP方程是否满足决策单调性？ 一个DP方程可以表示成$dp[i]=\\min\\limits_{j=1}^{i-1}(dp[j]+w(j,i))$ (这道题中$w(j,i)=|sum[i]-sum[j]+(i-j-1)-l|^p$) ，且对于任意的整数$a,b(a&lt;b)$，都有$w(a,b+1)+w(a+1,b)\\ge w(a,b)+w(a+1,b+1)$，那么这个DP方程满足决策单调性。 这道题的DP是满足决策单调性的，证明太长不证了，可以由打表得出结论。 那么这有什么好处呢 我们把最终的$p$数组列出来，大概就长这样：$1,1,2,2,3,3,3,\\cdots$ 因为它是单调不降的 所以我们可以二分出 对于两个数$a,b$，从哪个$dp[i]$开始 用$a$作为$dp[i]$的决策 不如 用$b$作为$dp[i]$的决策。 比如上面那个$p$数组的例子 从$dp[5]$开始 以$2$作为决策就不如$3$了 那么我们就可以通过维护一个单调队列来维护枚举到的$dp[i]$的最优决策是什么了 队列中的每个元素维护两个值 一个是下标$id$，另一个数$st$表示从$dp[st[i]]$开始到$dp[st[i+1]-1]$为止 决策选择$id[i]$是最优的 具体的说 假设现在正在计算$dp[5]$，$p$数组前四个是$1,1,1,2$那么队列里可能会是这样： 第一个元素$id[1]=1$$st[1]=1$表示从$dp[st[1]]$开始 到$dp[st[2]-1]$为止 选择$1$为决策最优 第二个元素$id[2]=2$$st[2]=4$同理 那么现在要推出$dp[5]$由于选择$1$为决策最优的范围是$st[1]\\sim st[2]$也就是$1\\sim 4$那么决策$1$对$dp[5]$已经没用了 所以从队头弹出。 此时队头元素的$id$是$2$那么就表明$p[5]=2$$dp[5]$从$dp[2]$转移过来最优 我们让$dp[5]=dp[2]+|sum[5]-sum[2]+(5-2-1)-l|^p$ 然后我们要看看$5$作为决策会不会比$2$好 由于决策单调性 我们可以二分出$l(l&gt;5)$表示从$l$开始 决策选择$5$比选择$2$更优 如果此时$l&lt;st[2]$那就说明$5$整个就是比$2$要优的 直接把$2$从队尾弹出 把所有要弹的弹出去之后 就在队尾插入这个新增的元素 基本就和普通的单调队列差不多吧。。。 请结合代码食用(感觉代码写的还是很易懂的) 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long double db;int ttt, n, L, p, sum[100005], ans[100005]; char s[100005][40];int q[100005], st[100005], head, tail;db dp[100005];inline db fpow(db x, int t) &#123; db ret = 1.0; for (; t; t &gt;&gt;= 1, x *= x) if (t &amp; 1) ret *= x; return ret;&#125;inline db cal(int j, int i) &#123; return dp[j] + fpow(fabs(sum[i] - sum[j] + (i - j - 1) - L), p);&#125;inline int find(int j, int i) &#123; if (cal(j, n) &lt; cal(i, n)) return n + 1; int l = i, r = n, mid, anss; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (cal(j, mid) &gt;= cal(i, mid)) &#123; anss = mid; r = mid - 1; &#125; else l = mid + 1; &#125; return anss;&#125; int main() &#123; scanf(\"%d\", &amp;ttt); while (ttt--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;L, &amp;p); for (int i = 1; i &lt;= n; i++) scanf(\"%s\", s[i]+1), sum[i] = sum[i-1] + strlen(s[i]+1); head = 1, q[tail=1] = 0, st[1] = 1; for (int i = 1; i &lt;= n; i++) &#123; while (head &lt; tail &amp;&amp; st[head+1] &lt;= i) head++; //把 当前head覆盖区间整个都在i前面的head弹出 ans[i] = q[head]; dp[i] = cal(q[head], i); while (head &lt; tail &amp;&amp; st[tail] &gt;= find(q[tail], i)) tail--; //把 当前tail覆盖区间内的全部dp[j] 通过id[tail]转移都不如通过i转移 的tail弹出 q[++tail] = i; st[tail] = find(q[tail-1], q[tail]); &#125; if (dp[n] &gt; 1e18) puts(\"Too hard to arrange\"); else &#123; printf(\"%lld\\n\", (long long)dp[n]); tail = 0; for (int i = n; i; i = ans[i]) &#123; q[++tail] = i; &#125; head = tail; for (int i = 1; i &lt;= n; i++) &#123; printf(\"%s\", s[i]+1); if (i == q[head]) &#123; head--; puts(\"\"); &#125; else putchar(' '); &#125; &#125; puts(\"--------------------\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Video Game Combos [USACO2012]","slug":"Video Game Combos [USACO2012]","date":"2020-02-19T12:21:52.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/311a1e1e.html/","link":"","permalink":"http://akdream.tk/post/311a1e1e.html/","excerpt":"","text":"【题目描述】贝西在玩一款游戏，该游戏只有三个技能键$\\texttt{A,B,C}$可用，但这些键可用形成N种($1 \\le N\\le 20$)特定的组合技。第$i$个组合技用一个长度为$1$到$15$的字符串$S_i$表示。 当贝西输入的一个字符序列和一个组合技匹配的时候，他将获得$1$分。特殊的，他输入的一个字符序列有可能同时和若干个组合技匹配，比如$N=3$时，3种组合技分别为”$\\texttt{ABA}$”, “$\\texttt{CB}$”, 和”$\\texttt{ABACB}$”,若贝西输入”$\\texttt{ABACB}$”，他将获得$3$分。 若贝西输入恰好$K$($1 \\le K \\le 1000)$个字符，他最多能获得多少分？ 【输入格式】第一行包含两个整数$N$和$K$ 接下来$N+1$行，第$i+1$行包含字符串$S_i$ 【输出格式】输出最大获得多少分。 题解 发现是要你构造一个长串去匹配若干给出的串 所以自然想到AC自动机 设$\\operatorname{f}(x)$为 x到根的fail链上的 打了结束标记的点个数。 假设把那个长串给你了 那匹配套路无非就是在AC自动机上跳 每跳到一个点x 分数就加上$\\operatorname{f}(x)$。(如果不懂请去学刁一下AC自动机) 那反正这$N$个串是不会变了 所以建好AC自动机之后把每个点x的$\\operatorname{f}(x)$预处理出来 然后显然是个DP 设$dp[i][j]$表示 枚举到答案串的第$i$位，最后一位在AC自动机的$j$号节点上 转移方程就是枚举$i,j$枚举$k\\in [0,25]$表示枚举到的字母$dp[i+1][j] = max(dp[i+1][son[j][k]], dp[i][j]+f(son[j][k]))$ 不需要特判什么$son[j][k]=0$之类的 答案串一直在节点0打转也是无所谓的 不影响DP 影响DP的是 有些状态$dp[i][j]$是无法到达的 所以我们先把整个dp数组设为$-1$然后让$dp[0][0]=0$如果枚举到$i,j\\ \\ dp[i][j]=-1$那就表示这个状态无法到达 要跳过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;int n, m; char s[30];int ch[10005][30], fail[10005], val[10005], tot;int dp[1005][1005];bool tag[100005];inline void insert(char *str, int l) &#123; int x = 0; for (int i = 1; i &lt;= l; i++) &#123; if (!ch[x][str[i] - 'A']) &#123; ch[x][str[i] - 'A'] = ++tot; &#125; x = ch[x][str[i] - 'A']; &#125; tag[x] = 1;&#125;queue&lt;int&gt; q;inline void getfail() &#123; for (int i = 0; i &lt; 26; i++) if (ch[0][i]) q.push(ch[0][i]); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (ch[x][i]) fail[ch[x][i]] = ch[fail[x]][i], q.push(ch[x][i]); else ch[x][i] = ch[fail[x]][i]; &#125; &#125;&#125;inline void calc() &#123; for (int i = 0; i &lt;= tot; i++) &#123; for (int j = i; j; j = fail[j]) &#123; if (tag[j]) val[i]++; &#125; &#125;&#125;inline void DP() &#123; memset(dp, -1, sizeof(dp)); dp[0][0] = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt;= tot; j++) &#123; if (dp[i][j] == -1) continue; for (int k = 0; k &lt; 26; k++) &#123; dp[i+1][ch[j][k]] = max(dp[i+1][ch[j][k]], dp[i][j] + val[ch[j][k]]); &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", s+1); insert(s, strlen(s+1)); &#125; getfail(); calc(); DP(); int ans = 0; for (int i = 0; i &lt;= tot; i++) &#123; ans = max(ans, dp[m][i]); &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://akdream.tk/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"完全平方数[中山市选2011]","slug":"完全平方数[中山市选2011]","date":"2020-02-18T14:05:41.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/89c52e04.html/","link":"","permalink":"http://akdream.tk/post/89c52e04.html/","excerpt":"","text":"【题目描述】小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第 K个数送给了小X。小X很开心地收下了。然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？ 【输入格式】包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 【输出格式】含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。 这种题一眼二分答案啊QWQ 然后问题就变成求1~x中有多少个合法的数了 当然是总数减不合法的 看一下不合法的怎么算 首先$4=2^2$的倍数都不合法 减掉$\\lfloor \\frac{n}{4} \\rfloor$然后$9=3^2$也不合法 减掉$\\lfloor \\frac{n}{9} \\rfloor$$16$呢？显然$4$的时候已经算过了 跳过$25$我们也跳过了 重点看一下$36$注意到$36$的倍数在$4$和$9$的时候都被减了一次(因为$6=2 * 3$，所以$6^2=2^2 * 3^2$) 因为容斥 我们反而要加回来一个$\\lfloor \\frac{n}{36} \\rfloor$ 再看看我们做了哪些运算：$+ \\lfloor \\frac{n}{4} \\rfloor * (-1) + \\lfloor \\frac{n}{9} \\rfloor * (-1) + \\lfloor \\frac{n}{16} \\rfloor * 0 + \\lfloor \\frac{n}{25} \\rfloor * (-1) + \\lfloor \\frac{n}{36} \\rfloor * 1$ 然后我们发现了美妙性质：$1\\sim x$中合法的数的个数$=x-\\sum\\limits_{i=1}^x \\mu(i)*\\lfloor \\frac{n}{i^2} \\rfloor$ 没毛病 然后质数筛预处理一下莫比乌斯函数 二分$r$开到$2*10^{9}$就够了 时间复杂度$O(\\sqrt{K} \\log{K})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;ll t, n; ll prime[100005], tot, mobius[100005];bool np[100005];inline void init() &#123; mobius[1] = 1; for (ll i = 2; i &lt;= 100000; i++) &#123; if (!np[i]) &#123; prime[++tot] = i; mobius[i] = -1; &#125; for (ll j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 100000; j++) &#123; np[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; mobius[i * prime[j]] = 0; break; &#125; else mobius[i * prime[j]] = -mobius[i]; &#125; &#125;&#125;inline bool check(ll x) &#123; ll sum = x; for (ll i = 2; i * i &lt;= x; i++) &#123; sum += mobius[i] * (x / (i * i)); &#125; return sum &gt;= n;&#125;int main() &#123; t = read(); init(); while (t--) &#123; n = read(); ll l = 1, r = 10000000000, mid, ans; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://akdream.tk/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯函数","slug":"莫比乌斯函数","permalink":"http://akdream.tk/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"},{"name":"二分答案","slug":"二分答案","permalink":"http://akdream.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]},{"title":"Color[POJ2154]","slug":"Color[POJ2154]","date":"2020-02-14T14:08:47.000Z","updated":"2020-10-08T12:16:07.948Z","comments":true,"path":"post/7faf3f44.html/","link":"","permalink":"http://akdream.tk/post/7faf3f44.html/","excerpt":"","text":"【题目描述】一串项链上有$n$颗珠子，用$n$种颜色给它们染色(不一定都要用到)，有多少种方案？通过已有方案进行旋转得到的染色方案不算。答案对$p$取模。 【输入格式】两个整数$n,p$。 【输出格式】一行一个整数表示总方案数模$p$。 $n\\le 10^9$ 题解 $\\operatorname{Burnside}$引理 设$A$和$B$为有限集合，$X$表示所有从$A$到$B$的映射集合(着色方案集合)。$G$是一个置换群，$X/G$表示$X$所有元素的轨道的集合(去重)，$X^g$表示$X$中在某个$G$中置换$g$作用下的不动元素集合，则有$$|X/G|=\\frac{1}{|G|}\\sum\\limits_{g\\in G}|X^g|$$ 看不懂没关系 用人话解释一下 比如给一个正方形的4个顶点染2种颜色 $X$是着色方案集合 这里先不考虑重复 每个点都有两种颜色可染 所以着色方案有$2^4=16$种 这里我们可以把这个正方形旋转0°,90°,180°或270°,所以$G$就是{旋转0°,旋转90°,旋转180°,旋转270°}。 先算一下$X^{g_1}$也就是旋转0°后 16种方案里有多少种4个角的颜色相对没变的 然而旋转0°也就是不旋转 16种都不会变 $X^{g_2}$旋转90°呢 只有2种 就是4个顶点颜色都一样的2种 $X^{g_3}=4$旋转180°时$\\texttt{RRRR}\\quad\\texttt{BBBB}\\quad\\texttt{RBRB}\\quad\\texttt{BRBR}$都是合法的 $X^{g_4}$同$X^{g_2}$。 所以此题答案是$\\frac{1}{4}(16+2+4+2)=6$！！！ 但是集合$G$的大小是$n$级别的 集合$X$的大小更是指数级的 我们也不知道怎么计算$X^g$ 于是我们需要用到$\\operatorname{Polya}$定理 先简单介绍一下什么是置换 $$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 3 &amp; 1 &amp; 2 &amp; 4 \\end{pmatrix}$$ 这个置换是上下对应的 表示把$1$的颜色给$3$，把$2$的颜色给$1$，把$3$的颜色给$2$，把$4$的颜色给$4$。 所以如果把正方形的四个顶点顺时针顺序标为$1,2,3,4$ 那么顺时针旋转90°就对应这样的一个置换： $$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 2 &amp; 3 &amp; 4 &amp; 1 \\end{pmatrix}$$ 任意一个置换都能分解成若干个循环置换的乘积 什么又是循环置换？(不想写了放张图) 嗯$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\ 3 &amp; 1 &amp; 2 &amp; 5 &amp; 4 \\end{pmatrix}$就是这两个循环置换合在一起 这个循环置换$\\begin{pmatrix}1 &amp; 3 &amp; 2 \\ 3 &amp; 2 &amp; 1 \\end{pmatrix}$按顺序排一下也就是$\\begin{pmatrix}1 &amp; 2 &amp; 3 \\ 3 &amp; 1 &amp; 2 \\end{pmatrix}$和这个循环置换$\\begin{pmatrix}4 &amp; 5 \\ 5 &amp; 4 \\end{pmatrix}$ 然后回到刚才那个引理 一个置换$g$可以表示为若干个循环置换的乘积 然而对于每个循环置换 这个循环置换里的每个元素 的颜色 必须全部一样 才能保证经过置换后每个元素的颜色都不变(这个不好理解) 设$m$是颜色种类数$c(g)$是$g$最多被分解成几个循环置换的乘积 那么有$|X^g|=m^{c(g)}$ 把这个代入刚才那个$\\operatorname{Burnside}$引理 得到$\\operatorname{Polya}$定理： $$|X/G|=\\frac{1}{|G|}\\sum\\limits_{g\\in G}m^{c(g)}$$ 看一下刚才那个正方形的例子$g_1$是$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 1 &amp; 2 &amp; 3 &amp; 4 \\end{pmatrix}$那么$c(g_1)$是$4$总之自己算一下得到$c(g_2)=1$，$c(g_3)=2$，$c(g_4)=1$答案就和刚才一样$\\frac{1}{4}(2^4+2^1+2^2+2^1)=6$ 那么这题怎么办呢 集合$G$很容易找 就是顺时针旋转过$1\\sim n$个珠子(旋转过$n$个就是没旋转) 所以$|G|=n$。 找找规律 发现顺时针旋转$i$个珠子得到的置换最多能被分解成$\\gcd(i,n)$个循环置换(原因我也忘了) 所以枚举$n$的因数$d$表示$\\gcd(i,n)=d$那么一定有$\\gcd(\\frac{i}{d},\\frac{n}{d})=1$且$\\frac{i}{d}\\le \\frac{n}{d}$ 所以$\\gcd(i,n)=d$的$1\\le i\\le n$的个数就是$\\varphi(\\frac{n}{d})$(欧拉函数) 答案就是$$\\frac{1}{n}\\sum\\limits_{d|n}n^d\\varphi(\\frac{n}{d})$$ 预处理一下质数 时间复杂度据说是$O(n^{0.75})$？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int ttt, n, mod, tot;int prime[40005], pr;bool np[40005];inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;void write(int x) &#123; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;inline void getprime() &#123; for (int i = 2; i &lt;= 36000; i++) &#123; if (!np[i]) &#123; prime[++pr] = i; &#125; for (int j = 1; j &lt;= pr &amp;&amp; (i * prime[j] &lt;= 36000); j++) &#123; np[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;inline int getphi(int x) &#123; int ret = x; for (int i = 1; prime[i] * prime[i] &lt;= x; i++) &#123; if (x % prime[i] == 0) &#123; ret = ret - ret / prime[i]; while (x % prime[i] == 0) x /= prime[i]; &#125; &#125; if (x &gt; 1) &#123; ret = ret - ret / x; &#125; return ret % mod;&#125;inline int fpow(int x, int t) &#123; int ret = 1; x %= mod; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;inline int solve(int x) &#123; int ret = 0; for (int i = 1; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; ret = (ret + fpow(x, i - 1) * getphi(x / i) % mod) % mod; if (x != i * i) &#123; ret = (ret + fpow(x, x / i - 1) * getphi(i) % mod) % mod; &#125; &#125; &#125; return ret;&#125;int main() &#123; ttt = read(); getprime(); while (ttt--) &#123; n = read(); mod = read(); write(solve(n)); puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://akdream.tk/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"病毒「POI 2000」","slug":"病毒「POI 2000」","date":"2020-02-13T04:58:15.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/690c88db.html/","link":"","permalink":"http://akdream.tk/post/690c88db.html/","excerpt":"","text":"【题目描述】 二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。 示例：例如如果${011, 11, 00000}$为病毒代码段，那么一个可能的无限长安全代码就是$010101\\cdots$。如果${01, 11, 000000}$为病毒代码段，那么就不存在一个无限长的安全代码。 请写一个程序，读入病毒代码，判断是否存在一个无限长的安全代码，将结果输出。 【输入格式】 第一行包括一个整数$n$，表示病毒代码段的数目；以下的$n$行，每一行都包括一个非空的$01$字符串——就是一个病毒代码段。 【输出格式】假如存在这样的代码，则输出 TAK，否则输出 NIE。 题解 由于是AC自动机专题 所以我们不妨考虑一下怎么用AC自动机解决 显而易见 这个无限长的$01$串应该是有循环节的 把$n$个危险串插入AC自动机 在结束节点打标记 那么当你在AC自动机上对这个$01$循环串做匹配的时候，当前指针走的应该也是循环，并且 沿途经过的节点 以及 每个经过节点到根的fail链上 都没有结束节点 因为用AC自动机做匹配的时候不是走到每个节点都要跳fail 如果跳到有结束tag的就(文章包含单词数)+1吗 而这里我们希望它为0 所以我们把所有 有结束tag的节点 及 这个节点到根的fail链上有结束节点 的节点删掉(设为不可用) 然后在剩下的节点构成的这个不完整的AC自动机里找环 如果找得到就是有解 否则无解 找环像找强连通分量那么找就行 或者就dfs一下也行 注意特判一下自环 【代码】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;int n, len;char s[100005];int ch[100005][2], fail[100005], tot;bool tag[100005];inline void insert(char *str, int l) &#123; int x = 0; for (int i = 1; i &lt;= l; i++) &#123; if (!ch[x][str[i] - '0']) &#123; ch[x][str[i] - '0'] = ++tot; &#125; x = ch[x][str[i] - '0']; &#125; tag[x] = 1;&#125;queue&lt;int&gt; q;inline void getfail() &#123; for (int i = 0; i &lt; 2; i++) if (ch[0][i]) q.push(ch[0][i]); while (!q.empty()) &#123; int x = q.front(); q.pop(); tag[x] |= tag[fail[x]]; for (int i = 0; i &lt; 2; i++) &#123; if (ch[x][i]) fail[ch[x][i]] = ch[fail[x]][i], q.push(ch[x][i]); else ch[x][i] = ch[fail[x]][i]; &#125; &#125;&#125;int dfn[30005], low[30005], stk[30005], tme, top;bool vis[30005], flag;void tarjan(int x) &#123; dfn[x] = low[x] = ++tme; vis[x] = 1; stk[++top] = x; for (int i = 0; i &lt; 2; i++) &#123; if (tag[ch[x][i]]) continue; int y = ch[x][i]; if (x == y) flag = 1; if (!dfn[y]) &#123; tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (vis[y]) &#123; low[x] = min(low[x], dfn[y]); &#125; &#125; if (dfn[x] == low[x]) &#123; int now = 0, totot = 0; do &#123; now = stk[top--]; vis[now] = 0; totot++; &#125; while (now != x); if (totot &gt; 1) flag = 1; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; memset(s, 0, sizeof(s)); scanf(\"%s\", s+1); len = strlen(s+1); insert(s, len); &#125; getfail(); flag = 0; tarjan(0); if (flag) puts(\"TAK\"); else puts(\"NIE\"); return 0;&#125;","categories":[],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"http://akdream.tk/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"单词「TJOI 2013」","slug":"单词「TJOI 2013」","date":"2020-02-13T04:43:30.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/a3530162.html/","link":"","permalink":"http://akdream.tk/post/a3530162.html/","excerpt":"","text":"【题目描述】某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。 【输入格式】第一个一个整数$N$，表示有多少个单词，接下来$N$行每行一个单词。 【输出格式】输出$N$个整数，第$i$行的数字表示第$i$个单词在文章中出现了多少次。 对于全部数据，$1\\le N\\le 200$，所有单词长度的和不超过$10^6$，保证每个单词由小写字母组成。 题解 这道题题目意思让我看半天 总之就是每个输入的单词同样也作为一篇文章 然后最后要你统计 每个词 在 所有词 中共出现了多少次 比如样例 12343aaaaaa 串$aa$在$a$中出现$0$次 在$aa$中出现$1$次 在$aaa$中出现$2$次 所以是$0+1+2=3$ 作为一道AC自动机的模板题，这道题在BZOJ上时限给了10s。。。 实际上不用这么宽的时限 1s就够了 首先先建好AC自动机 查询每个单词在文章中出现次数 一般我们会维护一个指针在AC自动机上跟着文章的字母走 然后每走一个字母都要暴力跳fail统计答案 然而很容易发现这样做的弊端：如果重复经过了AC自动机的同一个节点$k$次 那么就要重复跳$k$次同样的fail链每次加$1$不如到最后文章遍历结束后再进行统计 所以就把沿路经过的节点$val+1$，相当于打上一个标记 最后在fail树上累加一下$x$的子树和就是$x$代表的串出现多少次 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define re registerusing namespace std;int ans[1000005];int n, m, len;string s[1000005];struct AC_automaton&#123; int ch[1000005][30], fail[1000005], val[1000005], f[1000005], tot; vector&lt;int&gt; tag[1000005]; inline int o(char c) &#123; return c - 'a'; &#125; inline void insert(string str, int id) &#123; int x = 0; for (re int i = 0; i &lt; str.size(); i++) &#123; if (!ch[x][o(str[i])]) &#123; ch[x][o(str[i])] = ++tot; &#125; x = ch[x][o(str[i])]; &#125; tag[x].push_back(id); &#125; queue&lt;int&gt; q; inline void getfail() &#123; while (!q.empty()) q.pop(); for (re int i = 0; i &lt; 26; i++) if (ch[0][i]) q.push(ch[0][i]); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (re int i = 0; i &lt; 26; i++) &#123; if (ch[x][i]) fail[ch[x][i]] = ch[fail[x]][i], q.push(ch[x][i]); else ch[x][i] = ch[fail[x]][i]; &#125; &#125; &#125; inline void solve(string str) &#123; int now = 0; for (re int i = 0; i &lt; str.size(); i++) &#123; now = ch[now][o(str[i])]; val[now]++; &#125; &#125; int in[1000005], b[1000005], cnt; inline void toposort() &#123; while (!q.empty()) q.pop(); for (int i = 1; i &lt;= tot; i++) &#123; in[fail[i]]++; &#125; for (int i = 0; i &lt;= tot; i++) &#123; if (!in[i]) q.push(i); &#125; while (!q.empty()) &#123; int x = q.front(); q.pop(); b[++cnt] = x; in[fail[x]]--; if (!in[fail[x]]) q.push(fail[x]); &#125; &#125; inline void getans() &#123; toposort(); //拓扑排序完后直接累加就可以了 for (int i = 1; i &lt;= cnt; i++) &#123; int x = b[i]; if (x != 0) val[fail[x]] += val[x]; &#125; for (int i = 0; i &lt;= tot; i++) &#123; for (int j = 0; j &lt; tag[i].size(); j++) &#123; ans[tag[i][j]] += val[i]; &#125; &#125; &#125;&#125; T;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (re int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; T.insert(s[i], i); &#125; T.getfail(); for (re int i = 1; i &lt;= n; i++) &#123; T.solve(s[i]); &#125; T.getans(); for (re int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"http://akdream.tk/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://akdream.tk/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"储能表[SDOI2016]","slug":"储能表[SDOI2016]","date":"2020-02-13T04:27:26.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/e9afbe69.html/","link":"","permalink":"http://akdream.tk/post/e9afbe69.html/","excerpt":"","text":"【题目描述】有一个$n$行$m$列的表格，行从$0$到$n-1$编号，列从$0$到$m-1$编号。每个格子都储存着能量。最初，第$i$行第$j$列的格子储存着$(i\\ \\text{xor}\\ j)$点能量。所以，整个表格储存的总能量是: $\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}(i\\ \\text{xor}\\ j)$ 随着时间的推移，格子中的能量会渐渐减少。一个时间单位后，每个格子中的能量都会减少$1$。显然，一个格子的能量减少到$0$之后就不会再减少了。也就是说，$k$个时间单位后，整个表格储存的总能量是： $\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}max((i\\ xor\\ j)-k,0)$ 给出一个表格，求$k$个时间单位后它储存的总能量。由于总能量可能较大，输出时对$p$取模。 题解 先把原式拆开 原式=所有满足(i^j)&gt;k 的(i^j)之和 - 所有满足(i^j)&gt;k 的数对(i,j)的数量 * k 可以使用数位DP来求解有多少对(i,j)满足(i^j)&gt;k 以及 它们的(i^j)之和是多少 具体做法就是记忆化搜索 记录$limn, limm, limk$分别表示当前枚举二进制前$i$位，是否卡满$n,m$上界以及$k$下界 这个东西我也不知道怎么讲清楚 不是数位DP的基本套路吗 我用了个pair来存DP答案 first存的是有多少对满足条件 second存的是满足条件的(i^j)之和 注意取模 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define mp make_pairusing namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pii;inline ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;ll t, n, m, k, mod, mx;pii dp[105][2][2][2], ans;bool vis[105][2][2][2];inline ll getl(ll x) &#123; ll ret = 0; while (x) ret++, x &gt;&gt;= 1; return ret;&#125;pii dfs(ll d, bool limn, bool limm, bool limk) &#123; if (d &gt; mx) return mp(1, 0); if (vis[d][limn][limm][limk]) return dp[d][limn][limm][limk]; ll N = (n&gt;&gt;(mx-d)) &amp; 1, M = (m&gt;&gt;(mx-d)) &amp; 1, K = (k&gt;&gt;(mx-d)) &amp; 1; for (ll i = 0; i &lt;= (limn ? N : 1); i++) &#123; for (ll j = 0; j &lt;= (limm ? M : 1); j++) &#123; if (limk &amp;&amp; (i^j) &lt; K) continue; pii res = dfs(d+1, limn&amp;&amp;(i==N), limm&amp;&amp;(j==M), limk&amp;&amp;((i^j)==K)); dp[d][limn][limm][limk].first = (dp[d][limn][limm][limk].first + res.first) % mod; dp[d][limn][limm][limk].second = (((dp[d][limn][limm][limk].second + res.second) % mod) + (1ll &lt;&lt; (mx - d)) * (i^j) % mod * res.first % mod) % mod; &#125; &#125; vis[d][limn][limm][limk] = true; return dp[d][limn][limm][limk];&#125;int main() &#123; t = read(); while (t--) &#123; n = read(); m = read(); k = read(); mod = read(); n--, m--; memset(dp, 0, sizeof(dp)); memset(vis, 0, sizeof(vis)); mx = max(max(getl(n), getl(m)), getl(k)); ans = dfs(1, 1, 1, 1); printf(\"%lld\\n\", (ans.second - k % mod * ans.first % mod + mod) % mod); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"欢迎来到蒟蒻LK的博客","slug":"欢迎来到蒟蒻LK的博客","date":"2020-02-12T06:13:04.000Z","updated":"2020-03-13T04:46:50.000Z","comments":true,"path":"post/aa87bd07.html/","link":"","permalink":"http://akdream.tk/post/aa87bd07.html/","excerpt":"","text":"2020.2.11 花了一个下午建站，找域名，搬运博客，修复bug，基本上建好了 2020.2.12 修复gitalk，修复音乐播放器(然而还是有问题) 增加tags页面，增加friends页面 2020.2.13 修复音乐播放器 将以前的博客全部copy到这里 2020.2.14 增加RSS订阅功能(不知道有什么用) 2020.2.15 增加Progress Bar 2020.3.11 更换新头像 2020.3.13 增加pjax","categories":[],"tags":[]},{"title":"同类分布[AHOI2009]","slug":"同类分布[AHOI2009]","date":"2020-02-06T06:54:35.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/a604e319.html/","link":"","permalink":"http://akdream.tk/post/a604e319.html/","excerpt":"","text":"【题目描述】给出两个数$a,b$，求出$[a,b]$中各位数字之和能整除原数的数的个数。 【输入格式】一行，两个整数$a$和$b$($a,b\\le 10^{18}$) 【输出格式】一个整数，表示答案 题解 数位DP的一般思想就是表示状态，然后记忆化搜索 由于整除这个操作不太好处理，而$10^{18}$以内的数的数字和是不会超过$9*18=162$的 所以可以先枚举最终的数字和 考虑子状态需要记录哪些信息以便进行记忆化搜索 假设现在枚举到的最终数字和为$m$从高到低按数位搜索设当前枚举到数的前$k$位，数字和为$sum$，这个$k$位数模$m$余$r$。如果两个$k$位数的$sum,r$都相同，其实后面能填的数字也会是一样的，就可以进行记忆化。 举例来说，$m=20$，枚举到第3位$163??$和$523??$163和523模20同余，数字和也均为10那么后两位能填的数也会一样 不需要再搜索$523??$而是只用返回$163??$的结果 枚举$m$子状态就是$dp[i][j][k]$表示枚举到前i位，数字和为j，这个i位数模m余k 最后用$1\\sim r$的减掉$1\\sim l-1$的即可 时间复杂度$O(162^3*数位个数)$ 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, b, ans, ans2;ll num[20], len, mod;ll dp[20][200][200];inline void getnum(ll x) &#123; len = 0; while (x) &#123; num[++len] = x % 10; x /= 10; &#125;&#125;ll dfs(ll d, ll sum, ll m, ll lim) &#123; if (d &lt;= 0) &#123; return (m == 0 &amp;&amp; sum == mod ? 1 : 0); &#125; if (!lim &amp;&amp; ~dp[d][sum][m]) return dp[d][sum][m]; ll ret = 0, mx = lim ? num[d] : 9; for (int i = 0; i &lt;= mx; i++) &#123; ret += dfs(d-1, sum+i, (m*10+i)%mod, lim &amp;&amp; i == mx); &#125; if (!lim) dp[d][sum][m] = ret; return ret;&#125;ll work(ll x) &#123; if (!x) return 0; getnum(x); ll ret = 0; for (int i = 1; i &lt;= 9 * len; i++) &#123; mod = i; memset(dp, -1, sizeof(dp)); ret += dfs(len, 0, 0, 1); &#125; return ret;&#125;int main() &#123; scanf(\"%lld %lld\", &amp;a, &amp;b); ans = work(a-1); ans2 = work(b); printf(\"%lld\\n\", ans2 - ans); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"L语言","slug":"L语言[HNOI2004]","date":"2020-02-05T12:50:44.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/8531a4da.html/","link":"","permalink":"http://akdream.tk/post/8531a4da.html/","excerpt":"","text":"【题目描述】标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。 一段文章$T$是由若干小写字母构成。一个单词$W$也是由若干小写字母构成。一个字典$D$是若干个单词的集合。 我们称一段文章$T$在某个字典$D$下是可以被理解的，是指如果文章$T$可以被分成若干部分，且每一个部分都是字典$D$中的单词。 例如字典$D$中包括单词 is , your , what , name ，则文章 whatisyourname 是在字典$D$下可以被理解的，因为它可以分成 4 个单词： what , is , your , name ，且每个单词都属于字典$D$，而文章 whatisyouname 在字典$D$下不能被理解，但可以在字典 D’=D+D’=D+you 下被理解。这段文章的一个前缀 whatis ，也可以在字典$D$下被理解，而且是在字典$D$下能够被理解的最长的前缀。 给定一个字典$D$，你的程序需要判断若干段文章在字典$D$下是否能够被理解。 并给出其在字典$D$下能够被理解的最长前缀的位置。 【输入格式】输入文件第一行是两个正整数$n$和$m$，表示字典$D$中有$n$个单词，且有$m$段文章需要被处理。 之后的$n$行每行描述一个单词，再之后的$m$行每行描述一段文章。 【输出格式】对于输入的每一段文章，你需要输出这段文章在字典$D$可以被理解的最长前缀的位置。 题解 朴素想法就是在Trie上一直尽量向下匹配，然后失配了就从失配的地方开始重新从根匹配，然而这个错了 反例很好找 123453 1roadyouyouryouroad 这样暴力匹配的话到了your会失配 然后并没有与oad匹配的词但是youroad应该是能被全部理解的 所以我们发现对于每个能成功匹配的前缀，都要从它后面开始搜一次这个例子中前缀13及14都是能匹配上的 如果从1~3后面 即4开始搜的话就能全部匹配 所以记录一个ok数组$ok[i]$表示$1\\sim i$的前缀能成功匹配 时间复杂度$O(玄学)$蒟蒻不会分析 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;char s[1000005];int n, m, tr[10005][30], tag[10005], tot, len; bool ok[1000005];inline void insert(char *str, int l) &#123; int now = 0; for (int i = 1; i &lt;= l; i++) &#123; if (!tr[now][str[i]-'a']) tr[now][str[i]-'a'] = ++tot; now = tr[now][str[i]-'a']; &#125; tag[now] = 1;&#125;inline void query(char *str, int st, int l) &#123; int now = 0; for (int i = st; i &lt;= l; i++) &#123; if (!tr[now][str[i]-'a']) break; now = tr[now][str[i]-'a']; if (tag[now]) ok[i] = 1; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", s+1); len = strlen(s+1); insert(s, len); &#125; for (int i = 1; i &lt;= m; i++) &#123; memset(ok, 0, sizeof(ok)); ok[0] = 1; scanf(\"%s\", s+1); len = strlen(s+1); for (int j = 1; j &lt;= len; j++) &#123; if (ok[j-1]) query(s, j, len); &#125; for (int j = len; j &gt;= 0; j--) &#123; if (ok[j]) &#123; printf(\"%d\\n\", j); break; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Trie树","slug":"Trie树","permalink":"http://akdream.tk/tags/Trie%E6%A0%91/"}]},{"title":"Samjia和矩阵[LOJ6173]","slug":"Samjia和矩阵[LOJ#6173]","date":"2020-02-05T12:29:20.000Z","updated":"2020-10-08T12:16:08.064Z","comments":true,"path":"post/320f30f7.html/","link":"","permalink":"http://akdream.tk/post/320f30f7.html/","excerpt":"","text":"【题目描述】给你一个只包含大写字母的矩阵，求有多少本质不同的子矩阵。 【输入格式】第一行包含两个整数$n$,$m$,表示矩阵$n$行$m$列 。接下来$n$行描述这个矩阵。 【输出格式】只含一个整数，为本质不同的子矩阵个数。 先枚举长度$l$，然后将每个串压位哈希(哈希提前处理好就行)盗用一张图然后从上到下，从左到右，生成一个这样的串：ac$bc 对于每个长度$l$生成的新串 将这个新串的本质不同的子串个数累加到答案上可以感性理解一下 枚举$l$就相当是枚举子矩阵的长度 多简单鸭 离散化写起来极其恶臭 迫不得已用了map(因为懒)大家不要学我 离散化大法好 p.s. 模数998244353被卡到只有20分。。。要不用1e9+7要不用ull吧 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define mul 1000000007ull#define N 1000005using namespace std;typedef long long ll;typedef unsigned long long ull;int n, m;ull hsh[205][205], p[205];char s[205][205];int now;ull t[20005], len, ans;int sa[N], sa2[N], rnk[N], sum[N], key[N], height[N];map&lt;ull, int&gt; mp;inline bool check(int *num, int x, int y, int l) &#123; return num[x] == num[y] &amp;&amp; num[x+l] == num[y+l];&#125;inline void suffix(int n, int m) &#123; int i, j, p; int *_rnk = rnk, *_sa2 = sa2; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[_rnk[i]=t[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[_rnk[i]]--] = i; for (j = 1; j &lt;= n; j &lt;&lt;= 1, m = p) &#123; for (p = 0, i = n - j + 1; i &lt;= n; i++) _sa2[++p] = i; for (i = 1; i &lt;= n; i++) if (sa[i] &gt; j) _sa2[++p] = sa[i] - j; for (i = 1; i &lt;= n; i++) key[i] = _rnk[_sa2[i]]; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[key[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[key[i]]--] = _sa2[i]; for (swap(_rnk, _sa2), i = 2, p = 2, _rnk[sa[1]] = 1; i &lt;= n; i++) &#123; _rnk[sa[i]] = check(_sa2, sa[i-1], sa[i], j) ? p-1 : p++; &#125; &#125; p = 0; for (i = 1; i &lt;= n; i++) rnk[sa[i]] = i; for (i = 1; i &lt;= n; i++) &#123; if (p) p--; j = sa[rnk[i]-1]; while (t[i+p] == t[j+p]) p++; height[rnk[i]] = p; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%s\", s[i]+1); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; hsh[i][j] = (hsh[i][j-1] * mul + s[i][j]-'A'+1); &#125; &#125; p[0] = 1; for (int i = 1; i &lt;= 200; i++) &#123; p[i] = p[i-1] * mul; &#125; for (int l = 1; l &lt;= m; l++) &#123; len = 0; now = 0; mp.clear(); for (int j = 1; j &lt;= m - l + 1; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; ull x = hsh[i][j+l-1] - hsh[i][j-1] * p[l]; if (!mp[x]) mp[x] = ++now; t[++len] = mp[x]; &#125; t[++len] = ++now; &#125; now += 10; suffix(len, now); ans += n * (n+1) / 2 * (m - l + 1); for (int i = 1; i &lt;= len; i++) &#123; ans -= height[i]; &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://akdream.tk/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"跳蚤[BZOJ4310]","slug":"跳蚤[BZOJ4310]","date":"2020-02-05T11:43:52.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/b4dba3b9.html/","link":"","permalink":"http://akdream.tk/post/b4dba3b9.html/","excerpt":"","text":"【题目描述】很久很久以前，森林里住着一群跳蚤。一天，跳蚤国王得到了一个神秘的字符串，它想进行研究。首先，他会把串分成不超过$k$个子串，然后对于每个子串$S$，他会从$S$的所有子串中选择字典序最大的那一个，并在选出来的$k$个子串中选择字典序最大的那一个。他称其为“魔力串”。现在他想找一个最优的分法让“魔力串”字典序最小。 【输入格式】第一行一个整数 k,$k\\leq 15$接下来一个长度不超过$10^5$的字符串 S。 【输出格式】输出一行，表示字典序最小的“魔力串”。 题解 根据后缀数组height数组的定义，一个串s的本质不同的子串数目是$\\sum_{i=2}^{|s|} |s|-sa[i]+1-height[i]$ 可以二分答案$mid$，即判定字典序排名为第$mid$的子串是否可以作为答案 如何找到排在第$mid$的子串是哪一个？有个显而易见的结论：排在第i的后缀的所有前缀的字典序一定比 排在第i+1的后缀的所有前缀的字典序小所以得到一个这样的求法 1234567inline pair&lt;int, int&gt; getrnk(ll r) &#123; int i; for (i = 1; i &lt;= n &amp;&amp; r &gt; n - sa[i] - height[i] + 1; i++) &#123; r -= n - sa[i] - height[i] + 1; &#125; return make_pair(sa[i], height[i] + r);&#125; 返回的是起始位置+子串长度 自行理解一下 然后其实二分判定是一个贪心的思想 从后往前扫 如果当前的这个后缀比二分的子串小了 就需要从上一位开始截掉 这个可以用LCP来快速判断 最后如果截断次数$&lt;k$，就是一个符合条件的子串 时间复杂度$O(n\\log n)$ (预处理ST表) 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define N 100005#define fi first#define se secondusing namespace std;typedef long long ll;char s[N];int n, m, k, sa[N], sa2[N], rnk[N], key[N], sum[N], height[N];int st[N&lt;&lt;1][21];inline bool ok(int *num, int a, int b, int l) &#123; return num[a] == num[b] &amp;&amp; num[a+l] == num[b+l];&#125;inline void suffix() &#123; int i, j, p; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[rnk[i]=s[i]]++; for (i = 1; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[rnk[i]]--] = i; for (j = 1; j &lt;= n; j &lt;&lt;= 1, m = p) &#123; for (p = 0, i = n - j + 1; i &lt;= n; i++) sa2[++p] = i; for (i = 1; i &lt;= n; i++) if (sa[i] &gt; j) sa2[++p] = sa[i] - j; for (i = 1; i &lt;= n; i++) key[i] = rnk[sa2[i]]; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[key[i]]++; for (i = 1; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[key[i]]--] = sa2[i]; for (swap(sa2, rnk), i = 2, p = 2, rnk[sa[1]] = 1; i &lt;= n; i++) &#123; rnk[sa[i]] = ok(sa2, sa[i-1], sa[i], j) ? p-1 : p++; &#125; &#125;&#125;inline void geth() &#123; int p = 0; for (int i = 1; i &lt;= n; i++) &#123; int j = sa[rnk[i]-1]; if (p) p--; while (s[i+p] == s[j+p]) p++; height[rnk[i]] = p; &#125;&#125;inline void init_st() &#123; for (int i = 1; i &lt;= n; i++) st[i][0] = height[i]; for (int l = 1; l &lt;= 20; l++) &#123; for (int i = 1; i + (1 &lt;&lt; l) - 1 &lt;= n; i++) &#123; st[i][l] = min(st[i][l-1], st[i+(1&lt;&lt;(l-1))][l-1]); &#125; &#125;&#125;inline int LCP(int x, int y) &#123; if (x == y) return n - x + 1; int l = rnk[x], r = rnk[y]; if (l &gt; r) swap(l, r); l++; int len = log2(r - l + 1); return min(st[l][len], st[r-(1&lt;&lt;len)+1][len]);&#125;inline pair&lt;int, int&gt; getrnk(ll r) &#123; int i; for (i = 1; i &lt;= n &amp;&amp; r &gt; n - sa[i] - height[i] + 1; i++) &#123; r -= n - sa[i] - height[i] + 1; &#125; return make_pair(sa[i], height[i] + r);&#125;inline bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; int lcp = LCP(a.fi, b.fi); if (lcp &gt;= a.se || lcp &gt;= b.se) &#123; return a.se &lt;= b.se; &#125; else return s[a.fi + lcp] &lt; s[b.fi + lcp];&#125;inline bool check(ll mid) &#123; pair&lt;int, int&gt; a = getrnk(mid); int cnt = 0; for (int i = n, lst = n; i &gt;= 1; i--) &#123; if (s[a.fi] &lt; s[i]) &#123; return false; &#125; if (!cmp(make_pair(i, lst - i + 1), a)) &#123; cnt++, lst = i; &#125; if (cnt &gt;= k) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; scanf(\"%d%s\", &amp;k, s+1); n = strlen(s+1); m = 128; suffix(); geth(); ll tot = 0; for (int i = 1; i &lt;= n; i++) tot += n - sa[i] + 1 - height[i]; init_st(); ll l = 1, r = tot, mid, ans = tot; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; pair&lt;int, int&gt; aa = getrnk(ans); for (int i = aa.fi; i &lt;= aa.fi + aa.se - 1; i++) &#123; putchar(s[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"二分答案","slug":"二分答案","permalink":"http://akdream.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]},{"title":"脑洞治疗仪「SHOI2015」","slug":"脑洞治疗仪「SHOI2015」","date":"2020-02-05T10:57:44.000Z","updated":"2020-10-08T12:16:08.688Z","comments":true,"path":"post/f1a598da.html/","link":"","permalink":"http://akdream.tk/post/f1a598da.html/","excerpt":"","text":"【题目描述】曾经发明了自动刷题机的发明家 SHTSC 又公开了他的新发明：脑洞治疗仪——一种可以治疗他因为发明而日益增大的脑洞的神秘装置。为了简单起见，我们将大脑视作一个$01$序列。$1$代表这个位置的脑组织正常工作，$0$代表这是一块脑洞。 1010001110 脑洞治疗仪修补某一块脑洞的基本工作原理就是将另一块连续区域挖出，将其中正常工作的脑组织填补在这块脑洞中。（所以脑洞治疗仪是脑洞的治疗仪？） 例如，用上面第$8$号位置到第$10$号位置去修补第$1$号位置到第$4$号位置的脑洞，我们就会得到： 1111001000 如果再用第$1$号位置到第$4$号位置去修补第$8$号位置到第$10$号位置： 0000001111 这是因为脑洞治疗仪会把多余出来的脑组织直接扔掉。 如果再用第$7$号位置到第$10$号位置去填补第$1$号位置到第$6$号位置： 1111000000 这是因为如果新脑洞挖出来的脑组织不够多，脑洞治疗仪仅会尽量填补位置比较靠前的脑洞。 假定初始时 SHTSC 并没有脑洞，给出一些挖脑洞和脑洞治疗的操作序列，你需要即时回答 SHTSC 的问题：在大脑某个区间中最大的连续脑洞区域有多大。 【输入格式】第一行两个整数$n$、$m$，表示 SHTSC 的大脑可分为从$1$到$n$编号的$n$个连续区域，有$m$个操作。 以下$m$行每行是下列三种格式之一： $0\\quad l\\quad r$：SHTSC 挖了一个范围为$[l, r]$的脑洞。 $1\\quad l_0\\quad r_0\\quad l_1\\quad r_1$：SHTSC 进行了一次脑洞治疗，用从$l_0$到$r_0$的脑组织修补$l_1$到$r_1$的脑洞。 $2\\quad l\\quad r$：SHTSC 询问$[l, r]$区间内最大的脑洞有多大。 上述区间均在$[1, n]$范围内。 【输出格式】对于每个询问，输出一行一个整数，表示询问区间内最大连续脑洞区域有多大。 其实就是个板子题。。。可以先看看Luogu SP1043 以上面这题为例，对于这种询问 “哪段区间是最…的”(哪段区间和最大) ，一般思路是线段树的每个节点$[l,r]$维护和最大的前缀$[l,x]$，后缀$[y,r]$在哪里。然后父亲节点的前缀最大就是 MAX(左儿子最大的前缀和，左儿子整段区间的和+右儿子最大前缀和) 后缀同理 正确性显然。 这道题也是类似的，父亲节点的前缀最大就是 (左儿子整个区间都是0 ？ 左儿子整个区间+右儿子前缀0数量 : 左儿子前缀0数量) 后缀同理。 然后再维护一下区间和来进行修补操作就完了。。。 提一下怎么进行填1的操作 伪代码：int update () { 如果 (整段区间在填补范围$[x,y]$内 &amp;&amp; 剩下的可用1数量足以填满当前区间的0) { 打上懒标记; return 可用1数量-填满当前区间需要的1数量; } pushdown(); 可用1数量 = update(左儿子);//优先左儿子 可用1数量 = update(右儿子); return 可用1数量} 经证明，这个的时间复杂度依然是$O(log\\ n)$的 蒟蒻并不会证 总时间复杂度$O((n+m)log\\ n)$ 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define lson ind&lt;&lt;1#define rson ind&lt;&lt;1|1using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int n, m, tp, l0, r0, l1, r1; struct segtree&#123; int l, r, tot, pre, suf, tag, mx;&#125; tr[2000005]; inline void add(int ind, int x) &#123; tr[ind].tag = x; if (x == 0) &#123; tr[ind].tot = 0; tr[ind].pre = tr[ind].suf = tr[ind].mx = (tr[ind].r - tr[ind].l + 1); &#125; else &#123; tr[ind].tot = (tr[ind].r - tr[ind].l + 1); tr[ind].pre = tr[ind].suf = tr[ind].mx = 0; &#125;&#125;inline void pushup(int ind) &#123; tr[ind].tot = tr[lson].tot + tr[rson].tot; tr[ind].pre = tr[lson].pre; tr[ind].suf = tr[rson].suf; if (tr[lson].pre == tr[lson].r - tr[lson].l + 1) tr[ind].pre += tr[rson].pre; if (tr[rson].suf == tr[rson].r - tr[rson].l + 1) tr[ind].suf += tr[lson].suf; tr[ind].mx = max(max(tr[lson].mx, tr[rson].mx), tr[lson].suf + tr[rson].pre);&#125;void build(int ind, int l, int r) &#123; tr[ind].l = l; tr[ind].r = r; tr[ind].tag = -1; if (l == r) &#123; tr[ind].tot = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); pushup(ind);&#125;inline void pushdown(int ind) &#123; if (tr[ind].tag == 0) &#123; add(lson, 0); add(rson, 0); &#125; else if (tr[ind].tag == 1) &#123; add(lson, 1); add(rson, 1); &#125; tr[ind].tag = -1;&#125;void update1(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; add(ind, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) update1(lson, x, y); if (mid &lt; y) update1(rson, x, y); pushup(ind);&#125;int update2(int ind, int x, int y, int num) &#123; if (!num) return 0; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; num &gt;= r-l+1-tr[ind].tot) &#123; int ret = num-(r-l+1-tr[ind].tot); add(ind, 1); return ret; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) num = update2(lson, x, y, num); if (mid &lt; y) num = update2(rson, x, y, num); pushup(ind); return num;&#125;int query1(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return tr[ind].tot; &#125; int mid = (l + r) &gt;&gt; 1, ret = 0; pushdown(ind); if (x &lt;= mid) ret += query1(lson, x, y); if (mid &lt; y) ret += query1(rson, x, y); return ret;&#125;segtree merge(segtree a, segtree b) &#123; segtree ret; ret.l = a.l; ret.r = b.r; ret.tot = a.tot + b.tot; ret.pre = a.pre; ret.suf = b.suf; if (a.pre == a.r - a.l + 1) ret.pre += b.pre; if (b.suf == b.r - b.l + 1) ret.suf += a.suf; ret.mx = max(max(a.mx, b.mx), a.suf + b.pre); return ret;&#125;segtree query2(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) return tr[ind]; int mid = (l + r) &gt;&gt; 1; segtree a, b; a.mx = b.mx = -1; pushdown(ind); if (x &lt;= mid) a = query2(lson, x, y); if (mid &lt; y) b = query2(rson, x, y); if (a.mx == -1) return b; else if (b.mx == -1) return a; else return merge(a, b);&#125;int main() &#123; n = read(); m = read(); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; tp = read(); if (tp == 0) &#123; l0 = read(); r0 = read(); update1(1, l0, r0); &#125; else if (tp == 1) &#123; l0 = read(); r0 = read(); l1 = read(); r1 = read(); int num = query1(1, l0, r0); update1(1, l0, r0); update2(1, l1, r1, num); &#125; else &#123; l0 = read(); r0 = read(); segtree ans = query2(1, l0, r0); printf(\"%d\\n\", ans.mx); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"随机序列[SHOI2018]","slug":"随机序列[SHOI2018]","date":"2020-02-05T10:22:32.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/894e70d4.html/","link":"","permalink":"http://akdream.tk/post/894e70d4.html/","excerpt":"","text":"【题目描述】你的面前有$n$个数排成一行，分别为$a_1, a_2, \\dots, a_n$。你打算在每相邻的两个$a_i$ 和$a_{i+1}$间都插入一个加号、减号或者乘号。那么一共有$3^{n-1}$种可能的表达式。 你对所有可能的表达式的值的和非常感兴趣。但这毕竟太简单了，所以你还打算支持一个修改操作，可以修改某个$a_i$的值。 你能够编写一个程序对每个修改都输出修改完之后所有可能表达式的和吗？注意，修改是永久的，也就是说每次修改都是在上一次修改的基础上进行，而不是在最初的表达式上进行。 【输入格式】第一行包含两个正整数$n$和$Q$，为数的个数和询问的个数。第二行包含$n$个非负整数，依次表示$a_1, a_2, \\dots, a_n$。接下来$Q$行，每行包含两个非负整数$t$和$v$，表示要将$a_t$修改为$v$，其中$1 \\leq t \\leq n$。 保证对于$1 \\leq j \\leq n, 1 \\leq i \\leq Q$，都有$a_j, v_i \\leq 10^4$。 【输出格式】输出$Q$行。对于每个修改输出一行，包含一个整数，表示修改之后所有可能表达式的和，对$10^9 + 7$取模。 $n, Q \\le 100000$ 此题中乘号相对于加减号来说其实算一个比较特殊的运算符，由于运算符优先级，乘法要优先计算，所以每个表达式其实都能看作是几段连续的乘积相加减。举例来说$a_1*a_2-a_3*a_4*a_5+a_6$，就是$a_1*a_2$减去$a_3*a_4*a_5$减去$a_6$(废话)，即三个乘积相加减 所以我们可以将一个表达式的构成这样理解：先插入乘号，使得原来的$n$个元素变成$x$个乘积，不妨设这些乘积为$p_1,p_2,\\dots,p_x$。然后在这$x$个乘积之间加上正负号 对于每种表达式，一定有另外一种表达式与它相互对应，它们的和为$2*p_1$。什么意思呢？比如表达式$a_1*a_2-a_3*a_4*a_5+a_6$，中间的5个符号，乘号不变，加变减，减变加，变成$a_1*a_2+a_3*a_4*a_5-a_6$，这两个表达式的和为$2*a_1*a_2$，即$2*p_1$。 考虑$p_1$一定是一个$a_1*a_2*\\dots*a_k$的形式，即一个前缀积，而每种表达式产生的贡献只与$p_1$有关，所以可以来计算一下每个前缀积在多少个表达式中出现。设这个前缀积是$a_1*a_2*\\dots*a_k$，显然$a_k$和$a_{k+1}$之间的符号只能填加减中的一种，后面的位置则是三种任选，总方案数是$f[k]=2*3^{n-k-1}$，特别的，$f[n]=1$。 那么对于$a_1, a_2, \\dots, a_n$，所有可能的表达式的和就是$\\sum_{k=1}^n f[k]*a_1*a_2*\\dots*a_k$ 把这$n$个值插入线段树中，对于一个将$a_t$修改为$v$的修改操作，只需将[t,n]区间内的值除以原$a_t$(即乘以$a_t$的逆元)再乘上$v$，得到新的前缀积。 时间复杂度$O((n+Q)log\\ n)$ 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define mod 1000000007#define lson ind&lt;&lt;1#define rson ind&lt;&lt;1|1using namespace std;typedef long long ll; inline ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x&lt;&lt;1) + (x&lt;&lt;3) + (ch^'0'); return x * f;&#125;ll n, q, a[100005], mul[100005], f[100005];struct segtree&#123; ll l, r, sum, tag;&#125; tr[400005];inline ll fpow(ll x, ll t) &#123; ll r = 1; for (; t; t &gt;&gt;= 1, x = x * x % mod) if (t &amp; 1) r = r * x % mod; return r;&#125;void build(ll ind, ll l, ll r) &#123; tr[ind].l = l; tr[ind].r = r; tr[ind].tag = 1; if (l == r) &#123; tr[ind].sum = mul[l] * f[l] % mod; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); tr[ind].sum = (tr[lson].sum + tr[rson].sum) % mod;&#125;inline void pushdown(ll ind) &#123; if (tr[ind].tag == 1) return; ll v = tr[ind].tag; tr[ind].tag = 1; tr[lson].sum = tr[lson].sum * v % mod; tr[lson].tag = tr[lson].tag * v % mod; tr[rson].sum = tr[rson].sum * v % mod; tr[rson].tag = tr[rson].tag * v % mod;&#125;void update(ll ind, ll x, ll y, ll v) &#123; ll l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].sum = tr[ind].sum * v % mod; tr[ind].tag = tr[ind].tag * v % mod; return; &#125; ll mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) update(lson, x, y, v); if (mid &lt; y) update(rson, x, y, v); tr[ind].sum = (tr[lson].sum + tr[rson].sum) % mod;&#125;int main() &#123; n = read(); q = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); mul[0] = 1; f[n] = 1; f[n-1] = 2; for (int i = 1; i &lt;= n; i++) mul[i] = mul[i-1] * a[i] % mod; for (int i = n-2; i; i--) f[i] = f[i+1] * 3 % mod; build(1, 1, n); for (int i = 1, p, v; i &lt;= q; i++) &#123; p = read(); v = read(); update(1, p, n, v * fpow(a[p], mod-2) % mod); a[p] = v; printf(\"%lld\\n\", tr[1].sum); &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"集训队论文-基础排序算法","slug":"集训队论文-基础排序算法","date":"2020-01-26T02:35:18.000Z","updated":"2020-10-08T12:16:08.853Z","comments":true,"path":"post/7911789d.html/","link":"","permalink":"http://akdream.tk/post/7911789d.html/","excerpt":"","text":"1. 排序的简单应用 一些题目需要排序用来辅助解决问题 std::sort就完事了 不需要手写而且肯定比你手写跑得快 放一个手动快速排序的代码及注释 1234567891011void quicksort(int l, int r) &#123; if (l &gt;= r) return; int i = l, j = r, base = a[l]; //取最左边的数为基准数(取哪个都行); while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= base) j--; //找到右起第一个小于基准数的数 while (i &lt; j &amp;&amp; a[i] &lt;= base) i++; //找到左起第一个大于基准数的数 if (i &lt; j) swap(a[i], a[j]); //交换两数 &#125; swap(a[l], a[i]); //把基准数换到中心 此时[l,r]内基准数左边的所有数小于基准数 基准数右边的所有数大于基准数 quicksort(l, i - 1); quicksort(i + 1, r); //分别向左右递归 &#125; 平均复杂度$O(n\\ log\\ n)$最坏复杂度$O(n^2)$ 想到一个很经典的利用排序辅助解决问题的算法：莫队 模板例题 #240 小Z的袜子 简单来说就是暴力维护双指针指向当前查询区间的左右端点 每次左或右指针可以向左或向右移动一格 同时更新当前区间的答案 可以给询问排序 如果直接先按左端点排再按右端点排 依然容易被卡掉 比如询问[2,2][3,1000][4,4][5,2000][6,6] 如果按照[2,2][4,4][6,6][3,1000][5,2000]的顺序查询 显然右指针会少移动很多次 所以这个暴力的思路就是给左端点分块 左端点在同一个$\\sqrt{n}$块中的询问优先按右端点排序 否则才是优先按左端点排序 这样显然会更容易得到上面那个例子中的第二种排序 复杂度有所降低 据说这个复杂度是大约$O(n\\sqrt{n})$的 足以通过此题 只是在这里介绍一下莫队算法 这个题具体怎么用莫队维护神犇们肯定一眼就看出来了 (突然发现OJ里已经有这题了) 此题代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll read() &#123; ll x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;struct query&#123; ll l, r, id;&#125; q[50005];ll n, m, bl;ll c[50005];ll cnt[50005], ans, nl, nr;ll ansx[50005], ansy[50005];inline bool cmp(query a, query b) &#123; return a.l / bl == b.l / bl ? a.r &lt; b.r : a.l &lt; b.l;&#125;inline void add(ll x) &#123; cnt[x]++; if (cnt[x] &gt; 1) ans = ans - (cnt[x]-1) * (cnt[x]-2) + (cnt[x]) * (cnt[x]-1);&#125;inline void del(ll x) &#123; cnt[x]--; if (cnt[x] &gt; 0) ans = ans - (cnt[x]) * (cnt[x]+1) + (cnt[x]-1) * (cnt[x]); &#125;inline void update(ll l, ll r) &#123; while (nl &lt; l) del(c[nl++]); while (nl &gt; l) add(c[--nl]); while (nr &lt; r) add(c[++nr]); while (nr &gt; r) del(c[nr--]);&#125;inline void getans(ll x, ll y, ll id) &#123; if (x == 0) &#123; ansx[id] = 0; ansy[id] = 1; return; &#125; ll gcd = __gcd(x, y); x /= gcd; y /= gcd; ansx[id] = x; ansy[id] = y;&#125;int main() &#123; n = read(); m = read(); bl = sqrt(n); for (ll i = 1; i &lt;= n; i++) &#123; c[i] = read(); &#125; for (ll i = 1; i &lt;= m; i++) &#123; q[i].l = read(); q[i].r = read(); q[i].id = i; &#125; sort(q+1, q+m+1, cmp); nl = q[1].l, nr = q[1].r; for (ll i = q[1].l; i &lt;= q[1].r; i++) &#123; add(c[i]); &#125; getans(ans, (nr-nl+1)*(nr-nl), q[1].id); for (ll i = 2; i &lt;= m; i++) &#123; update(q[i].l, q[i].r); getans(ans, (nr-nl+1)*(nr-nl), q[i].id); &#125; for (ll i = 1; i &lt;= m; i++) &#123; printf(\"%lld/%lld\\n\", ansx[i], ansy[i]); &#125; return 0;&#125; 由此可以看出 通过排序改变询问顺序有时候可以辅助解题 排序也经常用于数据离散化 感觉扯得有点多了 跑题了 2.逆序对 逆序对定义为序列$a[1\\dots n]$中的一对下标$(i,j)$满足$1\\le i &lt; j \\le n$且$a[i] &gt; a[j]$。逆序对和排序算法有着密切关系。 例题1 #804 北冥有鱼 这道题我们就可以从逆序对的角度考虑 发现每次交换$a[i]$与$a[i+1]$只有这两个元素的相对顺序发生了变化 根据逆序对的定义 只有两个元素的相对顺序发生了变化 才有可能新产生或减少逆序对 所以 每次交换可能导致3种结果:1.$a[i]&lt;a[i+1]$逆序对增加12.$a[i]&gt;a[i+1]$逆序对减少13.$a[i]=a[i+1]$逆序对数量不变 所以我们得到一个最优的交换策略 每次找到一对$a[i]&gt;a[i+1]$并交换使逆序对减少1 容易发现当找不到这样一对$a[i]&gt;a[i+1]$时 数组必已有序 因为每次交换使逆序对数量-1 所以最小交换次数就是原数组的逆序对数量 如何求逆序对数量？ 1.树状数组将数组离散化，枚举$a[1\\sim n]$，每次查询现在树状数组中有多少个元素大于$a[i]$，然后将$a[i]$放进树状数组。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define lowbit(x) x&amp;(-x)using namespace std;typedef long long ll;ll n, a[500005], srt[500005], mx, ans;ll tr[500005];inline void update(ll ind, ll x) &#123; while (ind &lt;= n) &#123; tr[ind] += x; ind += lowbit(ind); &#125;&#125;inline ll getsum(ll ind) &#123; ll ret = 0; while (ind) &#123; ret += tr[ind]; ind -= lowbit(ind); &#125; return ret;&#125;int main() &#123; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); srt[i] = a[i]; &#125; sort(srt+1, srt+n+1); mx = unique(srt+1, srt+n+1)-srt-1; for (int i = 1; i &lt;= n; i++) &#123; a[i] = lower_bound(srt+1, srt+mx+1, a[i])-srt; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans += getsum(mx) - getsum(a[i]); update(a[i], 1); &#125; printf(\"%lld\\n\", ans); return 0;&#125; 2.归并排序不再阐述 见代码 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[500005], tmp[500005];long long ans; void merge_sort(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; merge_sort(l, mid); merge_sort(mid+1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) &#123; tmp[k++] = a[i++]; &#125; else &#123; tmp[k++] = a[j++]; ans += mid - i + 1; &#125; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (i = l; i &lt;= r; i++) a[i] = tmp[i];&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; merge_sort(1, n); printf(\"%lld\\n\", ans); return 0;&#125; 时间复杂度均为$O(n\\ log_2 n)$。 例题2 #805 巨神JZC暴力切题 发现$q$比较小，$m$则比较巨大 $10^6$次排序 很有可能在前$100$次后整个数组就基本有序 后面的每次排序如果还是用$O(n\\ log\\ n)$的时间处理一段可能已经有序的区间 会浪费很多时间 所以想到可以像#804 北冥有鱼一样用消除逆序对的方法来排序 每次找到$[l_i,r_i]$区间内所有的$a[i-1]&gt;a[i]$将每一对互换 因为逆序对的数量最多有$\\frac{n(n-1)}{2}$个 所以总的互换次数不会超过$n^2$此题$n\\le 1500$绰绰有余 总比$O(m\\cdot n\\ log\\ n)$要好 如何快速找到区间内的$a[i-1]&gt;a[i]$? 维护一个平衡树或std::set，每次询问初始时扫描一遍将所有$a[i-1]&gt;a[i]$的位置放入其中 每次排序操作时只需要一直查找第一个大于等于$l_i$的位置(如果该位置已经大于$r_i$就可以结束此次排序) 互换这个位置上的$a[i-1],a[i]$，然后检查$a[i-2],a[i-1]$及$a[i],a[i+1]$的大小关系并在set中更新 最后如果set为空，则表示$a$数组已不存在逆序对，输出Accepted，否则输出Wrong Answer。 时间复杂度$O(q(m+n^2)\\cdot \\log_2 n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, q;int a[2005], l[1000005], r[1000005]; set&lt;int&gt; s;int main() &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d %d\", &amp;l[i], &amp;r[i]); l[i] = max(l[i], 1); r[i] = min(r[i], n); &#125; for (int i = 1; i &lt;= q; i++) &#123; s.clear(); for (int j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;a[j]); if (a[j-1] &gt; a[j]) &#123; s.insert(j-1); &#125; &#125; for (int j = 1; j &lt;= m; j++) &#123; int pos = 0; set&lt;int&gt;::iterator it; do &#123; it = s.lower_bound(l[j]); pos = *it; if (it == s.end() || pos &gt;= r[j]) break; swap(a[pos], a[pos+1]); s.erase(pos); if (pos &gt;= 2) &#123; if (a[pos-1] &lt;= a[pos]) &#123; s.erase(pos-1); &#125; else &#123; s.insert(pos-1); &#125; &#125; if (pos &lt;= n - 2) &#123; if (a[pos+1] &lt;= a[pos+2]) &#123; s.erase(pos+1); &#125; else &#123; s.insert(pos+1); &#125; &#125; &#125; while (1); &#125; if (!s.empty()) &#123; puts(\"Wrong Answer\"); &#125; else puts(\"Accepted\"); &#125; return 0;&#125; 3. 01序列 01序列是指序列元素都为$0$或$1$的序列。这种序列有一些美♂妙性质可以帮助我们解题。 例题1 #807 苦练七十二变，笑对八十一难 和上面那道 #805 巨神JZC暴力切题 有点像 也是多次排序 直接暴排肯定TLE 很遗憾，对于这题$n,m\\le 50000$，消逆序对的处理速度依然不够快。 有什么东西处理区间操作比较快呢？当然是我们的线段树$Segment\\ Tree$啦！ 然而$Segment\\ Tree$并不会区间排序呢 但是如果序列中只存在$0$或$1$，线段树还是可以做到的 以升序排序为例，具体地说，每次查询区间中共有多少个$1$(区间求和)，记为$num$，然后将区间后$num$个修改成$1$，前面剩下的修改成$0$(区间修改)。就相当于给区间内的$0,1$做了升序排序了 而且线段树修改有着极其优秀的时间复杂度$O(log\\ n)$，比std::sort的$O(n\\ log\\ n)$比起来不知道快到哪里去了，和倍增谈笑风生。 所以对于这题我们可以得到一个极其诡异的解法： 二分答案$mid$(这也能二分？)，将原数组中小于mid的设成$0$，剩下的设成$1$。然后用线段树来排这$m$次序，排完后看看第$k$个是$0$还是$1$，如果是$0$表示$mid$大了，否则是$mid$小了。 时间复杂度$O(n\\ log\\ n\\ +\\ m\\ log^2\\ n)$; p.s.最好再加个离散化 不然会被我卡掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define lson ind&lt;&lt;1#define rson ind&lt;&lt;1|1using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125;int t, n, m, k, a[100005], srt[100005], mx, tp[100005], le[100005], ri[100005], tmp[100005]; namespace Segtree&#123; //线段树自己写去&#125;using namespace Segtree;bool check(int x) &#123; for (int i = 1; i &lt;= n; i++) tmp[i] = (a[i] &gt;= x); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; int num = query(1, le[i], ri[i]); if (!tp[i]) &#123; update(1, le[i], ri[i]-num, 0); update(1, ri[i] - num + 1, ri[i], 1); &#125; else &#123; update(1, le[i], le[i] + num - 1, 1); update(1, le[i] + num, ri[i], 0); &#125; &#125; return query(1, k, k) == 1;&#125;int main() &#123; t = read(); while (t--) &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) a[i] = srt[i] = read(); for (int i = 1; i &lt;= m; i++) tp[i] = read(), le[i] = read(), ri[i] = read(); k = read(); sort(srt+1, srt+n+1); mx = unique(srt+1, srt+n+1)-srt-1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(srt+1, srt+mx+1, a[i])-srt; int l = 1, r = mx, mid, ans = 0; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; printf(\"%d\\n\", srt[ans]); &#125; return 0;&#125; 这道题的这个思想似乎经常用于中位数有关的题目 又加了一道这个思路的题#808 孔明の金字塔 先存一下相似问题[CQOI2009]中位数 例题2 #806 巨神JZC巧妙切题 先普及一下 像题目这样的，对一个序列依次进行$m$次这种比较交换操作 叫做一个 比较网络 。一个总能给$n$个元素正确排序的 比较网络 叫做一个 排序网络 。 这道题其实就是给你一个比较网络，问你对于一个随机的$n$排列，它有多大几率不能正确排序。 先来思考一下如何判定一个比较网络是否是一个排序网络。 如果暴力枚举排列 时间复杂度是$O(n\\cdot n!)$的，还可以优化一下 实际上只需要枚举$2^n$种01序列判断是否能被这个比较网络成功排序就行了 简单的证明：假设有一个$n$排列不能被成功排序，则操作后必然存在至少一组逆序对$i&lt;j,a[i]&gt;a[j]$。 设$a[j]=x$，将排列中所有大于$x$的数设为$1$，小于等于的设为$0$。将原排列按这样变换，得来的01序列作为输入，则输出$a[i]$的位置上会是$1$，$a[j]$的位置上会是$0$。 所以当这个排列变换得来的01序列不能够被成功排序时，这个排列也一定不能被成功排列。 实际上，每个$n$排列对应着$n$个01序列(把$a[1\\sim n]$中任意一个设为$x$都能得到一个)，当且仅当这$n$个01序列都能被这个比较网络成功排序时，这个$n$排列能被成功排序。 如何求有多少$n$排列不能被排序？ 预处理出所有可以被排序的01序列，一个可以被排序的$n$排列实际上就对应着一条从$00\\dots0$到$11\\dots1$的路径，其间只能经过那些可以被排序的01序列。 这条路径上每个点的意义是什么呢？假设$n=5$，从$00000$到$01000$就意味着将数字$5$放在了排列的第二位，$01000$就代表着$x=4$($x$的意义见上文)时变换得来的01序列。同理，从$01000$到$01100$就意味着将数字$4$放在了排列的第三位。这样一直到$11111$就对应了一个$n$排列。 这个计数问题显然可以用$O(n\\cdot 2^n)$的时间复杂度内用一个状压DP解决 想改改这题题面 竞标中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;typedef long long ll;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125; int n, m, l[30], r[30];ll dp[2000005], wa, tot;bool ok[2000005];inline void getnum(int x, int *num) &#123; for (int i = 1; i &lt;= n; i++) &#123; num[i] = (x &gt;&gt; (n - i)) &amp; 1; &#125;&#125;inline ll fpow(ll x, ll t) &#123; ll ret = 1; for (; t; x = x * x % mod, t &gt;&gt;= 1) if (t &amp; 1) ret = ret * x % mod; return ret;&#125;inline bool check(int x) &#123; int num[30] = &#123;0&#125;; getnum(x, num); for (int i = 1; i &lt;= m; i++) &#123; if (num[l[i]] &gt; num[r[i]]) swap(num[l[i]], num[r[i]]); &#125; for (int i = 2; i &lt;= n; i++) &#123; if (num[i] &lt; num[i-1]) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= m; i++) &#123; l[i] = read(); r[i] = read(); &#125; for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; i++) &#123; ok[i] = check(i); &#125; dp[0] = tot = 1; for (int i = 1; i &lt;= n; i++) tot = tot * i % mod; for (int i = 1; i &lt;= (1 &lt;&lt; n) - 1; i++) &#123; if (!ok[i]) continue; for (int j = 1; j &lt;= n; j++) &#123; if (i &amp; (1 &lt;&lt; (j-1))) &#123; dp[i] = (dp[i] + dp[i-(1&lt;&lt;(j-1))]) % mod; &#125; &#125; &#125; wa = (tot - dp[(1&lt;&lt;n)-1] + mod) % mod; printf(\"%lld\\n\", wa * fpow(tot, mod-2) % mod); return 0;&#125; 在遇到一个排序问题不知道怎么做时，不妨试着从逆序对或01序列的角度思考一下 然后我们现在再回去看看#805 巨神JZC暴力切题 第8个点只有0和1 看一下怎么做 设$S_i$表示一个01序列的集合 其中的每个01序列$p\\in S_i$经过第$i+1\\sim m$次排序都能被完全排好序 这个集合似乎是无比巨大的 但是我们还是考虑下怎么递推得到每个$S_i$ 首先$S_m$中肯定只有一个序列 就是那个被完全排好序的 然后$S_0$就代表着所有能被这$m$次操作完全排好序的01序列的集合 要是求出这个回答询问就只需要判断一个询问序列在不在$S_0$里就行了 有哪些元素经过第$m$次排序能得到那个完全排好的序列，即$S_{m-1}$有哪些元素呢 显然 把$S_m$里那个唯一的序列记为$P$那么随机打乱$p[l_i\\dots r_i]$得到的所有序列都属于$S_{m-1}$ 扩展到每个$i$那么对于每个$p\\in S_i$如果$p[l_i\\dots r_i]$有序 那么就把随机打乱$p[l_i\\dots r_i]$得到的所有结果加入$S_{i-1}$ 这个的大小是指数级的 我们要想办法用更小的空间表示这些集合 定义两个01序列之间的大小关系为它们字典序的大小关系 即$p&lt;q$当且仅当$\\forall i \\in [1,k)\\ p[i]=q[i]$且$p[k]&lt;q[k]$ 我们想要给每个$S_i$找到一个有代表性的01序列$a_i$使得$\\forall p \\in S_i$都有$p\\le a_i$即$a_i$是$S_i$中最大的01序列 下面证存在这样的$a_i$并且对于所有$p\\le a_i$都有$p\\in S_i$ 定义$f(p,l,r)$为将$p[l\\dots r]$升序排序得到的新序列，$g(p,l,r)$为将$p[l\\dots r]$降序排列得到的新序列 不妨通过结论推过程 由于$S_m$就一个元素 所以$a_m$就是那个元素 对于剩下的$a_i$有$a_i=g(a_{i+1},l_{i+1},r_{i+1})$ 性质1：$f(p,l,r)\\le p$，$p\\le g(p,l,r)$ 性质2：令$b=f(a,l,r),c=g(a,l,r)$则$g(a,l,r)=g(b,l,r)=g(c,l,r)$，$f(a,l,r)=f(b,l,r)=f(c,l,r)$ 性质3：若$a\\le b$那么$f(a,l,r)\\le f(b,l,r)$，$g(a,l,r)\\le g(b,l,r)$ 都很容易得到吧。。。 证明1：如果$p\\in S_i$那么$p\\le a_i$ 如果$p\\in S_i$设$q=f(p,l_{i+1},r_{i+1})$为$p$经过第$i+1$次排序得到的结果 有$q\\in S_{i+1}$ 那么有$q\\le a_{i+1}$ 根据性质2有$g(p,l_{i+1},r_{i+1})=g(q,l_{i+1},r_{i+1})$记它为$r$根据性质1有$p\\le r$ 根据性质3 因为$q\\le a_{i+1}$所以有$r=g(q,l_{i+1},r_{i+1})\\le g(a_{i+1},l_{i+1},r_{i+1})$ 由定义得$g(a_{i+1},l_{i+1},r_{i+1})$其实就是$a_i$所以$r\\le a_i$ 又因为$p\\le r$所以$p\\le a_i$证毕 证明2：如果$p\\le a_i$那么$p\\in S_i$ 设$q=f(p,l_{i+1},r_{i+1})$为$p$经过第$i+1$次排序得到的结果 设$r=f(a_i,l_{i+1},r_{i+1})$ 根据性质3 因为$p\\le a_i$所以$q=f(p,l_{i+1},r_{i+1})\\le r=f(a_i,l_{i+1},r_{i+1})$ 又因$a_i=g(a_{i+1},l_{i+1},r_{i+1})$根据性质2得$r=f(a_{i+1},l_{i+1},r_{i+1})$再根据性质1得$r\\le a_{i+1}$所以$q\\le r\\le a_{i+1}$所以$q\\in S_{i+1}$ 也就是说$q$经过第$i+2\\sim m$次排序能被完全排好序 又因为$q$就是$p$经过第$i+1$次排序得来的 所以$p$经过第$i+1\\sim m$次排序也能被完全排好序 所以$p\\in S_i$证毕 那么我们现在就知道了 集合$S_i$正好由小于等于$a_i$的所有01序列构成 所以我们只需要按照上面说的递推$a_i$的方法 求出$a_0$ 然后对于每个询问 判断输入的01序列是否小于等于$a_0$即可 这个显然是可以$O(n)$的 预处理$a_0$需要$m$次降序排序 这个用线段树搞一搞或者用上面40分做法的消除逆序对都可以 时间复杂度$O((m+n^2)\\log n + qn)$ 打了这些基础之后就可以来推出满分算法了 不妨假设询问给出的数组$b$是一个$n$排列 如果不是的话离散化一下就好了 显然不会对答案造成影响 定义$h_k(b)$表示把$b$这个$n$排列中$\\ge k$的数全部设为$1$其余设为$0$得到的01序列 那么这$m$次操作必须把$k\\in [2,n]$的每个$c_k$都成功排序 才一定能把$b$完全排好序 先看看怎么求得刚才第8个点算法里的$a_0$ 看起来我们要对于每个$k$算1次$a_0$了 但是其实不需要 我们可以做一件等价的事情 把一个初始时为$1,2,3,\\dots,n$的序列$p$按照$m\\dots 1$的顺序 每次将$p[l_i\\dots r_i]$降序排序，就和上题一样 然后最后$h_k(p)$就是$k$对应的$a_0$了 那么一个询问序列$b$可以被排序的条件就是对于$k\\in [1,n]$都有$h_k(b)\\le h_k(p)$ 再来看看刚才我们对于01序列定义的小于运算 换个表示方法 两个01序列$x,y$有$x\\le y$当且仅当对于每个$i\\in [1,n]$都有$\\sum\\limits_{j=1}^{i}x[j]\\le \\sum\\limits_{j=1}^{i}y[j]$ 即$\\sum\\limits_{j=1}^{i}y[j] - \\sum\\limits_{j=1}^{i}x[j]\\ge 0$很显然吧 就不多解释了 现在我们要判断 是否对于$k\\in [1,n]$都有$h_k(b)\\le h_k(p)$ 注意到$h_k(b)$到$h_{k+1}(b)$只有一个$1$变成了$0$$h_k(p)$到$h_{k+1}(p)$也是 所以我们可以用线段树维护这个东西 线段树存储$h_k(b),h_k(p)$两个01序列前缀和的差 那么$k$增大$1$每次就是进行两次区间修改 然后再查一下最小值判断所有前缀和是否都非负即可 预处理$p$还是要用上面消逆序对的方法 时间复杂度$O(n^2+m+qn)\\log n$ 题解很毒瘤 代码很简短 (由于是自己乱写的也不知道有没有写错 欢迎巨佬来hack我) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125; int n, m, q;int a[1505], b[1505], posa[1505], posb[1505], le[1000005], ri[1000005];set&lt;int&gt; s;void my_sort() &#123; for (int j = m; j &gt;= 1; j--) &#123; int pos = 0; set&lt;int&gt;::iterator it; do &#123; it = s.lower_bound(le[j]); pos = *it; if (it == s.end() || pos &gt;= ri[j]) break; swap(a[pos], a[pos+1]); s.erase(pos); if (pos &gt;= 2) &#123; if (a[pos-1] &gt;= a[pos]) &#123; s.erase(pos-1); &#125; else &#123; s.insert(pos-1); &#125; &#125; if (pos &lt;= n - 2) &#123; if (a[pos+1] &gt;= a[pos+2]) &#123; s.erase(pos+1); &#125; else &#123; s.insert(pos+1); &#125; &#125; &#125; while (1); &#125;&#125;struct Segtree&#123; struct segtree&#123; int l, r, mn, tag; &#125; tr[100005]; #define lson ind&lt;&lt;1 #define rson ind&lt;&lt;1|1 void build(int ind, int l, int r) &#123; tr[ind].l = l, tr[ind].r = r, tr[ind].tag = 0, tr[ind].mn = 0; if (l == r) &#123; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid+1, r); &#125; void pushdown(int ind) &#123; if (!tr[ind].tag) return; int v = tr[ind].tag; tr[ind].tag = 0; tr[lson].mn += v; tr[rson].mn += v; tr[lson].tag += v; tr[rson].tag += v; &#125; void update(int ind, int x, int y, int v) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].mn += v; tr[ind].tag += v; return; &#125; pushdown(ind); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(lson, x, y, v); if (mid &lt; y) update(rson, x, y, v); tr[ind].mn = min(tr[lson].mn, tr[rson].mn); &#125;&#125;T;pair&lt;int, int&gt; tmp[1505];inline void init() &#123; for (int i = 1; i &lt;= n; i++) tmp[i] = make_pair(b[i], i); sort(tmp+1, tmp+n+1); for (int i = 1; i &lt;= n; i++) b[tmp[i].second] = i; for (int i = 1; i &lt;= n; i++) posb[b[i]] = i;&#125;int main() &#123; n = read(); m = read(); q = read(); for (int i = 1; i &lt;= m; i++) &#123; le[i] = read(); ri[i] = read(); &#125; for (int i = 1; i &lt;= n; i++) a[i] = i; for (int i = 1; i &lt; n; i++) s.insert(i); my_sort(); for (int i = 1; i &lt;= n; i++) posa[a[i]] = i; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 1; j &lt;= n; j++) b[j] = read(); init(); T.build(1, 1, n); bool ok = 1; for (int j = 2; j &lt;= n; j++) &#123; T.update(1, posb[j-1], n, 1); T.update(1, posa[j-1], n, -1); if (T.tr[1].mn &lt; 0) &#123; ok = 0; break; &#125; &#125; if (ok) puts(\"Accepted\"); else puts(\"Wrong Answer\"); &#125; return 0;&#125; 完结撒花！","categories":[],"tags":[]},{"title":"字符串树「JSOI2015」","slug":"字符串树「JSOI2015」","date":"2020-01-21T05:00:56.000Z","updated":"2020-05-08T09:59:22.000Z","comments":true,"path":"post/7a74c5cc.html/","link":"","permalink":"http://akdream.tk/post/7a74c5cc.html/","excerpt":"","text":"【题目描述】萌萌买了一颗字符串树的种子，春天种下去以后夏天就能长出一棵很大的字符串树。字符串树很奇特，树枝上都密密麻麻写满了字符串，看上去很复杂的样子。字符串树本质上还是一棵树，即N个节点N-1条边的连通无向无环图，节点从1到N编号。与普通的树不同的是，树上的每条边都对应了一个字符串。萌萌和JYY在树下玩的时候，萌萌决定考一考JYY。每次萌萌都写出一个字符串S和两个节点U,V，需要JYY立即回答U和V之间的最短路径（即,之间边数最少的路径。由于给定的是一棵树，这样的路径是唯一的）上有多少个字符串以为前缀。JYY虽然精通编程，但对字符串处理却不在行。所以他请你帮他解决萌萌的难题。 【输入格式】输入第一行包含一个整数N，代表字符串树的节点数量。接下来N-1行，每行先是两个数U,V，然后是一个字符串S,表示节点和U节点V之间有一条直接相连的边，这条边上的字符串是S。输入数据保证给出的是一棵合法的树。接下来一行包含一个整数Q，表示萌萌的问题数。接来下Q行，每行先是两个数U,V，然后是一个字符串S,表示萌萌的一个问题是节点U和节点V之间的最短路径上有多少字符串以S为前缀。 【输出格式】输出Q行，每行对应萌萌的一个问题的答案。 题解前置知识点: 可持久化Trie 树链剖分/LCA 可持久化Trie支持查找一段区间内的所有字符串的相关信息在此题中可以树链剖分后查询路径上的字符串有多少个包含有询问的前缀码量稍大 其实就是道模板题 时间复杂度$O(q\\ log\\ n)$ 也可以直接用LCA做 免去了树剖 建Trie树时令以当前节点i代表的树从历史版本fa[i]转移过来 然后询问x~y的路径就用 树x + 树y - 树lca 就行了 实现更简单一点 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) if (ch == '-') f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ '0'); return x * f;&#125; int n, m, tot;int head[100005], pre[200005], to[200005], len[200005], sz;char s[200005][11], q[11];inline int o(char ch) &#123; return ch - 'a' + 1; &#125; inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v; pre[++sz] = head[v]; head[v] = sz; to[sz] = u;&#125;namespace Trie&#123; struct trie&#123; int son[30], sz; &#125; tr[5000005]; int rt[100005]; void insert(int d, int &amp;ind, int lst, char *str) &#123; ind = ++tot; tr[ind].sz = tr[lst].sz; if (str[d] &lt; 'a' || str[d] &gt; 'z') &#123; tr[ind].sz++; return; &#125; for (int i = 1; i &lt;= 26; i++) &#123; tr[ind].son[i] = tr[lst].son[i]; &#125; insert(d+1, tr[ind].son[o(str[d])], tr[lst].son[o(str[d])], str); for (int i = 1; i &lt;= 26; i++) &#123; tr[ind].sz += tr[tr[ind].son[i]].sz - tr[tr[lst].son[i]].sz; &#125; &#125; int query(int d, int lind, int rind, char *str) &#123; if (str[d] &lt; 'a' || str[d] &gt; 'z') &#123; return max(0, tr[rind].sz - tr[lind].sz); &#125; else return query(d+1, tr[lind].son[o(str[d])], tr[rind].son[o(str[d])], str); &#125;&#125;using namespace Trie;namespace Treechains&#123; int d[100005], dfn[100005], rnk[100005], tme, fa[100005], top[100005], siz[100005], son[100005], sonind[100005]; void dfs(int x, int fafa) &#123; siz[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fafa) continue; d[y] = d[x] + 1; fa[y] = x; dfs(y, x); siz[x] += siz[y]; if (!son[x] || siz[y] &gt; siz[son[x]]) son[x] = y, sonind[x] = i; &#125; &#125; void dfs2(int x, int tp) &#123; dfn[x] = ++tme; rnk[tme] = dfn[x]; top[x] = tp; if (son[x]) &#123; insert(1, rt[tme+1], rt[tme], s[sonind[x]]); dfs2(son[x], tp); &#125; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa[x] || y == son[x]) continue; insert(1, rt[tme+1], rt[tme], s[i]); dfs2(y, y); &#125; &#125; inline int query_path(int x, int y) &#123; int ret = 0; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) swap(x, y); ret += query(1, rt[dfn[top[x]]-1], rt[dfn[x]], q); x = fa[top[x]]; &#125; if (d[x] &gt; d[y]) swap(x, y); ret += query(1, rt[dfn[x]], rt[dfn[y]], q); return ret; &#125;&#125;using namespace Treechains;int main() &#123; n = read(); for (int i = 1; i &lt; n; i++) &#123; addedge(read(), read()); scanf(\"%s\", s[sz-1]+1); len[sz-1] = len[sz] = strlen(s[sz-1]+1); for (int j = 1; j &lt;= len[sz-1]; j++) s[sz][j] = s[sz-1][j]; &#125; dfs(1, 0); dfs2(1, 1); m = read(); for (int i = 1; i &lt;= m; i++) &#123; int x = read(), y = read(); scanf(\"%s\", q+1); query_path(x, y); printf(\"%d\\n\", query_path(x, y)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Trie树","slug":"Trie树","permalink":"http://akdream.tk/tags/Trie%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://akdream.tk/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"产奶模式「usaco2006」","slug":"产奶模式「USACO 2006」","date":"2020-01-20T14:31:35.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/c4229057.html/","link":"","permalink":"http://akdream.tk/post/c4229057.html/","excerpt":"","text":"【题目描述】农夫John发现他的奶牛产奶的质量一直在变动。经过细致的调查，他发现：虽然他不能预见明天产奶的质量，但连续的若干天的质量有很多重叠。我们称之为一个“模式”。 John的牛奶按质量可以被赋予一个$0$到$1000000$之间的数。并且John记录了$N(1\\le N\\le 20000)$天的牛奶质量值。他想知道最长的出现了至少$K(2\\le K\\le N)$次的模式的长度。比如1 2 3 2 3 2 3 1 中 2 3 2 3出现了两次。当$K=2$时，这个长度为4。 【输入格式】Line 1: 两个整数 N,K。Lines 2..N+1: 每行一个整数表示当天的质量值。 【输出格式】Line 1: 一个整数：N天中最长的出现了至少K次的模式的长度 题解 后缀数组+LCP(最长公共前缀)这个组合的好处是什么呢 一个字符串中的每个子串都必然是一个后缀的前缀 定义suf(i)表示s[i~n]定义height[i]表示suf(sa[i-1])与suf(sa[i])的最长公共前缀 即排名为i的后缀与他排名前一个的后缀的LCP关于height数组这里只给出求法 具体证明请自行百度 123456789void geth() &#123; int p = 0; for (int i = 1; i &lt;= n; i++) rnk[sa[i]] = i; for (int i = 1; i &lt;= n; i++) &#123; if (p) p--; int j = sa[rnk[i]-1]; while (s[i+p] == s[j+p]) p++; height[rnk[i]] = p; &#125;&#125; 引理1$LCP(suf(x), suf(y)) = min_{i=rnk[x]+1}^{rnk[y]} height[i]$证明略(其实是懒) 假设现在要找一个最长的子串 使得这个子串在原串中出现至少2次(可重叠)只需要找出height数组的最大值即是答案证明：假设$LCP(suf(x), suf(y))=k$不妨设rnk[x]&lt;rnk[y] 那么由引理1 一定有$LCP(suf(x), suf(sa[rnk[x]+1]))=height[rnk[x]+1]\\ge k$(sa[rnk[x]+1]即排名在suf(x)后一名的后缀) 那么如果出现至少3次呢 同理可得 如果存在一对连续的height[i],height[i+1]均大于等于m 就存在一个至少出现3次的长为m的子串 得出一般性结论 如果能找到一段连续k-1个height[i+1]height[i+k-1]均大于等于m 那么就存在一个出现至少k次的长为m的子串由引理1 这段区间内的k个后缀suf(sa[i])suf(sa[i+k-1])必然是两两有长度至少为m的LCP 对于这题 可以二分答案mid 然后判断是否存在一段k-1个height全部大于等于mid读入数据可以离散化一下 不离散化也无所谓 时间复杂度$O(n\\ log\\ n)$ 扩展: 求一个最长子串使得这个子串在原串中出现至少2次(不可重叠)方法: 二分答案 找出每一段 连续一些height全部大于二分值mid的区间 形如height[l+1]~height[r]如果$max_{i=l}^{r}sa[i]-min_{i=l}^{r}sa[i]\\ge mid$则必定存在不重叠的长为mid的相同子串(自行理解一下) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define mx 1000005using namespace std;int s[mx], srt[mx], mxx;int n, m, k, ans;int sa[mx], sa2[mx], rnk[mx], key[mx], sum[mx], height[mx];inline bool check(int *num, int a, int b, int l) &#123; return num[a] == num[b] &amp;&amp; num[a+l] == num[b+l]; &#125;inline void suffix() &#123; int i, j, p; int *_rnk = rnk, *_sa2 = sa2, *tmp; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[_rnk[i]=s[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[_rnk[i]]--] = i; for (j = 1; p &lt;= n; j &lt;&lt;= 1, m = p) &#123; p = 0; for (i = n - j + 1; i &lt;= n; i++) _sa2[++p] = i; for (i = 1; i &lt;= n; i++) if (sa[i] &gt; j) _sa2[++p] = sa[i] - j; for (i = 1; i &lt;= n; i++) key[i] = _rnk[_sa2[i]]; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[key[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[key[i]]--] = _sa2[i]; for (tmp = _rnk, _rnk = _sa2, _sa2 = tmp, p = 2, _rnk[sa[1]] = 1, i = 2; i &lt;= n; i++) &#123; _rnk[sa[i]] = check(_sa2, sa[i-1], sa[i], j) ? p - 1 : p++; &#125; &#125;&#125; inline void geth() &#123; int p = 0; for (int i = 1; i &lt;= n; i++) rnk[sa[i]] = i; for (int i = 1; i &lt;= n; i++) &#123; if (p) p--; int j = sa[rnk[i]-1]; while (s[i+p] == s[j+p]) p++; height[rnk[i]] = p; &#125;&#125;inline bool check(int mid) &#123; int p = 0; for (int i = 2; i &lt;= n; i++) &#123; if (height[i] &gt;= mid) p++; else p = 0; if (p &gt;= k - 1) return 1; &#125; return 0;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;s[i]); srt[i] = s[i]; &#125; sort(srt+1, srt+n+1); mxx = unique(srt+1, srt+n+1)-srt-1; for (int i = 1; i &lt;= n; i++) &#123; s[i] = lower_bound(srt+1, srt+mxx+1, s[i]) - srt; &#125; m = 1000000; suffix(); geth(); int l = 1, r = n, mid; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"队列变换「usaco2007」","slug":"队列变换「USACO 2007」 ","date":"2020-01-20T13:54:43.000Z","updated":"2020-10-08T12:16:08.819Z","comments":true,"path":"post/c83c82a7.html/","link":"","permalink":"http://akdream.tk/post/c83c82a7.html/","excerpt":"","text":"【题目描述】FJ打算带他的$N(1 \\leq N \\leq 30,000)$头奶牛去参加一年一度的“全美农场主大奖赛”。在这场比赛中，每个参赛者都必须让他的奶牛排成一列，然后领她们从裁判席前依次走过。 今年，竞赛委员会在接受队伍报名时，采用了一种新的登记规则：他们把所有队伍中奶牛名字的首字母取出，按它们对应奶牛在队伍中的次序排成一列（比如说，如果FJ带去的奶牛依次为Bessie、Sylvia、Dora，登记人员就把这支队伍登记为BSD）。登记结束后，组委会将所有队伍的登记名称按字典序升序排列，就得到了他们的出场顺序。 FJ最近有一大堆事情，因此他不打算在这个比赛上浪费过多的时间，也就是说，他想尽可能早地出场。于是，他打算把奶牛们预先设计好的队型重新调整一下。 FJ的调整方法是这样的：每次，他在原来队列的首端或是尾端牵出一头奶牛，把她安排到新队列的尾部，然后对剩余的奶牛队列重复以上的操作，直到所有奶牛都被插到了新的队列里。这样得到的队列，就是FJ拉去登记的最终的奶牛队列。 接下来的事情就交给你了：对于给定的奶牛们的初始位置，计算出按照FJ的调整规则所可能得到的字典序最小的队列。 【输入格式】第1行: 一个整数：N第2..N+1行: 第i+1行仅有1个‘A’..‘Z’中的字母，表示队列中从前往后数第i 头奶牛名字的首字母 【输出格式】输出FJ所能得到的字典序最小的队列。每行（除了最后一行）输 出恰好80个‘A’..‘Z’中的字母，表示新队列中每头奶牛姓名的首字母。 题解 第一篇写后缀数组的题解 先放下模板代码 123456789101112131415161718192021inline bool check(int *num, int a, int b, int l) &#123; return num[a] == num[b] &amp;&amp; num[a+l] == num[b+l]; &#125;void suffix() &#123; int i, j, p; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[rnk[i]=r[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[rnk[i]]--] = i; for (j = 1, p = 0; p &lt;= n; j &lt;&lt;= 1, m = p) &#123; p = 0; for (i = n - j + 1; i &lt;= n; i++) sa2[++p] = i; for (i = 1; i &lt;= n; i++) if (sa[i] &gt; j) sa2[++p] = sa[i] - j; for (i = 1; i &lt;= n; i++) key1[i] = rnk[sa2[i]]; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n; i++) sum[key1[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = n; i &gt;= 1; i--) sa[sum[key1[i]]--] = sa2[i]; for (swap(rnk, sa2), p = 2, rnk[sa[1]] = 1, i = 2; i &lt;= n; i++) &#123; rnk[sa[i]] = check(sa2, sa[i-1], sa[i], j) ? p - 1 : p++; &#125; &#125;&#125; sa[i]表示字典序为第i名的后缀的起始位置 rnk[i]表示起始位置为i的后缀的排名对这道题有什么用呢 先考虑一下暴力做法双指针l, r记录当前已经把a[1l-1]及a[r+1n]的奶牛扔到新队列里，现在原队列首尾分别是牛a[l]和a[r] 若a[l]&lt;a[r] 那么为使新队列字典序最小 显然要将a[l]先放到新队列里 反之亦然 若a[l]==a[r] 此时并不能直接判断要先把a[l]放入还是要先把a[r]放入举个例子 样例: ACDBCB 将a[1], a[6]先后放入新队列后发现此时a[2]==a[5] 显然是要先将a[5]放入 以便下一个放a[4] 比较优可以看出其实就是比较一下 字符串{a[2], a[3]} 和 {a[5], a[4]} 哪个字典序较小直接比较是O(n)的 考虑如何用后缀数组优化 将a[1]a[n]反转后接在后面 如样例: ACDBCB -&gt; ACDBCB|BCBDCA然后此时比较 字符串{a[2], a[3]} 和 {a[5], a[4]} 的大小就等同于比较 后缀[22n]和后缀[8~2n]的大小 p.s. 这个技巧也经常用于处理回文串有关的问题后缀大小排名是可以O(nlogn)预处理的 查询时就可以把r对称到另一边去 实现O(1)查询总时间复杂度O(nlogn) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define mx 1000005using namespace std;char one_time_AC_accepted[5];char s[mx], ans[mx];int n, m, len;int sa[mx], sa2[mx], rnk[mx], key[mx], sum[mx], height[mx];inline bool check(int *num, int a, int b, int l) &#123; return num[a] == num[b] &amp;&amp; num[a+l] == num[b+l]; &#125;inline void suffix() &#123; int i, j, p; int *_rnk = rnk, *_sa2 = sa2, *tmp; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= 2*n; i++) sum[_rnk[i]=s[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = 2*n; i &gt;= 1; i--) sa[sum[_rnk[i]]--] = i; for (j = 1; p &lt;= 2*n; j &lt;&lt;= 1, m = p) &#123; p = 0; for (i = n*2 - j + 1; i &lt;= 2*n; i++) _sa2[++p] = i; for (i = 1; i &lt;= 2*n; i++) if (sa[i] &gt; j) _sa2[++p] = sa[i] - j; for (i = 1; i &lt;= 2*n; i++) key[i] = _rnk[_sa2[i]]; for (i = 1; i &lt;= m; i++) sum[i] = 0; for (i = 1; i &lt;= n*2; i++) sum[key[i]]++; for (i = 2; i &lt;= m; i++) sum[i] += sum[i-1]; for (i = 2*n; i &gt;= 1; i--) sa[sum[key[i]]--] = _sa2[i]; for (tmp = _rnk, _rnk = _sa2, _sa2 = tmp, p = 2, _rnk[sa[1]] = 1, i = 2; i &lt;= 2*n; i++) &#123; _rnk[sa[i]] = check(_sa2, sa[i-1], sa[i], j) ? p - 1 : p++; &#125; &#125;&#125; inline void print() &#123; for (int i = 1; i &lt;= len; i++) &#123; putchar(ans[i]); if (i % 80 == 0) puts(\"\"); &#125;&#125;inline bool check(int l0, int r0) &#123; return rnk[(n&lt;&lt;1)-r0+1] &gt; rnk[l0];&#125;int main() &#123; scanf(\"%d\", &amp;n); m = 128; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", one_time_AC_accepted); s[i] = one_time_AC_accepted[0]; &#125; for (int i = 1; i &lt;= n; i++) &#123; s[n * 2 - i + 1] = s[i]; &#125; suffix(); int l = 1, r = n; for (int i = 1; i &lt;= n; i++) &#123; if (s[l] &lt; s[r]) &#123; ans[++len] = s[l]; l++; &#125; else if (s[l] &gt; s[r]) &#123; ans[++len] = s[r]; r--; &#125; else &#123; if (check(l, r)) &#123; ans[++len] = s[l]; l++; &#125; else &#123; ans[++len] = s[r]; r--; &#125; &#125; &#125; print(); return 0;&#125;","categories":[],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"染色「sdoi2011」","slug":"染色「SDOI 2011」","date":"2019-12-29T05:17:11.000Z","updated":"2020-02-12T05:51:00.000Z","comments":true,"path":"post/427ce7df.html/","link":"","permalink":"http://akdream.tk/post/427ce7df.html/","excerpt":"","text":"【题目描述】给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。 请你写一个程序依次完成这m个操作。 【输入格式】第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面n-1行每行包含两个整数x和y，表示x和y之间有一条无向边。下面m行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。 【输出格式】对于每个询问操作，输出一行答案。 题解看到这种树上操作路径的题大概率就是树链剖分了先考虑一下 如果是一条链要怎么做显然 可以用线段树维护 每个区间记录三个值：此区间内的颜色段数量，区间最左边点的颜色，区间最右边点的颜色那么 一个区间的颜色段数量=左区间颜色段数量+右区间颜色段数量-(左区间最右颜色==右区间最左颜色)；最左边点颜色=左区间最左点颜色 最右边点颜色=右区间最右边点颜色查询也是差不多 把左儿子返回的结果(这里可以返回一个结构体)和右儿子返回的结果按上一行的方法合并一下即可 然而树剖查询一条路径时是有最多log次的线段树区间查询 而不是直接查询一个区间 怎么合并这些查询答案统计出最终答案呢其实只需要记录一下上一次查询区间的左端点颜色 如果和这一次查询区间的右端点颜色相同 答案-1即可具体可见代码 统计答案这段还是有点抽搐 ps: 这题线段树区间修改要打懒标记 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, a[100005], b1, b2, b3, lst[10];int head[100005], pre[200005], to[200005], sz;int fa[100005], d[100005], st[100005], dfn[100005], son[100005], pos[100005], siz[100005], tme;char tp[5];struct segtree&#123; int l, r, lcol, rcol, cnt, tag; segtree() &#123; lcol = rcol = tag = -1; l = r = cnt = 0; &#125;&#125; tr[400005];inline void addedge(int u, int v) &#123; pre[++sz] = head[u]; head[u] = sz; to[sz] = v;&#125;namespace Segtree&#123; inline void pushup(int ind) &#123; tr[ind].cnt = tr[ind&lt;&lt;1].cnt + tr[ind&lt;&lt;1|1].cnt - (tr[ind&lt;&lt;1].rcol == tr[ind&lt;&lt;1|1].lcol); tr[ind].lcol = tr[ind&lt;&lt;1].lcol; tr[ind].rcol = tr[ind&lt;&lt;1|1].rcol; &#125; inline void pushdown(int ind) &#123; if (tr[ind].tag == -1) return; tr[ind&lt;&lt;1].cnt = tr[ind&lt;&lt;1|1].cnt = 1; tr[ind&lt;&lt;1].lcol = tr[ind&lt;&lt;1|1].lcol = tr[ind&lt;&lt;1].rcol = tr[ind&lt;&lt;1|1].rcol = tr[ind].tag; tr[ind&lt;&lt;1].tag = tr[ind&lt;&lt;1|1].tag = tr[ind].tag; tr[ind].tag = -1; &#125; void build(int ind, int l, int r) &#123; tr[ind] = segtree(); tr[ind].l = l; tr[ind].r = r; tr[ind].tag = -1; if (l == r) &#123; tr[ind].cnt = 1; tr[ind].lcol = tr[ind].rcol = a[pos[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(ind&lt;&lt;1, l, mid); build(ind&lt;&lt;1|1, mid+1, r); pushup(ind); &#125; void update(int ind, int x, int y, int v) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; tr[ind].cnt = 1; tr[ind].lcol = tr[ind].rcol = v; tr[ind].tag = v; return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); if (x &lt;= mid) update(ind&lt;&lt;1, x, y, v); if (mid &lt; y) update(ind&lt;&lt;1|1, x, y, v); pushup(ind); &#125; inline segtree merge(segtree a, segtree b) &#123; segtree ret = segtree(); ret.cnt = a.cnt + b.cnt - (a.rcol == b.lcol); ret.lcol = a.lcol; ret.rcol = b.rcol; return ret; &#125; segtree query(int ind, int x, int y) &#123; int l = tr[ind].l, r = tr[ind].r; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return tr[ind]; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(ind); segtree ret1 = segtree(), ret2 = segtree(); if (x &lt;= mid) ret1 = query(ind&lt;&lt;1, x, y); if (mid &lt; y) ret2 = query(ind&lt;&lt;1|1, x, y); if (!ret1.cnt) return ret2; else if (!ret2.cnt) return ret1; else return merge(ret1, ret2); &#125;&#125;using namespace Segtree;namespace treechains&#123; void dfs1(int x, int f) &#123; siz[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == f) continue; d[y] = d[x] + 1; fa[y] = x; dfs1(y, x); siz[x] += siz[y]; if (siz[y] &gt; siz[son[x]]) son[x] = y; &#125; &#125; void dfs2(int x, int start) &#123; dfn[x] = ++tme; pos[tme] = x; st[x] = start; if (son[x]) dfs2(son[x], start); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y != fa[x] &amp;&amp; y != son[x]) dfs2(y, y); &#125; &#125; void change(int x, int y, int z) &#123; while (st[x] != st[y]) &#123; if (d[st[x]] &lt; d[st[y]]) swap(x, y); update(1, dfn[st[x]], dfn[x], z); x = fa[st[x]]; &#125; if (dfn[x] &gt; dfn[y]) swap(x, y); update(1, dfn[x], dfn[y], z); &#125; int ask(int x, int y) &#123; int ret = 0, o = 0; lst[0] = lst[1] = -1; //lst[0]: x~lca这条链上上一次查询的左端点颜色; lst[1]: y~lca这条链上上一次查询的左端点颜色 segtree tmp = segtree(); while (st[x] != st[y]) &#123; if (d[st[x]] &lt; d[st[y]]) swap(x, y), o ^= 1; tmp = query(1, dfn[st[x]], dfn[x]); ret += tmp.cnt - (tmp.rcol == lst[o]); lst[o] = tmp.lcol; x = fa[st[x]]; &#125; if (dfn[x] &gt; dfn[y]) swap(x, y), o ^= 1; tmp = query(1, dfn[x], dfn[y]); if (!o) &#123; ret += tmp.cnt - (lst[0] == tmp.lcol) - (lst[1] == tmp.rcol); &#125; else &#123; ret += tmp.cnt - (lst[1] == tmp.lcol) - (lst[0] == tmp.rcol); &#125; return ret; &#125;&#125;using namespace treechains;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt; n; i++) &#123; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); addedge(x, y); addedge(y, x); &#125; dfs1(1, 0); dfs2(1, 1); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%s\", tp); if (tp[0] == 'C') &#123; scanf(\"%d %d %d\", &amp;b1, &amp;b2, &amp;b3); change(b1, b2, b3); &#125; else &#123; scanf(\"%d %d\", &amp;b1, &amp;b2); printf(\"%d\\n\", ask(b1, b2)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://akdream.tk/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"永无乡「HNOI2012」","slug":"永无乡「HNOI2012」","date":"2019-12-19T12:45:55.000Z","updated":"2020-10-08T12:16:08.592Z","comments":true,"path":"post/e04bdb19.html/","link":"","permalink":"http://akdream.tk/post/e04bdb19.html/","excerpt":"","text":"【题目描述】永无乡包含 n 座岛，编号从 1 到 n，每座岛都有自己的独一无二的重要度，按照重要度可 以将这 n 座岛排名，名次用 1 到 n 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛 到达另一个岛。如果从岛 a 出发经过若干座（含 0 座）桥可以到达岛 b，则称岛 a 和岛 b 是连 通的。现在有两种操作：B x y 表示在岛 x 与岛 y 之间修建一座新桥。Q x k 表示询问当前与岛 x连通的所有岛中第 k 重要的是哪座岛，即所有与岛 x 连通的岛中重要度排名第 k 小的岛是哪 座，请你输出那个岛的编号。 【输入格式】输入文件第一行是用空格隔开的两个正整数 n 和 m，分别 表示岛的个数以及一开始存在的桥数。接下来的一行是用空格隔开的 n 个数，依次描述从岛 1 到岛 n 的重要度排名。随后的 m 行每行是用空格隔开的两个正整数 ai 和 bi，表示一开始就存 在一座连接岛 ai 和岛 bi 的桥。后面剩下的部分描述操作，该部分的第一行是一个正整数 q， 表示一共有 q 个操作，接下来的 q 行依次描述每个操作，操作的格式如上所述，以大写字母 Q 或B 开始，后面跟两个不超过 n 的正整数，字母与数字以及两个数字之间用空格隔开。 【输出格式】对于每个 Q x k 操作都要依次输出一行，其中包含一个整数，表 示所询问岛屿的编号。如果该岛屿不存在，则输出-1。 如果是单一的一个问题 求$a_1\\sim a_n$中第$k$小的数是什么 显然是可以用一棵权值线段树直接实现的 这里要在岛之间连边 即把两个连通块合并 可以用一个线段树合并的奇技淫巧 什么是线段树合并？简单来说 就是把两个线段树上对应的点的权值相加得到新的线段树一般需要线段树合并的题 如果直接建树 空间复杂度都会十分巨大 所以一般会使用动态开点 合并时注意一下新树节点的左右儿子放张图理解一下线段树合并 线段树合并代码 12345678910int merge_tr(int idx, int idy) &#123; if (!idx) return idy; if (!idy) return idx; tr[idx].val += tr[idy].val; //权值 tr[idx].lc = merge_tr(tr[idx].lc, tr[idy].lc); //左儿子 tr[idx].rc = merge_tr(tr[idx].rc, tr[idy].rc); //右儿子 return idx;&#125;//root[x] = merge(root[x], root[y]); 所以操作就非常简单了 并查集维护连通性 每次把两个连通块连起来就合并这两棵权值线段树作为新连通块的树 每次在 查询点所在连通块 的那棵树上找第$k$小就行 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;struct segtree&#123; int lc, rc, val;&#125;tr[6000005];int n, m, q, a[100005], rk[100005], rt[100005], tot, fa[100005];char tp[15];void update(int &amp;ind, int l, int r, int x) &#123; if (!ind) ind = ++tot; if (l == r) &#123; tr[ind].val = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(tr[ind].lc, l, mid, x); if (x &gt; mid) update(tr[ind].rc, mid+1, r, x); tr[ind].val = tr[tr[ind].lc].val + tr[tr[ind].rc].val;&#125;void init() &#123; for (int i = 1; i &lt;= n; i++) &#123; update(rt[i], 1, n, a[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; fa[i] = i; &#125;&#125;int get(int x) &#123; if (fa[x] == x) return x; else return fa[x] = get(fa[x]);&#125;int merge_tr(int idx, int idy) &#123; if (!idx) return idy; if (!idy) return idx; tr[idx].val += tr[idy].val; tr[idx].lc = merge_tr(tr[idx].lc, tr[idy].lc); tr[idx].rc = merge_tr(tr[idx].rc, tr[idy].rc); return idx;&#125;void merge(int x, int y) &#123; int tx = get(x), ty = get(y); if (tx != ty) &#123; fa[ty] = tx; rt[tx] = merge_tr(rt[tx], rt[ty]); &#125;&#125;int query(int ind, int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1; if (tr[tr[ind].lc].val &gt;= k) return query(tr[ind].lc, l, mid, k); else return query(tr[ind].rc, mid+1, r, k - tr[tr[ind].lc].val);&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); rk[a[i]] = i; &#125; init(); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); merge(x, y); &#125; scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf(\"%s\", tp); int x, y; scanf(\"%d %d\", &amp;x, &amp;y); if (tp[0] == 'B') &#123; merge(x, y); &#125; else &#123; int tx = get(x); if (tr[rt[tx]].val &lt; y) puts(\"-1\"); else printf(\"%d\\n\", rk[query(rt[tx], 1, n, y)]); &#125; &#125; return 0; &#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"蒟蒻选手的CSP2019游记","slug":"蒟蒻选手的CSP2019游记 ","date":"2019-11-16T05:35:02.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/426bf9a6.html/","link":"","permalink":"http://akdream.tk/post/426bf9a6.html/","excerpt":"","text":"D0前一天晚上慌的一批 敲了一大堆模板题来调整心态大概10:00就睡了 D1开考之前都挺顺利的 开考先看T1 好像挺简单的 不到5分钟就推出了规律然后发现$2^64$心想是不是要写高精了。。。然而发现ull就可以了差不多花了20min T2想起以前做的这种括号问题是用栈匹配的 多少有了点头绪决定用树形DP 然后推了推DP方程 推出一个似乎正确的DP方程然后大样例倒都过了 就再检查一遍就走了 差不多用了40~60min吧(晚上Luogu出了民间数据 凭印象重写一遍只有20pts 慌的一批 还好考场写的代码是能AC的) T3不会做 于是就乱搞 写了个菊花图的情况 然后爆0(最后爆0还是因为CE。。。不过不CE也是0分) 下午是普及组T1T2乱水一波就过了 T3看出来是背包 然后努力推了推DP方程 期间错了几次 最后推出来一个对的 但是时间复杂度似乎有点不对 然而大样例都跑的挺快 自己造的卡满的数据也没卡掉 于是就不管了 最后居然只有90pts QAQ 被毒瘤老爷机卡掉一个点 T4考试时候真是傻了。。。这么简单的题没想出正解于是就开始搞暴力 用bitset来记录一下第i次移动能到哪些人那里 然后就暴力转移然后光荣的TLE了 60pts D2T1就把我弄傻了 原先我只有指数级算法 后来发现那些指数级算法的计数都可以用$o(n^3)$的DP解决 而且这几个DP长得都差不多 9:30搞到$O(n^4m)$然后加了前缀和优化到$O(n^3m)$然后过了那几个小的大样例就走了 耗时90min 最终64pts T2可开心了 用了15min乱写了个弱智的$O(n^2)$DP 然后大样例没TLE的都过了不会证这个DP是正确的 也不会写多项式复杂度的对拍 然后就放弃了这题最终得分64pts T3直接O(n^2)暴力枚举删边找重心然后处理了一下链的情况 没去找找满二叉树的规律太可惜了最终55pts 普及: 100+100+90+60=350 有点蓝瘦提高: 100+100+0 + 64+64+55=383 这个感觉还行","categories":[],"tags":[]},{"title":"蚯蚓「NOIP2016」","slug":"蚯蚓「NOIP2016」","date":"2019-11-14T00:20:45.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/563ea6c0.html/","link":"","permalink":"http://akdream.tk/post/563ea6c0.html/","excerpt":"","text":"【题目描述】本题中，我们将用符号$\\lfloor c \\rfloor$表示对$c$向下取整，例如：$\\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3$。 蛐蛐国里现在共有$n$只蚯蚓（$n$为正整数）。每只蚯蚓拥有长度，我们设第$i$只蚯蚓的长度为$a_i$ （$i = 1, 2, \\ldots , n$)，并保证所有的长度都是非负整数（即：可能存在长度为$0$的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数$p$（是满足$0 &lt; p &lt; 1$的有理数）决定，设这只蚯蚓长度为$x$，神刀手会将其切成两只长度分别为$\\lfloor px \\rfloor$和$x - \\lfloor px \\rfloor$的蚯蚓。特殊地，如果这两个数的其中一个等于$0$，则这个长度为$0$的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加$q$（是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要$m$秒才能到来 ……（$m$为非负整数） 蛐蛐国王希望知道这$m$秒内的战况。具体来说，他希望知道： 1.$m$秒内，每一秒被切断的蚯蚓被切断前的长度（有$m$个数）；2.$m$秒后，所有蚯蚓的长度（有$n + m$个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你 …… 【输入格式】第一行包含六个整数$n$，$m$，$q$，$u$，$v$，$t$，其中：$n$，$m$，$q$的意义见「问题描述」；$u$，$v$，$t$均为正整数，你需要自己计算$p = \\frac{u}{v}$（保证$0 &lt; u &lt; v$）；$t$是输出参数，其含义将会在「输出格式」中解释。第二行包含$n$个非负整数，为$a_1, a_2, \\ldots, a_n$，即初始时$n$只蚯蚓的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。 保证$1 \\leq n \\leq 10 ^ 5$，$0 &lt; m &lt; 7 \\times 10 ^ 6$，$0 &lt; u &lt; v &lt; 10 ^ 9$，$0 \\leq q \\leq 200$，$1 &lt; t &lt; 71$，$0 &lt; a_i &lt; 10 ^ 8$。 【输出格式】第一行输出$\\lfloor \\frac{m}{t} \\rfloor$个整数，按时间顺序，依次输出第$t$秒，第$2t$秒，第$3t$秒 …… 被切断蚯蚓（在被切断前）的长度。第二行输出$\\lfloor \\frac{(n+m)}{t} \\rfloor$个整数，输出$m$秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第$t$，第$2t$，第$3t$…… 的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。 【题解】直接用大根堆跑暴力会被卡掉。。。差不多是$O((n+m)log(n+m))$ 正解是$O(n+m)$的 性质一：如果一条蚯蚓i 比 蚯蚓j 先被切掉 那么i的两个切出来的小段中较短的那段 也一定比 j切出来的较短的那段 先被切掉 较长的那段同理证明：设i现在的长度为$a_i$，j现在的长度为$a_j$，那么i这次被切出来的一个小段为$\\lfloor pa_i \\rfloor$，一秒后变为$\\lfloor pa_i \\rfloor+q$; j在下一秒被切掉 切出来的一个小段为$\\lfloor pa_j+q \\rfloor$若$a_i &gt; a_j$则易证$\\lfloor pa_i \\rfloor+q &gt; \\lfloor pa_j+q \\rfloor$。 所以其实这道题具有一定的单调性 维护三个队列：队列1存储还一次都没有被切的蚯蚓长度 队列2存储被切掉的那些蚯蚓两段中较长的那些段 队列3存储切掉后剩下较短的那些段开始时按从大到小的顺序把蚯蚓长度全部放进队列1 然后每次从1，2，3三个队列的首端取一个最大的切掉 然后把切出来的两段分别丢进队列2，3答案就边做边记录一下 每秒结束后增长$q$的操作其实可以比较优美的处理 具体见代码 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll n, m, u, qq, v, t, a[1000005], nowlen;ll q[7000005], q2[7000005], q3[7000005], head = 1, head2 = 1, head3 = 1, tail, tail2, tail3;ll ans[7000005], ans2[8000005], sz;ll getmax() &#123; ll x = -0x7fffffff, x2 = -0x7fffffff, x3 = -0x7fffffff; if (head &lt;= tail) x = q[head]; if (head2 &lt;= tail2) x2 = q2[head2]; if (head3 &lt;= tail3) x3 = q3[head3]; if (x &gt;= x2 &amp;&amp; x &gt;= x3) &#123; head++; return x; &#125; else if (x2 &gt;= x &amp;&amp; x2 &gt;= x3) &#123; head2++; return x2; &#125; else &#123; head3++; return x3; &#125;&#125;int main() &#123; scanf(\"%lld %lld %lld %lld %lld %lld\", &amp;n, &amp;m, &amp;qq, &amp;u, &amp;v, &amp;t); for (ll i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); &#125; sort(a + 1, a + n + 1, greater&lt;ll&gt;() ); for (ll i = 1; i &lt;= n; i++) q[++tail] = a[i]; for (ll i = 1; i &lt;= m; i++) &#123; ans[i] = getmax() + nowlen; ll x = ans[i] * u / v, y = ans[i] - x; nowlen += qq; if (x &lt; y) swap(x, y); q2[++tail2] = x - nowlen; q3[++tail3] = y - nowlen; &#125; while (head &lt;= tail || head2 &lt;= tail2 || head3 &lt;= tail3) ans2[++sz] = getmax() + nowlen; for (ll i = t; i &lt;= m; i += t) printf(\"%lld \", ans[i]); putchar('\\n'); for (ll i = t; i &lt;= sz; i += t) printf(\"%lld \", ans2[i]); putchar('\\n'); return 0;&#125;","categories":[],"tags":[]},{"title":"Matching「CEOI2011」","slug":"Matching「CEOI2011」","date":"2019-11-13T08:11:23.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/5d48d089.html/","link":"","permalink":"http://akdream.tk/post/5d48d089.html/","excerpt":"","text":"【题目描述】对于整数序列$(a_1,a_2,a_3,\\cdots,a_n)$和$1 \\sim n$的排列$(p_1,p_2,p_3,\\cdots,p_n)$，称$(a_1,a_2,a_3,\\cdots,a_n)$符合$(p_1,p_2,p_3,\\cdots,p_n)$，当且仅当 $a$中任意两个数字互不相同 将$a$从小到大排序后，将会得到$(a_{p_1},a_{p_2},a_{p_3},\\cdots,a_{p_n})$。 现在给出$1 \\cdots n$的排列$\\{p\\}$和序列$\\{h\\}$，求出哪些$\\{h\\}$的子串符合排列$\\{p\\}$。 【输入格式】第一行两个空格隔开的正整数$n,m$。第二行$n$个空格隔开的正整数，表示排列$p$。第三行$m$个空格隔开的正整数，表示序列$h$。 【输出格式】第一行一个整数$k$，表示符合${p}$的子串个数。第二行$k$个空格隔开的正整数，表示这些子串的起始位置（编号从$1$开始）。请将这些位置按照从小到大的顺序输出。特别地，若$k=0$，那么你也应当输出一个空行。 虽然说看起来不像 但是这题是个KMP匹配 注意到 对于一个数组$a_{1 \\sim n}$，其中$a_i$表示第$i$个数在$n$个数中的相对大小是第$a_i$大，假设另一个数组$cnt_{1 \\sim n}$表示第$i$个数前面有$cnt_i$个数比它大，那么这样的一个$cnt$数组和$a$数组是一一对应的。以样例$2,1,4,5,3$为例 对应的$cnt$数组是$0,0,2,3,2$ 于是 我们把原题转变为了求${h}$中的一段长为$n$的子串 对应的$cnt$数组 和 排列${p}$对应的$cnt$数组相等这里直接暴力枚举是$O(nm)$的 肯定会炸 所以考虑用KMP的思想 令$nxt[i]$表示排列${p}$中最长的 前缀的$cnt$数组和后缀的$cnt$数组相同 的长度(类似KMP)求法就和KMP差不多 具体见代码主要是如何快速求出$cnt$数组呢？这个用树状数组或线段树就能很容易的实现 每次在 当前数的值 的位置单点修改+1(即上文第二段的$a_i$) 然后查询$1 \\sim a_i-1$的和以样例为例$2,1,4,5,3$第一次让位置2 ++ 然后查询$1 \\sim 1$得到0第二次让位置1 ++ 查询$1 \\sim 0$得到0第三次让位置4 ++ 查询$1 \\sim 3$得到2以此类推 注意题目中的${h}$序列需要离散化处理一下 剩下的就是和KMP差不多的匹配了 注意每次失配时把失配扔掉的那些元素在树状数组上-1 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;iostream&gt; #include &lt;algorithm&gt;#include &lt;cstring&gt;#define lowbit(x) x&amp;(-(x))using namespace std;int n, m, sz;int q[1000010], h[1000010], srt[1000010], cnt[1000010];int tr[1000010];int nxt[1000010];int ans[1000010];void updata(int ind, int x) &#123; while (ind &lt;= m) &#123; tr[ind] += x; ind += lowbit(ind); &#125;&#125;int getsum(int ind) &#123; int ret = 0; while (ind) &#123; ret += tr[ind]; ind -= lowbit(ind); &#125; return ret;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int a; scanf(\"%d\", &amp;a); q[a] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;h[i]); srt[i] = h[i]; &#125; sort(srt + 1, srt + m + 1); int len = unique(srt + 1, srt + m + 1) - srt - 1; for (int i = 1; i &lt;= m; i++) &#123; h[i] = lower_bound(srt + 1, srt + len + 1, h[i]) - srt; &#125; cnt[n + 1] = -0x7fffffff; for (int i = 1; i &lt;= n; i++) &#123; cnt[i] = getsum(q[i]); updata(q[i], 1); &#125; for (int i = 1; i &lt;= m; i++) &#123; tr[i] = 0; &#125; for (int i = 2, j = 0; i &lt;= n; i++) &#123; while (j &amp;&amp; getsum(q[i]) != cnt[j + 1]) &#123; for (int k = i - j; k &lt; i - nxt[j]; k++) updata(q[k], -1); j = nxt[j]; &#125; if (getsum(q[i]) == cnt[j + 1]) &#123; j++; updata(q[i], 1); &#125; nxt[i] = j; &#125; for (int i = 1; i &lt;= m; i++) &#123; tr[i] = 0; &#125; for (int i = 1, j = 0; i &lt;= m; i++) &#123; while (j &amp;&amp; getsum(h[i]) != cnt[j + 1]) &#123; for (int k = i - j; k &lt; i - nxt[j]; k++) updata(h[k], -1); j = nxt[j]; &#125; if (getsum(h[i]) == cnt[j + 1]) &#123; j++; updata(h[i], 1); &#125; if (j == n) &#123; ans[++sz] = i - n + 1; &#125; &#125; printf(\"%d\\n\", sz); for (int i = 1; i &lt;= sz; i++) &#123; printf(\"%d \", ans[i]); &#125; puts(\"\"); return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://akdream.tk/tags/KMP/"}]},{"title":"sza-template「poi 2005」","slug":"Sza-Template「POI 2005」","date":"2019-10-28T13:55:53.000Z","updated":"2020-10-08T12:16:08.104Z","comments":true,"path":"post/61261493.html/","link":"","permalink":"http://akdream.tk/post/61261493.html/","excerpt":"","text":"【题目描述】Byteasar 想在墙上涂一段很长的字符,他为了做这件事从字符的前面一段中截取了一段作为模版. 然后将模版重复喷涂到相应的位置后就得到了他想要的字符序列.一个字符可以被喷涂很多次,但是一个位置不能喷涂不同的字符.做一个模版很费工夫,所以他想要模版的长度尽量小,求最小长度是多少.拿样例来说 ababbababbabababbabababbababbaba , 模版为前8个字符ababbaba，是最小的模板长度。 【输入格式】输入一行最多不超过$500000$个，最少$1$个小写字符。 【输出格式】一个数表示最小的模板长度。 有一说一 这题我又不会做 我是听了题解之后还挣扎了半天才理解的 前置知识：KMP首先 把这个串的$nxt$数组(就是KMP里那个)求出来 然后建出这个串的$fail$树在这里 我举一个例子来帮助理解这题设给的串是 aabaaba 显然答案是4 即最小模板为 aaba $nxt$数组 $fail$树(让每个$i$连向$nxt[i]$) 我根本就不会画图 因为模板串必然是主串的一个前缀 也必然是主串的一个后缀 所以可能的答案只会在$0\\sim n$的这条链上(不包括0)再考虑一个问题 设主串为$s$$fail$树上的一个点$i$对于它子树里的所有点$j$一定满足$s[1\\sim i]$是$s[1\\sim j]$的一个后缀(有点绕) 为什么？不知道就再回去看看$nxt$数组的定义所以我们可以等价理解为 当且仅当$j$是$i$子树中的一个节点时，我们可以把$s[1\\sim i]$喷涂在$j-i+1 \\sim j$的位置上 即喷涂到一段以$j$结尾 长为$i$的区间上 —–分割线 理解之后继续看下面的——– 理解了这个之后 剩下的操作就比较简单了 把$0 \\sim n$链上的点全部打上标记 从$0$开始dfs，每次到一个点，遍历它所有的儿子节点 若一个儿子节点被标记了 就表示这是链上的下一个点 把它设为$y$若一个儿子节点没有被标记 那就把它子树中(包括自己)所有的点$j$的$deleted[j]$设为1$deleted[j]=1$表示$s[1\\sim y]$这个串不能被喷涂在以$j$结尾的位置上然后删除的时候顺便维护一下 当前最长的一段连续的$deleted[j]$都为1的有多长 记为$mx$处理完所有子节点后向那个打了标记的子节点继续深搜 每到达一个打了标记的点$x$之后立即判断 若$mx &lt; x$即长为$x$的模板已经足够覆盖所有空缺处$x$就是一个符合题意的答案 由于$fail$树的父节点一定比子节点编号小 所以链上第一个$x$就是最小答案 附：样例 程序实现过程 【代码】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ri register intusing namespace std;char ch[500005];int n, the_nxt[500005];int head[500005], pre[1000005], to[1000005], sz;int pr[500005], nxt[500005];bool mark[500005];int mx, ans;void insert(int u, int v) &#123; pre[++sz] = head[u]; to[sz] = v; head[u] = sz;&#125;void del(int x, int fa) &#123; pr[nxt[x]] = pr[x]; nxt[pr[x]] = nxt[x]; mx = max(mx, nxt[x] - pr[x] - 1); for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; del(y, x); &#125;&#125;void dfs(int x, int fa) &#123; if (x &gt; mx) return ans = x, void(); int nnxt; for (int i = head[x]; i; i = pre[i]) &#123; int y = to[i]; if (y == fa) continue; if (!mark[y]) del(y, x); else nnxt = y; &#125; dfs(nnxt, x);&#125;int main() &#123; scanf(\"%s\", ch + 1); n = strlen(ch + 1); for (ri i = 2, j = 0; i &lt;= n; i++) &#123; while (j &amp;&amp; ch[j+1] != ch[i]) j = the_nxt[j]; if (ch[j+1] == ch[i]) j++; the_nxt[i] = j; &#125; for (ri i = 1; i &lt;= n; i++) &#123; insert(i, the_nxt[i]); insert(the_nxt[i], i); &#125; for (ri i = n; i &gt; 0; i = the_nxt[i]) mark[i] = 1; mark[0] = 1; for (ri i = 1; i &lt;= n; i++) &#123; pr[i] = i-1; nxt[i] = i+1; &#125; dfs(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://akdream.tk/tags/KMP/"}]},{"title":"普通图论题","slug":"普通图论题","date":"2019-10-24T14:21:38.000Z","updated":"2020-10-08T12:16:08.518Z","comments":true,"path":"post/deb9583d.html/","link":"","permalink":"http://akdream.tk/post/deb9583d.html/","excerpt":"","text":"【题目描述】给定一棵$n$个点的树，标记出$m$个不同的点$s_1,s_2,s_3,\\cdots,s_m$，对于每个点$s_i$求出剩下的标记点中哪个离$s_i$最近，输出距离。 【输入格式】第一行一个整数$n$。第$2\\sim n$行每行两个整数$u,w$，第$i$行表示$i$与父亲$u$之间有一条权为$w$的边。 接下来一行一个整数$m$。接下来一行$m$个整数表示$s_1\\sim s_m$。 【输出格式】输出一行空格隔开的$m$个整数，第$i$个数代表$s_i$的答案。 【数据范围】$2 \\le m \\le n \\le 10^6$，$0 \\le w \\le 10^9$ 暴力做法就很简单 什么最短路LCA之类的随便搞一搞就行然而还是要DP 假设根节点是1，令$f[i]$表示$i$子树内的最小答案，这个答案显然是一遍dfs就能跑出来。子树外的答案怎么推呢？ 其实也挺简单 设$ans[i]$是$i$的最终答案 设$fa$是$i$的父亲情况1$ans[fa]$指的就是$fa$到$i$的距离 即距离$fa$最近的标记点就是$i$此时用$fa$的次小值$ans2[fa]$来更新$ans[i]$即$ans[i]=min(ans[i], ans2[fa]+dis[fa][i]) \\ dis[fa][i]$指$i$到$fa$边的长度 情况2 距离$fa$最近的标记点不是$i$（或者$i$根本不是标记点）显然$ans[i]=min(ans[i], ans[fa]+dis[fa][i])$ 在更新最小值的同时顺便更新一下次小值就行了 具体看代码 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define re registerusing namespace std;typedef long long ll;ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; ret = (ret &lt;&lt; 1) + (ret &lt;&lt; 3) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125;ll n, m, head[2000005], pre[2000005], to[2000005], val[2000005], sz, s[1000005];bool spe[1000005];ll f[1000005], ind[1000005], f2[1000005], ind2[1000005];inline void insert(ll u, ll v, ll w) &#123; to[++sz] = v; pre[sz] = head[u]; head[u] = sz; val[sz] = w;&#125; void update(ll x, ll y, ll v) &#123; if (v &lt; f[x]) &#123; f2[x] = f[x]; ind2[x] = ind[x]; f[x] = v; ind[x] = y; &#125; else if (v &lt; f2[x]) &#123; f2[x] = v; ind2[x] = y; &#125;&#125;void dfs(ll x, ll fa) &#123; if (spe[x]) &#123; f[x] = 0; ind[x] = x; &#125; for (re int i = head[x]; i; i = pre[i]) &#123; ll y = to[i]; if (y == fa) continue; dfs(y, x); update(x, y, f[y] + val[i]); &#125;&#125;void dfs2(ll x, ll fa) &#123; for (re int i = head[x]; i; i = pre[i]) &#123; ll y = to[i]; if (y == fa) continue; if (y == ind[x]) &#123; if (f[y] &gt; f2[x] + val[i]) &#123; f2[y] = f[y]; ind2[y] = ind[y]; f[y] = f2[x] + val[i]; ind[y] = ind2[x]; &#125; else if (f2[y] &gt; f2[x] + val[i]) &#123; f2[y] = f2[x] + val[i]; ind2[y] = ind2[x]; &#125; &#125; else &#123; if (f[y] &gt; f[x] + val[i]) &#123; f2[y] = f[y]; ind2[y] = ind[y]; f[y] = f[x] + val[i]; ind[y] = ind[x]; &#125; else if (f2[y] &gt; f[x] + val[i]) &#123; f2[y] = f[x] + val[i]; ind2[y] = ind[x]; &#125; &#125; dfs2(y, x); &#125;&#125;int main() &#123; n = read(); for (re int i = 2; i &lt;= n; i++) &#123; ll u, w; u = read(); w = read(); insert(i, u, w); insert(u, i, w); &#125; m = read(); for (re int i = 1; i &lt;= m; i++) &#123; s[i] = read(); spe[s[i]] = 1; &#125; for (re int i = 1; i &lt;= n; i++) &#123; f[i] = f2[i] = 0x7ffffffffffffff; &#125; dfs(1, 0); dfs2(1, 0); for (re int i = 1; i &lt;= m; i++) &#123; printf(\"%lld \", f2[s[i]]); &#125; puts(\"\"); return 0;&#125; ps: 这题$10^6$蜃臭还是要卡卡常才能过三年OI一场空 不开long long 见祖宗","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"宝藏「NOIP2017」","slug":"宝藏「NOIP2017」","date":"2019-10-12T12:24:10.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/fa917cad.html/","link":"","permalink":"http://akdream.tk/post/fa917cad.html/","excerpt":"","text":"【题目描述】参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了$n$个深埋在地下的宝藏屋，也给出了这$n$个宝藏屋之间可供开发的$m$条道路和它们的长度。 小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。 小明的决心感动了考古挖掘的赞助商， 赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。 在此基础上， 小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。 新开发一条道路的代价是： 这条道路的长度$\\times$从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋）。 请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。 【输入格式】第一行两个用空格分离的正整数$n$和$m$，代表宝藏屋的个数和道路数。 接下来$m$行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为$1\\sim n$），和这条道路的长度$v$。 【输出格式】输出共一行，一个正整数，表示最小的总代价。 【数据范围】$1 \\le n \\le 12，0 \\le m \\le 1000，v \\le 500000$。 第一眼看到$n \\le 12$就知道十有八九是个状压DP_(:з」∠)_然而本蒟蒻推不出来 抄的网上子状态和转移方程过的 不妨用$dp[S][i]$表示当前连接了集合S中的所有点，当前树的高度是$i$。 用$val[S][i]$表示将 点$i$连向 (集合$S$中的所有点所组成的连通块) 所需的最小花费不难看出$val[S][i] = min_{j \\in S}(e[i][j])$e[i][j]代表边$(i, j)$的边权 那转移方程是什么呢假设我们现在正在求$dp[S][i]$枚举$S$的子集$S2$，设$S$中除$S2$的部分为$S3$，我们假设前$i-1$层是由$S2$中的点构成的 则在第$i$层中 我们要把$S3$中的点放在第$i$层 代价是多少呢？ 其实这个我们之前已经预处理过了 代价就是$\\sum_{j \\in S3}val[S2][j] * i$$i$就是深度得到转移方程为$dp[S][i]=dp[S2][i-1]+\\sum_{j \\in S3}val[S2][j] * i$枚举免费挖掘的第一个宝藏$k$边界为$dp[1&lt;&lt;(k-1)][0]=0$ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll ans = 0x7fffffff, n, m, maxn;ll dis[30][30], val[(1&lt;&lt;12)+5][30], dp[(1&lt;&lt;12)+5][30];int main() &#123; scanf(\"%lld %lld\", &amp;n, &amp;m); if (n == 1) &#123; puts(\"0\"); return 0; &#125; memset(dis, 0x7f, sizeof(dis)); for (int i = 1; i &lt;= m; i++) &#123; ll u, v, w; scanf(\"%lld %lld %lld\", &amp;u, &amp;v, &amp;w); dis[u-1][v-1] = dis[v-1][u-1] = min(dis[u-1][v-1], w); &#125; maxn = (1 &lt;&lt; n) - 1; for (ll i = 1; i &lt;= maxn; i++) &#123; for (ll j = 0; j &lt; n; j++) &#123; val[i][j] = 0x7fffffff; if ((1 &lt;&lt; j) &amp; i) continue; for (ll k = 0; k &lt; n; k++) &#123; if ((1 &lt;&lt; k) &amp; i) val[i][j] = min(val[i][j], dis[j][k]); &#125; &#125; &#125; for (ll i = 0; i &lt; n; i++) &#123; memset(dp, 0x7f, sizeof(dp)); dp[(1 &lt;&lt; i)][0] = 0; for (ll s1 = 1; s1 &lt;= maxn; s1++) &#123; for (ll s2 = s1 &amp; (s1-1); s2; s2 = s1 &amp; (s2-1)) &#123; ll s3 = s1 - s2, sum = 0; for (ll j = 0; j &lt; n; j++) &#123; if ((1 &lt;&lt; j) &amp; s3) sum += val[s2][j]; &#125; for (ll j = 1; j &lt;= n; j++) &#123; dp[s1][j] = min(dp[s1][j], dp[s2][j-1] + j * sum); &#125; &#125; &#125; for (ll j = 1; j &lt;= n; j++) &#123; ans = min(ans, dp[maxn][j]); &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125; 一个枚举子集的方法 123for (int s2 = (s-1) &amp; s; s2; s2 = (s2-1)&amp;s) &#123; //s2即为s的子集&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://akdream.tk/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"不等数列","slug":"不等数列","date":"2019-10-06T11:27:54.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/42f54a5b.html/","link":"","permalink":"http://akdream.tk/post/42f54a5b.html/","excerpt":"","text":"【题目描述】将$1$到$n$任意排列，然后在排列的每两个数之间根据他们的大小关系插入“$&gt;$”和“$&lt;$”。问在所有排列中，有多少个排列恰好有$k$个“$&lt;$”。答案对$2012$取模。 【输入格式】第一行$2$个整数$n,k$。 【输出格式】一个整数表示答案。 【数据范围】对于30%的数据：$n \\leq 10$对于100%的数据：$k &lt; n \\leq 1000$ 题解考虑一个比较简单的情况$2, 1, 3$这个序列现在有$1$个$&lt;$和$1$个$&gt;$假设现在要把$4$插入这个序列(1) 如果要将$4$放到原有的两个数之间 因为$4$一定会是当前序列中最大的 所以会新产生一个$&lt;$和一个$&gt;$。如果插入的位置原来是$&gt;$则$&lt;$的总量会+1 反之$&gt;$的总量会+1(2) 如果把$4$放在最左边 就会新产生一个$&gt;$如果放在最右边就会新产生一个$&lt;$ 综上$4$一共有四个位置可以插入 其中有两个位置会使$&lt;$的总数+1 另外两个位置会使$&gt;$的总数+1对于一般情况 如果当前要插入$i$则一共会有正好$i$个位置可供插入 设目前有$j$个$&lt;$则会有$i-j-1$种情况使得$&lt;$增多一个 会有$j+1$种情况使得$&gt;$增多一个然后就可以DP了 设$f[i][j]$表示$1$~$i$的排列中有$j$个$&lt;$的方案数 则转移方程为$f[i][j]=f[i-1][j-1]*(i-j)+f[i-1][j]*(j+1)$边界:$f[2][0]=f[2][1]=1$ 代码 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const ll mod = 2012;ll n, k;ll dp[1005][1005];int main() &#123; scanf(\"%lld %lld\", &amp;n, &amp;k); dp[2][0] = dp[2][1] = 1; for (ll i = 3; i &lt;= n; i++) &#123; for (ll j = 0; j &lt;= min(k, i - 1); j++) &#123; dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (i - j)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * (j + 1)) % mod; &#125; &#125; printf(\"%lld\\n\", dp[n][k]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"小Biu看电影","slug":"小Biu看电影","date":"2019-10-06T10:46:44.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/4bd53a3c.html/","link":"","permalink":"http://akdream.tk/post/4bd53a3c.html/","excerpt":"","text":"【题目描述】无聊的小Biu来到了电影之城，他发现这里有$n$个电影院，而且每个电影院的电影票价是不同的，有一些电影院之间有双向联通的道路，想要通过某条道路需要一定的花费，小Biu想知道，他以每一个电影院为起点(当然也可以原地不动)，最少需要多少花费可以看到电影。 【输入格式】第 1 行：两个整数$n,m$，$n$表示城市中电影院的个数，$m$表示电影院之间的道路总数。($1\\leq n\\leq 100000,1\\leq m\\leq 300000$)第 2 行：$n$个正整数，第$i$个正整数表示在第$i$个电影院看电影的票价$val[i]$。($1\\leq val[i]\\leq 1000$)第 3~m+2 行：每行三个正整数,$u,v,w$,表示电影院$u$与电影院$v$之间有一条花费为$w$的道路。($1\\leq u,v\\leq n,1\\leq w\\leq 1000$) 【输出格式】输出$n$行每行一个正整数。第$i$行输出的正整数表示从第$i$个电影院出发，最少需要多少花费可以看到电影。 看上去好像蜃难其实似乎也挺简单 把 从一个电影院出发走到任意一个电影院看电影 倒过来 理解成 在任意一个电影院看完电影然后回到指定电影院然后就可以想到建立一个虚点 将虚点与每个电影院之间连一条权为$val[i]$(即票价)的边 然后从$i$影院出发看到电影的最小代价实际上就是虚点到$i$的最短路然后跑一遍Dijkstra就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125;ll n, m, val[1000005], ans;ll head[1000005], pre[1000005], to[1000005], dis[1000005], sz;ll dist[1000005];bool vis[100005];void insert(ll u, ll v, ll w) &#123; to[++sz] = v; dis[sz] = w; pre[sz] = head[u]; head[u] = sz;&#125;void dijkstra(ll st) &#123; priority_queue&lt; pair&lt;ll, ll&gt; , vector&lt; pair&lt;ll, ll&gt; &gt; , greater&lt; pair&lt;ll, ll&gt; &gt; &gt; q; q.push(make_pair(0, st)); while (!q.empty()) &#123; ll x = q.top().second; q.pop(); if (vis[x]) continue; else vis[x] = 1; for (int i = head[x]; i; i = pre[i]) &#123; ll y = to[i]; if (dist[y] &gt; dist[x] + dis[i]) &#123; dist[y] = dist[x] + dis[i]; q.push(make_pair(dist[y], y)); &#125; &#125; &#125;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) &#123; val[i] = read(); insert(0, i, val[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; ll u, v, w; u = read(); v = read(); w = read(); insert(u, v, w * 2); insert(v, u, w * 2); &#125; ans = 0x7fffffff; for (int j = 1; j &lt;= n; j++) &#123; dist[j] = 0x7fffffff; vis[j] = 0; &#125; dist[0] = 0; dijkstra(0); for (int i = 1; i &lt;= n; i++) printf(\"%lld\\n\", dist[i]); return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"修改数组","slug":"修改数组","date":"2019-10-06T10:27:32.000Z","updated":"2020-10-08T12:16:08.239Z","comments":true,"path":"post/996feecc.html/","link":"","permalink":"http://akdream.tk/post/996feecc.html/","excerpt":"","text":"【题目描述】给出一个整数数组$A$，你可以将任何一个数修改为任意一个正整数，最终使得整个数组是严格递增的且均为正整数。问最少需要修改几个数？ 【输入格式】第$1$行：一个数$N$表示序列的长度($1\\leq N\\leq 100000$)。第$2$~$N+1$行：每行$1$个数，对应数组元素。($0\\leq A[i]\\leq 10^9$)。 【输出格式】输出最少需要修改几个数使得整个数组是严格递增的。 题解如果把题目改成 “最终使得整个数组是不下降的” 似乎就会好做很多把严格递增的数组改为不降的数组也很简单 把每个$A[i]$变成$A[i]-i$就行了 这样处理后 原题就变成将处理后的数组修改成不下降数组最少修改几个数求一下它的最长不下降子序列 然后把其他数改掉就行了LIS不会求？点这里 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll n;ll a[100005], b[100005], sz;ll num[100005], len;ll maxn;ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125;ll search(ll x) &#123; ll l = 1, r = sz, mid, ret = 0; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (b[mid] &gt; x) &#123; ret = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return ret;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) &#123; a[i] = read() - i; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] &gt;= 0) num[++len] = a[i]; &#125; for (int i = 1; i &lt;= len; i++) &#123; if (num[i] &gt;= b[sz]) b[++sz] = num[i]; else b[upper_bound(b + 1, b + sz + 1, num[i]) - b] = num[i]; maxn = max(sz, maxn); &#125; printf(\"%lld\\n\", n - maxn); return 0;&#125;","categories":[],"tags":[]},{"title":"特殊的排列","slug":"特殊的排列","date":"2019-10-05T13:47:19.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/cf98960f.html/","link":"","permalink":"http://akdream.tk/post/cf98960f.html/","excerpt":"","text":"【题目描述】一个数组的元素为 1 至 N 的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？2 5 3 4 1 将 1 移到头部 =&gt;1 2 5 3 4 将 5 移到尾部 =&gt;1 2 3 4 5 这样就排好了，移动了 2 个元素。给出一个 1-N 的排列，输出完成排序所需的最少移动次数。 【输入格式】第 1 行：1 个数$N(2\\leq N\\leq 50000)$。第 2 ~ N+1 行：每行 1 个数，对应排列中的元素。 【输出格式】输出 1 个数，对应所需的最少移动次数。 考试的时候 把结论猜对了 不然我估计我也推不出这个结论来QWQ 结论是这样的假设你以最少的移动次数排好了序 那么你一定会将1p的这些数按照p, p-1, p-2, …, 2, 1的顺序依次挪到最前面 将qn的数按q, q+1, q+2, …, n - 1, n的顺序挪到最后面这样移动的所需次数一定是最少的那么还有一部分数 p+1q-1 是不需要移动的 为了让移动次数最少 我们肯定想要这段 p+1q-1 最长这段数字还必须是连续的正整数 所以问题就变成了求序列中最长的 由连续正整数构成的 子序列这个其实也很容易求 设$ind[i]$表示 数字$i$在序列中的位置 以上文样例为例$ind$数组应该是这样的：${5, 1, 3, 4, 2}$然后其实就是求这个数组的最长连续上升子序列 遍历一遍就行了 时间复杂度$O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125;ll n, a[100005], b[100005];ll maxn, maxst;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); b[a[i]] = i; &#125; ll st = 1; for (int i = 2; i &lt;= n; i++) &#123; if (b[i] &lt; b[i-1]) &#123; if (i - st &gt; maxn) &#123; maxn = i - st; &#125; st = i; &#125; &#125; if (n - st + 1 &gt; maxn) maxn = n - st + 1; printf(\"%lld\\n\", n - maxn); return 0; &#125;","categories":[],"tags":[]},{"title":"贫富差距","slug":"贫富差距","date":"2019-10-05T13:00:09.000Z","updated":"2020-10-08T12:16:08.726Z","comments":true,"path":"post/ccd98c1.html/","link":"","permalink":"http://akdream.tk/post/ccd98c1.html/","excerpt":"","text":"【题目描述】一个国家有$N$个公民，标记为$0,1,2，…，N-1$，每个公民有一个存款额。已知每个公民有一些朋友，同时国家有一条规定朋友间的存款额之差不能大于$d$。也就是说，$a$和$b$是朋友的话，$a$有$x$元的存款，$b$有$y$元，那么$|x-y|\\leq d$。给定$d$值与$N$个人的朋友关系，求这个国家最富有的人和最贫穷的人的存款相差最大的可能值是多少？即求贫富差距的最大值的下界。若这个值为无穷大，输出$-1$. 【输入格式】多组测试数据，第一行一个整数$T$，表示测试数据数量，$1\\leq T\\leq 5$每组测试数据有相同的结构构成。每组数据的第一行两个整数$N$，$d$，表示人数与朋友间存款差的最大值，其中$2\\leq N\\leq 50,0\\leq d\\leq 1000$. 接下来有一个$N\\times N$的数组$A$，若$A[i][j]=’Y’$表示$i$与$j$两个人是朋友，否则$A[i][j]=’N’$表示不是朋友。其中$A[i][i]=’N’$，且保证$A[i][j]=A[j][i]$. 【输出格式】每组数据一行输出，即这个国家的贫富差距最大值的下界，如果这个值为无穷大输出$-1$. 题解看一下这个例子 （我根本不会画图）给每对朋友之间连一条边权为$d$的无向边这个例子中 4个人两两都是朋友 其实仔细观察可以发现$i$和$j$之间的最大贫富差距就是他们之间的最短路 (这让我想到了差分约束)再试几次 好像这个结论是对的所以就最短路乱搞就行了 floyd dijkstra SPFA都行证明可能有点类似差分约束（口胡） 然后 什么情况下最大贫富差距是无穷大呢这个还是很容易看出来 当图中存在不止一个连通块的时候 贫富差距可以是无穷大dfs一遍就完了 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstring&gt; #include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125;ll t, n, d, ans;ll a[100][100];char ch[100][100];bool vis[1005];ll dis[1005];void dfs(ll x) &#123; vis[x] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (a[x][i] &amp;&amp; !vis[i]) dfs(i); &#125;&#125;void SPFA(ll st) &#123; queue&lt;ll&gt; q; q.push(st); while (!q.empty()) &#123; ll x = q.front(); q.pop(); for (int i = 1; i &lt;= n; i++) &#123; if (a[x][i]) &#123; if (dis[x] + d &lt; dis[i]) &#123; dis[i] = dis[x] + d; if (!vis[i]) &#123; q.push(i); vis[i] = 1; &#125; &#125; &#125; &#125; vis[x] = 0; &#125;&#125;int main() &#123; t = read(); while (t--) &#123; n = read(); d = read(); ans = -1; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", ch[i] + 1); &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; if (ch[i][j] == 'Y') a[i][j] = 1; else a[i][j] = 0; &#125; memset(vis, 0, sizeof(vis)); dfs(1); bool flag = 1; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; puts(\"-1\"); flag = 0; break; &#125; &#125; if (!flag) continue; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) dis[j] = 0x7fffffff; memset(vis, 0, sizeof(vis)); dis[i] = 0; vis[i] = 1; SPFA(i); for (int j = 1; j &lt;= n; j++) &#123; ans = max(ans, dis[j]); &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"整数划分","slug":"整数划分","date":"2019-10-05T11:45:55.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/75e76536.html/","link":"","permalink":"http://akdream.tk/post/75e76536.html/","excerpt":"","text":"【题目描述】给定整数$N$，求分解成$2$的幂的方案数。结果$Mod \\ 1000000007$,比如$N = 7$时，共有$6$种划分方法。$7=1+1+1+1+1+1+1 \\ \\ =1+1+1+1+1+2 \\ \\ =1+1+1+2+2 \\ \\ =1+2+2+2 \\ \\ =1+1+1+4 \\ \\ =1+2+4 \\$ 【输入格式】输入一个数$N$。$(1 \\le N \\le 10^6)$ 【输出格式】输出划分方法的数量$Mod \\ 000000007$ 第一眼看好像是结论题 于是推了好久的结论。。。没推出来 然后就去写DP结果到最后也只写了个错误的背包 做法1 完全背包物品就是$2^0 2^1 2^2 \\cdots$然后跑个板子就行了。。。借下学长代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define maxn 1000000 #define mod 1000000007 using namespace std;typedef long long ll;int n;int sz;int bin[maxn+5];ll dp[maxn+5];int main()&#123; scanf(\"%d\",&amp;n); bin[0]=1; while(bin[sz]*2&lt;=n)&#123; sz++; bin[sz]=bin[sz-1]*2; &#125; dp[0]=1; for(int i=0;i&lt;=sz;i++)&#123; for(int j=bin[i];j&lt;=n;j++)&#123; dp[j]+=dp[j-bin[i]]; dp[j]%=mod; &#125; &#125; printf(\"%lld\\n\",dp[n]);&#125; 时间复杂度$O(n log n)$ 做法2 递推可以分别考虑将当前数字拆分出几个1设$f[i]$代表$i$有多少种拆分方案以$f[9]$为例 如果把9拆分成1个1 和 其他一些数字 则方案数就等于(将8用2, 4, 8拆分的方案数) 其实也就是 (将4用1, 2, 4拆分的方案数) 即$f[4]$同理 把9拆分成3个1和其他数字时 方案数会是$f[3]$所以可以得出结论$f[n] = \\sum_{i=1}^{n/2} f[i]$这个东西用前缀和维护一下就行这么简单的结论我没想到 我太蒻了 代码 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const ll mod = 1000000007;ll n, ans;ll a[1000005], sum[1000005];ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125;int main() &#123; n = read(); a[1] = 1; sum[1] = 2; a[0] = 1; sum[0] = 1; for (int i = 2; i &lt;= n; i++) &#123; a[i] = sum[i/2]; sum[i] = (sum[i-1] + a[i]) % mod; &#125; printf(\"%lld\\n\", a[n]); return 0;&#125; 时间复杂度$O(n)$","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Tinux系统[HNOI2002]","slug":"Tinux系统[HNOI2002]","date":"2019-09-25T13:43:25.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/eecd944f.html/","link":"","permalink":"http://akdream.tk/post/eecd944f.html/","excerpt":"","text":"【题目描述】原题又臭又长 不写了 请自行去看题面大意：一棵有根树 每一个节点最多只能有$k$个子节点 要放$n$个文件进去 文件只能放在叶子节点里 从任意一个非叶子节点（文件夹）访问到他的第$i$个子节点需要耗费时间$p_i$访问一个文件的时间定义为从根节点访问到该文件所处的叶子节点所需时间 求一种文件放置方法 使得依次访问每个文件花费的时间总和最小 【输入格式】文件的第一行为两个正整数$N,K$($1 \\le N \\le 1000, 2 \\le K \\le 150$)接下来的$K$行每行有一个正整数$P_i, P_i \\le150$。 【输出格式】在最优存储方案下的时间总和 这题在某谷上是黑题黑题我怎么会做呢 网上搜了一下题解的思路然后胡搞搞过了就来写Blog 首先 由于对于一个非叶子节点我们可以随便选择优先用哪个子节点 所以肯定从时间花费少的用起 所以可以先给$p$数组排序 然后此题我们可以用记忆化搜索求解实际上就是DP 设$f[i][j]$表示 还剩$i$个文件需要安排 使用第$j$个子节点到第$k$(如果忘了$k$是什么 回去读题)个子节点(排序后的) 最优安排方案下访问这$i$个点所需的最短时间 转移 对于$dp[i][j]$如果$i=1$就直接把这个文件扔当前这个第$j$个子节点就行了如果$j=1$且$i&gt;1$那就必须在第$j$个子节点这个位置新开一个文件夹了 耗费时间就是$dp[i][1]$(新文件夹从子节点1开始)$+p[i]*i*i$$p[i]*i*i$就是把这$i$个文件经过这里所需的时间给提前算进去了对于其它情况 枚举$x$表示要放在当前的第$j$个子节点的位置或者$j$位置下面的文件夹的文件个数$dp[i][j] = min(dp[x][1]+dp[i-x][j+1]+p[i]*x*x)$; DP时可以使用一种dfs的方法 【代码】 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll n, k, p[1005];ll dp[1005][205];int dfs(ll need, ll cur) &#123; if (need == 1) &#123; return dp[need][cur] = p[cur]; &#125; else if (cur == k) &#123; return dp[need][cur] = p[cur] * need * need + dfs(need, 1); &#125; if (dp[need][cur]) return dp[need][cur]; dp[need][cur] = p[cur] + dfs(need - 1, cur + 1); for (int i = 2; i &lt; need; i++) &#123; dp[need][cur] = min(dp[need][cur], dfs(need - i, cur + 1) + dfs(i, 1) + p[cur] * i * i); &#125; return dp[need][cur];&#125;int main() &#123; scanf(\"%lld %lld\", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123; scanf(\"%lld\", &amp;p[i]); &#125; sort(p + 1, p + k + 1); printf(\"%lld\\n\", dfs(n, 1)); return 0;&#125; 众所周知 黑题的代码量很小","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"集合选数[HNOI2012]","slug":"集合选数[HNOI2012]","date":"2019-08-31T12:23:33.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/daceb9cd.html/","link":"","permalink":"http://akdream.tk/post/daceb9cd.html/","excerpt":"","text":"【问题描述】《集合论与图论》这门课程有一道作业题，要求同学们求出{$1, 2, 3, 4, 5$}的所有满足以 下条件的子集：若$x$在该子集中，则$2x$和$3x$不能在该子集中。同学们不喜欢这种具有枚举性质的题目，于是把它变成了以下问题：对于任意一个正整数$n\\le100000$，如何求出{$1, 2,…, n$} 的满足上述约束条件的子集的个数（只需输出对$1,000,000,001$取模的结果），现在这个问题就交给你了。 【输入格式】 只有一行，其中有一个正整数$n$，$30%$的数据满足$n\\le20$,$100%$的数据满足$n \\le 100000$。 【输出格式】 仅包含一个正整数，表示{$1, 2,…, n$}有多少个满足上述约束条件的子集。 第一眼看上去是个组合计数问题。。。然而组合做不了，所以我们考虑DP。考虑将题目所给的限制条件转化成一个矩阵以从$1$开始为例：这是矩阵 -&gt;$\\begin{bmatrix} 1 &amp; 3 &amp; 9 &amp; 27 &amp; …\\ 2 &amp; 6 &amp; 18 &amp; 54 &amp; … \\ 4 &amp; 12 &amp; 36 &amp; 108 &amp; … \\ 8 &amp; 24 &amp; 72 &amp; 216 &amp; … \\ … &amp; … &amp; … &amp; … &amp; … \\end{bmatrix}\\quad$于是乎 原问题就变成了求在这个矩阵里选一些两两不相邻的数的方案数由于这些数是指数级增长的，所以在$100000$范围内，粗略估计矩阵的长宽最多也不会超过$20$，而$3$倍增长的列的数目更是不会超过$11$。所以可以想到用状压DP 怎么DP就不说了 注意可以把很多没必要枚举的状态跳过，第一次写的时候被卡TLE了。。。从$1$开始的矩阵不一定包含所有数，对于一个数，如果前面的矩阵都没有包含它，如$5, 7, 11$，需要在从这个数开始的矩阵再DP一次，答案就是每次DP出来的部分答案的积。时间复杂度$O($一秒内$)$ 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const ll mod = 1000000001;ll n, dp[21][100005], ans = 1;ll len, len2[1005];bool vis[100005];inline void add(ll &amp;x, ll y) &#123; x += y; if (x &gt;= mod) x -= mod;&#125;ll solve(ll x) &#123; ll nowans = 0; for (int i = 1; ; i++) &#123; ll cur = (x &lt;&lt; (i-1)); if (cur &gt; n) &#123; len = i - 1; break; &#125; vis[cur] = 1; for (int j = 1; ; j++) &#123; cur *= 3; if (cur &gt; n) &#123; len2[i] = j; break; &#125; vis[cur] = 1; &#125; &#125; for (int i = 0; i &lt;= len; i++) for (int j = 0; j &lt; (1 &lt;&lt; len2[i]); j++) dp[i][j] = 0; dp[0][0] = 1; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; (1 &lt;&lt; len2[i]); j++) &#123; if (dp[i][j]) &#123; if (j &amp; (j &lt;&lt; 1)) continue; for (int k = 0; k &lt; (1 &lt;&lt; len2[i+1]); k++) &#123; if (k &amp; (k &lt;&lt; 1)) continue; if ((j &amp; k) == 0) &#123; dp[i+1][k] = (dp[i+1][k] + dp[i][j]) % mod; &#125; &#125; &#125; &#125; &#125; for (int j = 0; j &lt; (1 &lt;&lt; len2[len]); j++) &#123; nowans = (nowans + dp[len][j]) % mod; &#125; return nowans;&#125;int main() &#123; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; vis[i] = 1; ans = ans * solve(i) % mod; &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125; ~~DP题目太难了 我太蒻了~~","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://akdream.tk/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"糖果「SCOI2011」","slug":"糖果「SCOI2011」","date":"2019-08-28T13:11:20.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/6a7ab410.html/","link":"","permalink":"http://akdream.tk/post/6a7ab410.html/","excerpt":"","text":"【题目描述】幼儿园里有$N$个小朋友，$lxhgww$老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$lxhgww$需要满足小朋友们的$K$个要求。幼儿园的糖果总是有限的，$lxhgww$想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 神仙幼儿园 【输入格式】输入的第一行是两个整数$N, K$。接下来K行，表示这些点需要满足的关系，每行3个数字，$X, A, B$。如果$X=1$， 表示第$A$个小朋友分到的糖果必须和第$B$个小朋友分到的糖果一样多；如果$X=2$， 表示第$A$个小朋友分到的糖果必须少于第$B$个小朋友分到的糖果；如果$X=3$， 表示第$A$个小朋友分到的糖果必须不少于第$B$个小朋友分到的糖果；如果$X=4$， 表示第$A$个小朋友分到的糖果必须多于第$B$个小朋友分到的糖果；如果$X=5$， 表示第$A$个小朋友分到的糖果必须不多于第$B$个小朋友分到的糖果； 【输出格式】输出一行，表示$lxhgww$老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出$-1$。 $N\\leq 100000$$K\\leq 100000$$1\\leq X\\leq 5$$1\\leq A, B\\leq N$ 差分约束模版题 关于差分约束差分约束系统是用于解决这样一类问题的：给你$n$个形如$x-y\\le z$的不等式，求是否有解及符合条件的一组解对于此类问题处理方式就是对于每个$x-y\\le z$, 连一条从y到x，边权为z的有向边。如果是形如$x-y\\ge z$的不等式，也可以将它转换成$y-x \\le -z$来连边。如果给出了一组$x=y$的等式，可以转化为$0 \\le x-y \\le 0$即连一条$x, y$之间的边权为$0$的无向边。最后从$0$号点向每个点连一条边权为$0$的有向边，或者如果每个数至少要是$1$就连边权为$1$的边。然后从$0$号点开始跑SPFA，如果有负环则无解，否则$dis[1]$到$dis[n]$就是对应的一组解。 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define re registerusing namespace std;typedef long long ll;ll n, m, sum;ll head[1000005], to[1000005], pre[1000005], val[1000005], len;ll dis[1000005], cnt[1000005];bool vis[1000005];ll read() &#123; ll ret = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; ret = ret * 10 + ch - '0'; ch = getchar(); &#125; return ret;&#125;void insert(ll u, ll v, ll w) &#123; len++; to[len] = v, pre[len] = head[u], val[len] = w, head[u] = len;&#125;queue&lt;ll&gt; q;bool SPFA() &#123; q.push(0); vis[0] = 1; while (!q.empty()) &#123; ll c = q.front(); q.pop(); vis[c] = 0; if (cnt[c] == n - 1) return false; cnt[c]++; for (re ll i = head[c]; i != 0; i = pre[i]) &#123; if (dis[c] + val[i] &gt; dis[to[i]]) &#123; dis[to[i]] = dis[c] + val[i]; // cnt[to[i]] = cnt[c] + 1; // if (cnt[to[i]] &gt; n) &#123; // return false; // &#125; if (!vis[to[i]]) &#123; vis[to[i]] = 1; q.push(to[i]); &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; n = read(), m = read(); for (re ll i = 1; i &lt;= m; i++) &#123; ll ch, a, b; ch = read(); a = read(), b = read(); switch (ch) &#123; case 1: insert(b, a, 0), insert(a, b, 0); break; case 2: &#123; insert(a, b, 1); if (a == b) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; break; &#125; case 3: insert(b, a, 0); break; case 4: &#123; if (a == b) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; insert(b, a, 1); break; &#125; case 5: insert(a, b, 0); break; &#125; &#125; for (re ll i = n; i &gt;= 1; i--) &#123; insert(0, i, 1); &#125; q.push(0); vis[0] = 1; while (!q.empty()) &#123; ll c = q.front(); q.pop(); vis[c] = 0; for (re ll i = head[c]; i != 0; i = pre[i]) &#123; if (dis[c] + val[i] &gt; dis[to[i]]) &#123; dis[to[i]] = dis[c] + val[i]; if (!vis[to[i]] &amp;&amp; cnt[to[i]] &lt; n) &#123; vis[to[i]] = 1; cnt[to[i]]++; q.push(to[i]); &#125; else if (cnt[to[i]] &gt;= n) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) sum += dis[i]; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"差分约束","slug":"差分约束","permalink":"http://akdream.tk/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"配对[SCOI2008]","slug":"配对[SCOI2008]","date":"2019-08-28T02:26:26.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/ba2e2f17.html/","link":"","permalink":"http://akdream.tk/post/ba2e2f17.html/","excerpt":"","text":"【题目描述】你有$n$个整数$A_i$和$n$个整数$B_i$。你需要把它们配对，即每个$A_i$恰好对应一 个$B_i$。要求所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。例如$A={5,6,8}，B={5,7,8}$，则最优配对方案是$5$配$8$,$6$配$5$,$8$配$7$，配对整数的差的绝对值分别为$2, 2, 1$，和为$5$。注意，$5$配$5$，$6$配$7$，$8$配$8$是不允许的，因 为相同的数不许配对。 【输入格式】第一行为一个正整数$n$，接下来是$n$行，每行两个整数$A_i$和$B_i$，保证所有$A_i$各不相同，$B_i$也各不相同。 【输出格式】输出一个整数，即配对整数的差的绝对值之和的最小值。如果无法配对，输出$-1$。 【数据范围】$1 \\le n \\le 10^5$，$A_i$和$B_i$均为$1$到$10^6$之间的整数。 关于此题没想到吧！又是DP 首先 先对$A,B$数组进行排序。如果没有限制条件的话,明显最优解就是排序后的每个A[i]和每个B[i]配对。加上限制条件之后对于某个位置$i$$1.$如果$A[i-1] = B[i-1]$那么我们可以让$A[i-1]$和$B[i]$配对，让$A[i]$和$B[i-1]$配对。$2.$如果$A[i-1] = B[i-1]$且$A[i-2] = B[i-2]$那就可以让$A[i-2], B[i-1]$，$A[i-1], B[i]$,$A[i], B[i-2]$分别配对或是让$A[i-2], B[i]$，$A[i-1], B[i-2]$,$A[i], B[i-1]$分别配对$3.$如果有更多连续相等的，都可以把它们转化成上面的两种情况进行处理，不需要再分开考虑 得到转移方程为$dp[i] = min(dp[i-1] + calc(A[i], B[i]), dp[i-2] + calc(A[i-1], B[i]) + calc(A[i], B[i-1]), dp[i-3] + calc(A[i-2], B[i-1]) + calc(A[i-1], b[i]) + calc(A[i], b[i-2]), dp[i-3] + calc(A[i-2], B[i]) + calc(A[i-1], b[i-2]) + calc(A[i], b[i-1]))$;$calc(x, y)$在$x = y$时返回无穷大。 【代码】 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll inf = 0x3f3f3f3f3f3f3f3f;ll n, a[100005], b[100005], dp[100005];inline ll _abs(ll x) &#123; return x &lt; 0 ? -x : x;&#125;inline ll calc(ll a, ll b) &#123; if (a == b) return inf; else return _abs(a - b);&#125;int main() &#123; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld %lld\", &amp;a[i], &amp;b[i]); &#125; sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); dp[1] = calc(a[1], b[1]); dp[2] = min(dp[1] + calc(a[2], b[2]), calc(a[1], b[2]) + calc(a[2], b[1])); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = inf; dp[i] = min(dp[i], dp[i-1] + calc(a[i], b[i])); dp[i] = min(dp[i], dp[i-2] + calc(a[i-1], b[i]) + calc(a[i], b[i-1])); dp[i] = min(dp[i], dp[i-3] + min(calc(a[i-2], b[i-1]) + calc(a[i-1], b[i]) + calc(a[i], b[i-2]), calc(a[i-2], b[i]) + calc(a[i-1], b[i-2]) + calc(a[i], b[i-1]))); &#125; if (dp[n] &gt;= inf) puts(\"-1\"); else printf(\"%lld\\n\", dp[n]); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"火山喷发","slug":"火山喷发","date":"2019-08-27T03:41:13.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/40a07a47.html/","link":"","permalink":"http://akdream.tk/post/40a07a47.html/","excerpt":"","text":"【题目描述】火山喷发对所有附近的生物具有毁灭性的影响。在本题中，我们希望用数值来模拟这一过程。在环境里有$n$个生物分别具有$A_1,A_2,\\cdots,A_n$点生命值，一次火山喷发总计$M$轮，每轮造成$1$点伤害，等概率地分给所有存活的生物，即如果目前有$K$个活着的生物，每个生物受到这点伤害的概率是$\\frac{1}{K}$。如果一个生物的生命值减为$0$，它会立即死去，此后都不会再占用受到伤害的概率。如果没有生物存活，那么将没有生物会受到伤害。现在你的任务是，给定$n,M$和全部生物的生命值，问每个生物火山喷发后依然存活的概率。 【输入格式】第一行两个正整数$n$和$M$。第二行$n$个正整数$A_1,\\cdots,A_n$。 【输出格式】$n$行，第$i$行一个数表示第$i$个生物存活下来的概率，保留小数点后六位。 【数据范围】对于全部数据$n \\le 4$,$M \\le 120$,$A_i\\le50$。 挺水的突破口在于$n \\le 4$，可以直接建数组$f[i][j][k][l]$表示生物1有$i$生命，生物2有$j$生命，$3$-&gt;$k$,$4$-&gt;$l$的概率然后就可以枚举轮数，枚举$i, j, k$来进行DP了，注意$l$不需要枚举，因为每个轮数及$i, j, k$正好对应一个$l$。转移方程很简单吧。。。文字不太好表示，看代码吧时间复杂度$O(120*50^{3})$; 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n, m, sum, a[10];double dp[51][51][51][51], ans[10];int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); sum += a[i]; &#125; m = min(m, sum); dp[a[1]][a[2]][a[3]][a[4]] = 1; for (int tme = 0; tme &lt;= m; tme++) &#123; for (int i = 0; i &lt;= a[1]; i++) &#123; for (int j = 0; j &lt;= a[2]; j++) &#123; for (int k = 0; k &lt;= a[3]; k++) &#123; int l = sum - tme - i - j - k; if (sum - i - j - k - l != tme) continue; if (l &gt; a[4] || l &lt; 0) continue; if (i == 0 &amp;&amp; j == 0 &amp;&amp; k == 0 &amp;&amp; l == 0) continue; int num = 0; if (i) num++; if (j) num++; if (k) num++; if (l) num++; if (i) dp[i-1][j][k][l] += dp[i][j][k][l] / num; if (j) dp[i][j-1][k][l] += dp[i][j][k][l] / num; if (k) dp[i][j][k-1][l] += dp[i][j][k][l] / num; if (l) dp[i][j][k][l-1] += dp[i][j][k][l] / num; &#125; &#125; &#125; &#125;//统计答案写得恶臭无比 不要在意 for (int i = 0; i &lt;= a[2]; i++) &#123; for (int j = 0; j &lt;= a[3]; j++) &#123; for (int k = 0; k &lt;= a[4]; k++) &#123; if (sum - i - j - k == m) &#123; ans[1] += dp[0][i][j][k]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= a[1]; i++) &#123; for (int j = 0; j &lt;= a[3]; j++) &#123; for (int k = 0; k &lt;= a[4]; k++) &#123; if (sum - i - j - k == m) ans[2] += dp[i][0][j][k]; &#125; &#125; &#125; for (int i = 0; i &lt;= a[1]; i++) &#123; for (int j = 0; j &lt;= a[2]; j++) &#123; for (int k = 0; k &lt;= a[4]; k++) &#123; if (sum - i - j - k == m) ans[3] += dp[i][j][0][k]; &#125; &#125; &#125; for (int i = 0; i &lt;= a[1]; i++) &#123; for (int j = 0; j &lt;= a[2]; j++) &#123; for (int k = 0; k &lt;= a[3]; k++) &#123; if (sum - i - j - k == m) ans[4] += dp[i][j][k][0]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf(\"%.6lf\\n\", 1 - ans[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"概率DP","slug":"概率DP","permalink":"http://akdream.tk/tags/%E6%A6%82%E7%8E%87DP/"}]},{"title":"数三角形","slug":"数三角形","date":"2019-08-26T02:22:00.000Z","updated":"2020-10-08T12:16:08.460Z","comments":true,"path":"post/6c4ff7a0.html/","link":"","permalink":"http://akdream.tk/post/6c4ff7a0.html/","excerpt":"","text":"【题目描述】刚刚上高中的洁洁在学习组合数学的过程中遇到一道麻烦的题目，她希望你能帮助她解决。给定一张无向完全图$G$，其中大部分边被染成蓝色，但也有一些边被染成红色或者绿色。现在，洁洁需要给这张图的多样性进行打分。一张图的多样性取决于它的同色和异色三角形的个数。具体来说，$G$中每有一个三边颜色都互不同的三角形（异色三角形）可以得$3$分，每有一个三边颜色都相同的三角形（同色三角形）则要被扣掉$6$分，其它三角形不得分也不扣分。现在，请你写一个程序来计算$G$的多样性分数。 【输入格式】第一行两个正整数$n$和$m$，其中$n$表示$G$中顶点的个数，$m$表示$G$中红色或者绿色的边的条数。接下来$m$行每行包括三个整数$a,b,c$，代表连接顶点$a$和顶点$b$的边颜色为红色$(c=1)$或者绿色$(c=2)$。 【输出格式】一行，$G$的多样性得分。 【数据范围】$n \\le 100000, m \\le min(\\frac{n(n-1)}{2},200000)$。 也就是说 请你$O(n)$解决此题 下面来看看正解的思路： 设$a$表示两条邻边颜色不相同的角的个数，$b$表示两条邻边颜色相同的角的个数。三角形有三种，第一种是三边各不相同的，设数目为$x$，第二种是三边全部相同的，设它为$y$，剩下的都是两边相同，一边不同的，设它为$z$。每个$x$型三角形有$3$个$a$型角，$0$个$b$型角; 每个$y$型三角形有$0$个$a$型角，$3$个$b$型角; 每个$z$型三角形有$2$个$a$型角，$1$个$b$型角。所以$a=3x+2z, b=3y+z$而我们要求的正好是$a-2b$,即$a-2b=3x+2z-2*(3y-z)=3x-6y$ $a, b$都是很好求的，组合数算一算【代码实现】 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll n, m, ans;ll a, b;ll num[100005][3];int main() &#123; scanf(\"%lld %lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; ll x, y, z; scanf(\"%lld %lld %lld\", &amp;x, &amp;y, &amp;z); num[x][z]++; num[y][z]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; num[i][0] = n - 1 - num[i][1] - num[i][2]; a = a + num[i][0] * num[i][1] + num[i][1] * num[i][2] + num[i][2] * num[i][0]; b = b + (num[i][0] * (num[i][0] - 1) / 2) + (num[i][1] * (num[i][1] - 1) / 2) + (num[i][2] * (num[i][2] - 1) / 2); &#125; printf(\"%lld\\n\", a - 2 * b); return 0;&#125;","categories":[],"tags":[]},{"title":"字符串-最小表示法","slug":"字符串-最小表示法","date":"2019-08-18T03:55:42.000Z","updated":"2020-10-08T12:16:08.365Z","comments":true,"path":"post/244081e1.html/","link":"","permalink":"http://akdream.tk/post/244081e1.html/","excerpt":"","text":"【题目描述】给你两个长度为$n$的字符串，问能否通过将某一字符串的一个前缀接到该串的后面使得两个字符串相等。若可以，你还可能被要求输出通过上述操作所能得到的字典序最小的字符串。【输入格式】第一行两个整数$n,T$。接下来两行，每行一个长度为$n$的字符串。 【输出格式】若可以，输出$TAK$，否则输出$NIE$。如果$T=1$，你还需要在下一行输出字典序最小的字符串。 【数据范围】$n \\le 1000000$ 先想想暴力做法 将一个前缀接到该串的后面就等同于是原串的一个循环移位，所以枚举所有循环移位即可。时间复杂度$O(n^2)$ 在这里介绍一种$O(n)$求出一个字符串最小的循环移位的方法先将原串复制一遍加在原串后面 即 将$ABCD$变为$ABCDABCD$ 这样在这个新字符串中任意取一段长为$n$的子串一定是原串的一种循环移位。维护两个指针$i, j$和当前子串长度$len$，表示现在正在比较从$i$开始的长度为$len+1$的子串和从$j$开始的长为$len+1$的子串。若某一时刻，$s[i+len] \\neq s[j+len]$ 若$s[i+len] &lt; s[j+len]$，则说明从$i$开始的子串比从$j$开始的子串小，所以最小子串一定不会从$j$开始。此时可以直接让$j = j + len + 1$，然后继续匹配。 反之让$i = i + len + 1$。为什么这样可以保证正确性呢？反证：如果此时$s[i+len] &lt; s[j+len]$，即$j$被“淘汰”了，假设最小子串其实是从$s[j+k] (1 \\le k \\le len)$开始的，那么一定存在从$s[i+k]$开始的子串会比它小。举例：”$ABAABBC$”: 此时$i$在$s[1]$，$j$在$s[4]$，$len=2$时发现$s[1+2] &lt; s[4+2]$，所以$j$可以直接跳到7。因为从$S[5], S[6]$开始的子串一定不会成为最小的。对于从$s[5]$开始的”$BBC$…”有从$s[2]$开始的”$BA$…”比它小，从$s[6]$开始的$s[3]$一定比它小。 【代码实现】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;inline int read() &#123; int ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 1) + (ret &lt;&lt; 3) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125; int n, t;int i, j;int min1, min2;char s1[2000005], s2[2000005];bool yes = 1;int main() &#123; n = read(); t = read(); scanf(\"%s\", s1+1); scanf(\"%s\", s2+1); for (ri a = 1; a &lt;= n; a++) &#123; s1[a + n] = s1[a]; s2[a + n] = s2[a]; &#125; i = 1; j = 2; while (i &lt;= n &amp;&amp; j &lt;= n) &#123; if (i == j) j++; for (int len = 0; ; len++) &#123; if (s1[i+len] &lt; s1[j+len]) &#123; j = j + len + 1; break; &#125; if (s1[j+len] &lt; s1[i+len]) &#123; i = i + len + 1; break; &#125; &#125; &#125; if (i &lt;= n) min1 = i; else min1 = j; i = 1; j = 2; while (i &lt;= n &amp;&amp; j &lt;= n) &#123; if (i == j) j++; for (int len = 0; ; len++) &#123; if (s2[i+len] &lt; s2[j+len]) &#123; j = j + len + 1; break; &#125; if (s2[j+len] &lt; s2[i+len]) &#123; i = i + len + 1; break; &#125; &#125; &#125; if (i &lt;= n) min2 = i; else min2 = j; for (ri len = 0; len &lt; n; len++) &#123; if (s1[min1 + len] != s2[min2 + len]) &#123; yes = 0; break; &#125; &#125; if (yes) &#123; puts(\"TAK\"); if (t) &#123; for (ri a = min1; a &lt;= min1 + n - 1; a++) &#123; putchar(s1[a]); &#125; puts(\"\"); &#125; &#125; else puts(\"NIE\"); return 0;&#125;","categories":[],"tags":[]},{"title":"物流运输trans「ZJOI2006」","slug":"物流运输trans「ZJOI2006」","date":"2019-08-14T13:26:07.000Z","updated":"2020-09-07T15:13:12.000Z","comments":true,"path":"post/ade456a6.html/","link":"","permalink":"http://akdream.tk/post/ade456a6.html/","excerpt":"","text":"【题目描述】物流公司要把一批货物从码头$A$运到码头$B$。由于货物量比较大，需要$n$天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个$n$天的运输计划，使得总成本尽可能地小。 【输入格式】第一行是四个整数$n(1\\leq n\\leq 100), m(1\\leq m\\leq 20), K$和$e$。$n$表示货物运输所需天数，$m$表示码头总数，$K$表示每次修改运输路线所需成本。接下来$e$行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编号以及航线长度$(&gt;0)$。其中码头$A$编号为$1$，码头$B$编号为$m$。单位长度的运输费用为$1$。航线是双向的。再接下来一行是一个整数$d$，后面的$d$行每行是三个整数$P(1 &lt; P &lt; m), a, b(1 \\leq a \\leq b \\leq n)$。表示编号为$P$的码头从第$a$天到第$b$天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一条从码头$A$到码头$B$的运输路线。 【输出格式】包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。 【题解】设$f[i]$表示前$i$天的最小成本。则枚举$j$表示在第$j$天变更方案，有$f[i] = min(f[j] + K + cost(j+1, i)*(i-j))$，$cost(i, j)$表示第$i-j$天采用可行最优方案的每天的花费。$cost(i, j)$是可以用最短路求出的。枚举每个限制条件，若某个码头$k$不能使用的日期和$i-j$有交集，则将该码头标记为不能使用（将$vis[k]$设为$1$）。然后就可以用最短路求出每个$cost(i, j)$。注意从$f[0]$转移时不用加上$K$。 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define re registerusing namespace std;typedef long long ll;ll n, m, kk, e, d;ll head[10007], pre[20007], to[20007], dis[20007], len, ans[20007];ll cost[103][103], p[100007], a[100007], b[100007], dp[100007];bool vis[10007];ll read() &#123; ll ret = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = ret * 10 + ch - '0'; ch = getchar(); &#125; return ret;&#125;void insert(ll u, ll v, ll w) &#123; len++; to[len] = v, pre[len] = head[u], dis[len] = w, head[u] = len;&#125;void dijkstra() &#123; priority_queue&lt; pair&lt;ll, ll&gt; &gt; q; q.push(make_pair(0, 1)); ans[1] = 0; while (!q.empty()) &#123; ll c = q.top().second; q.pop(); if (vis[c]) continue; vis[c] = true; for (re ll i = head[c]; i != 0; i = pre[i]) &#123; if (ans[c] + dis[i] &lt; ans[to[i]]) &#123; ans[to[i]] = ans[c] + dis[i]; q.push(make_pair(-ans[to[i]], to[i])); &#125; &#125; &#125;&#125;int main() &#123; n = read(), m = read(), kk = read(), e = read(); for (ll i = 1; i &lt;= e; i++) &#123; ll u, v, w; u = read(), v = read(), w = read(); insert(u, v, w); insert(v, u, w); &#125; d = read(); for (ll i = 1; i &lt;= d; i++) &#123; p[i] = read(), a[i] = read(), b[i] = read(); &#125; for (ll i = 1; i &lt;= n; i++) for (ll j = i; j &lt;= n; j++) &#123; for (ll k = 1; k &lt;= m; k++) vis[k] = 0; for (ll k = 1; k &lt;= m; k++) ans[k] = 0x7fffffff; for (ll k = 1; k &lt;= d; k++) if ((a[k] &gt;= i &amp;&amp; a[k] &lt;= j) || (b[k] &gt;= i &amp;&amp; b[k] &lt;= j) || (a[k] &lt;= i &amp;&amp; b[k] &gt;= j)) vis[p[k]] = 1; dijkstra(); cost[i][j] = ans[m]; &#125; for (ll i = 1; i &lt;= n; i++) &#123; dp[i] = 0x7fffffff; for (ll j = 0; j &lt; i; j++) &#123; if (cost[j + 1][i] == 0x7fffffff) continue; if (j != 0) dp[i] = min(dp[j] + cost[j + 1][i] * (i - j) + kk, dp[i]); else dp[i] = min(dp[j] + cost[j + 1][i] * (i - j), dp[i]); &#125; &#125; printf(\"%lld\\n\", dp[n]); return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"不相交路径[BZOJ1471]","slug":"不相交路径[BZOJ1471]","date":"2019-08-13T13:05:48.000Z","updated":"2020-10-08T12:16:08.158Z","comments":true,"path":"post/cfc6935d.html/","link":"","permalink":"http://akdream.tk/post/cfc6935d.html/","excerpt":"","text":"最近学容斥的时候又碰到一道类似的题目，所以想分享一个套路，拿这题来举例【题目描述】给出一个$N(N\\leq 150)$个结点的有向无环简单图。给出4个不同的点$a,b,c,d$，定义不相交路径为两条路径，两条路径的起点分别为$a$和$c$，对应的两条路径的终点为$b$和$d$，要求满足这两条路径不相交，即两条路径上没有公共的点。 现在要求不相交路径的方案数。【输入格式】第一行为$N,M$。表示这个有向无环图有$N$个节点，$M$条边。 接下来$M$行，每行两个整数$x,y$。表示$x$至$y$有一条有向边。 接下来一行四个数$a,b,c,d$，意义如题中所述。【输出格式】输出为一行，即答案（方案数）。 在写这题之前，先看另外一个问题： 一个$N*M(N, M \\le 100000)$的矩阵，从$(0,0)$出发，每次可以向上或者向右走一步，问有多少种方案到达点$(N,M)$？很显然，答案是$C^N_{N*M}$。那如果规定有$K$个点是不能走的呢？$(k \\le 1000)$如果直接递推的话肯定是会超时的 所以我们要使用一些数学方法 具体来说，合法方案数等于总方案数减去不合法方案数 废话如果直接对于每个不合法点统计有多少路径经过它，然后用总数减去这些方案的话，很有可能会重复删减同一个方案，因为一种方案可能经过多个不合法点。所以我们改变一下思路，设$f[i]$表示有多少路径第一个经过的不合法点为$i$，最后用总方案数减去所有的$f[i]$。由于一条不合法路径无论如何都只会有一个【第一个经过的不合法点】，所以这种方法显然是正确的。 统计时，只需将所有不合法点先按照$X,Y$轴大小排好序，对于一个不合法点$i$，$f[i] = (从(0,0)到i点的方案数 - \\sum f[j]) * 从i点到(N,M)$的方案数，其中$j$是所有位于它左下方的点。时间复杂度$O(k^2)$，这就是数学的力♂量 再看此题，类似的，我们可以设$f[i]$表示第一次相交在$i$点的情况数。先用$DP, Floyd$,等各种奇葩方法求出任意两点$u, v$从$u$到$v$的路径数。然后按照拓扑序算出每个$f[i]$，$f[i] = (cnt[a][i] * cnt[b][i] - \\sum f[j] * cnt[j][i]^2) * cnt[i][c] * cnt[i][d]$，$j$为每个拓扑序在$i$之前的点。答案$=$总方案数$- \\sum f[i]$ 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll n, m, a, b, c, d, ans;ll x[505][505], in[505], f[505][505], g[505];ll que[5005], head = 1, tail;void toposort() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (in[i] == 0) que[++tail] = i, in[i] = -1; &#125; while (head &lt;= tail) &#123; ll c = que[head]; head++; for (int i = 1; i &lt;= n; i++) &#123; if (x[c][i]) &#123; in[i]--; if (in[i] == 0) que[++tail] = i, in[i] = -1; &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%lld %lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; ll xx, yy; scanf(\"%lld %lld\", &amp;xx, &amp;yy); x[xx][yy] = f[xx][yy] = 1; in[yy]++; &#125; scanf(\"%lld %lld %lld %lld\", &amp;a, &amp;b, &amp;c, &amp;d); toposort(); for (int i = 1; i &lt;= n; i++) f[i][i] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; ll u = que[i], v = que[j]; for (int k = 1; k &lt;= n; k++) &#123; if (x[v][k]) &#123; f[u][k] += f[u][v]; &#125; &#125; &#125; &#125; ans = f[a][b] * f[c][d]; for (int i = 1; i &lt;= n; i++) &#123; ll cur = que[i]; g[cur] = f[a][cur] * f[c][cur]; for (int j = i - 1; j &gt;= 1; j--)&#123; g[cur] -= g[que[j]] * f[que[j]][cur] * f[que[j]][cur]; &#125; ans -= g[cur] * f[cur][b] * f[cur][d]; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://akdream.tk/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"送礼物「JSOI 2015」","slug":"送礼物「JSOI 2015」","date":"2019-08-10T11:25:00.000Z","updated":"2020-10-08T12:16:08.745Z","comments":true,"path":"post/83006bc1.html/","link":"","permalink":"http://akdream.tk/post/83006bc1.html/","excerpt":"","text":"【题目描述】礼品店一共有N件礼物排成一列，每件礼物都有它的美观度。排在第$i(1\\leq i\\leq N)$个位置的礼物美观度为正整数$A_I$。JYY决定选出其中连续的一段，即编号为礼物$i,i+1,…,j-1,j$的礼物。选出这些礼物的美观程度定义为:$(M(i,j)-m(i,j))/(j-i+K)$,其中$M(i,j)$表示$max{A_i,A_{i+1}\\dots A_j}$，$m(i,j)$表示$min{A_i,A_{i+1}\\dots A_j}$，$K$为给定的正整数。 由于不能显得太小气，所以JYY所选礼物的件数最少为$L$件；同时，选得太多也不好拿，因此礼物最多选$R$件。JYY应该如何选择，才能得到最大的美观程度？由于礼物实在太多挑花眼，JYY打算把这个问题交给会编程的你。 【输入格式】本题每个测试点有多组数据。输入第一行包含一个正整数$T(T\\leq 10)$，表示有T组数据。 每组数据包含两行，第一行四个非负整数$N,K,L,R(2\\leq L\\leq R\\leq N)$。第二行包含$N$个正整数，依次表示$A_1,A_2….A_n$，$(A_i\\leq 10^8)$,$N, K\\leq 50,000$。 【输出格式】输出$T$行，每行一个非负实数，依次对应每组数据的答案，数据保证答案不会超过$10^3$。输出四舍五入保留4位小数。 【思路】这题暴力还是比较好写的，直接枚举礼物件数。。。良心题目 下面是正解： 很明显较优的一个区间取法是取一段区间$[l, r]$使得该区间最大值和最小值其中一个位于$A[l]$，另一个位于$A[r]$。因为如果使用这种取法，对于每对该区间内的最小值和最大值，$(r - l + k)$会尽量小。所以分类讨论：$1$区间大小小于限制$L$此时必须将区间大小扩大到$L$直接用单调队列维护长度为$L$区间的最大最小值，分别计算$n-L+1$个区间。$2$二分答案$x$ 对于一个区间$[L, R]$： 如果最大值在$A[L]$处，最小值在$A[R]$处，则有$A[L]-A[R]-(R-L+K) * x &gt; 0$; 若$max((A[i]+i * mid)-(A[j]+j * mid)-k * mid)&gt;=0$则$x$可以继续扩大。 如果最大值在$A[R]$处，最小值在$A[L]$处，则计算 $max((A[i]-i * mid)-(A[j]-j * mid)-k * mid)$是否大于0。 将$k * mid$移到不等式右边，剩下的$(A[i]-i * mid)$最大值可以用单调队列维护。 可以每次枚举位于左端点或右端点当作最大值，然后在合法的范围内通过单调队列找出一个最小值进行计算。 这题就做完了 好像依然没讲清楚 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;ll t, n, k, l, r;ll st1, st2, ed1, ed2;ll que1[50005], que2[50005];ll q[50005], head, tail;ll a[50005];double cur[50005];double ans;ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = ret * 10 + ch - '0'; ch = getchar(); &#125; return ret * flag;&#125;bool check(double mid) &#123; for (ri i = 1; i &lt;= n; i++) &#123; cur[i] = a[i] - mid * i; &#125; head = 1; tail = 0; double nowans = -1e9; for (ri i = l + 1; i &lt;= n; i++) &#123; while (head &lt;= tail &amp;&amp; i - q[head] &gt;= r) head++; while (head &lt;= tail &amp;&amp; cur[q[tail]] &gt;= cur[i - l]) tail--; q[++tail] = i - l; nowans = max(nowans, cur[i] - cur[q[head]]); &#125; for (ri i = 1; i &lt;= n; i++) &#123; cur[i] = a[i] + mid * i; &#125; head = 1; tail = 0; for (ri i = n - l; i &gt;= 1; i--) &#123; while (head &lt;= tail &amp;&amp; q[head] - i &gt;= r) head++; while (head &lt;= tail &amp;&amp; cur[q[tail]] &gt;= cur[i + l]) tail--; q[++tail] = i + l; nowans = max(nowans, cur[i] - cur[q[head]]); &#125; return nowans &gt;= k * mid;&#125;int main() &#123; t = read(); while (t--) &#123; n = read(); k = read(); l = read(); r = read(); for (ri i = 1; i &lt;= n; i++) &#123; a[i] = read(); &#125; st1 = st2 = 1; ed1 = ed2 = 0; for (ri i = 1; i &lt; l; i++) &#123; while (st1 &lt;= ed1 &amp;&amp; a[que1[ed1]] &gt;= a[i]) ed1--; while (st2 &lt;= ed2 &amp;&amp; a[que2[ed2]] &lt;= a[i]) ed2--; que1[++ed1] = que2[++ed2] = i; &#125; ans = -1e9; for (ri i = l; i &lt;= n; i++) &#123; while (st1 &lt;= ed1 &amp;&amp; i - que1[st1] &gt;= l) st1++; while (st2 &lt;= ed2 &amp;&amp; i - que2[st2] &gt;= l) st2++; while (st1 &lt;= ed1 &amp;&amp; a[que1[ed1]] &gt;= a[i]) ed1--; while (st2 &lt;= ed2 &amp;&amp; a[que2[ed2]] &lt;= a[i]) ed2--; que1[++ed1] = que2[++ed2] = i; ans = max(ans, 1.0 * (a[que2[st2]] - a[que1[st1]]) / (l + k - 1)); &#125; double l = 0, r = 1005, mid; while (r - l &gt;= 1e-7) &#123; mid = (l + r) / 2; if (check(mid)) &#123; l = mid + 0.000001; ans = max(ans, mid); &#125; else r = mid - 0.000001; &#125; printf(\"%.4lf\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"01分数规划","slug":"01分数规划","permalink":"http://akdream.tk/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"二分答案","slug":"二分答案","permalink":"http://akdream.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]},{"title":"大陆争霸[SDOI2010]","slug":"大陆争霸[SDOI2010]","date":"2019-08-08T14:36:00.000Z","updated":"2020-10-08T12:16:08.332Z","comments":true,"path":"post/a6fb1d1f.html/","link":"","permalink":"http://akdream.tk/post/a6fb1d1f.html/","excerpt":"","text":"只要你有无限个自爆机器人，你就能为所欲为 斯普林·布拉泽 【题目描述】略一句话题意：杰森国有$N$个城市，由$M$条单向道 路连接。杰森国的首都是城市$N$。你只需摧毁杰森国首都就能获胜。为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个城市，你就必须破坏掉维持这个城市结界的所有结界发生器。 现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间引爆，破坏一个目标（结界发生器，或是杰森国首都），当然机器人本身也会一起被破坏。你需要知道：击败杰森国所需的最短时间。【输入格式】第一行两个正整数 N, M。 接下来 M行，每行三个正整数$u_i, v_i ,w_i$，表示有一条从城市$u_i$到城市$v_i$的单向道路，自爆机器人通过这条道路需要$w_i$的时间。之后$N$行，每行描述一个城市。首先是一个正整数$l_i$，代表维持这个城市结界所使用的结界发生器数目。之后$l_i$个$1$~$N$之间的城市编号，表示每个结界发生器的 位置。如果$l_i = 0$，则说明该城市没有结界保护，保证$l_1 = 0$。【输出格式】仅包含一个正整数 ，击败杰森国所需的最短时间。 【思路点拨】如果没有结界的限制，很明显此题就只需要跑一遍$Dijkstra$就过了。第一眼看到这题就想到拓扑排序。当时在考场上先写了一个最短路算每个点到源点的最短距离，然后根据结界发生器的拓扑序更新$ans[i] = max(dist[i], ans[j])$，其中城市$j$的结界发生器维持城市$i$结界。大样例一次过，美滋滋考试结束， 【题目描述】$\\color{red}{Wrong\\ Answer\\qquad10}$不过，其实这题也就只需要在最短路算法上小小的改动一下就行了。开三个数组$dist, tme, ans$，$dist[i]$表示源点到点$i$的最短距离，$tme[i]$表示点$i$最早在此时解除结界，$ans[i]$则表示城市$i$最早能在$ans[i]$时被炸飞。显然，$ans[i] = max(dist[i], tme[i])$。而对于$tme[i]$，$\\forall j \\in L[i], tme[i] = max(ans[j])$，其中$L[i]$代表维持城市$i$结界的城市的集合。然后直接跑一遍$Dijkstra$, 不过要在更新完$L[i]$中所有的城市后才能将$i$入堆。最后的答案就是$ans[n]$，时间复杂度$O(m\\ log\\ n)$。 【代码实现】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define re registerusing namespace std;typedef long long ll;ll n, m;ll head[100005], pre[150005], to[150005], val[150005], len;ll h2[100005], p2[100005], t2[100005], l2, in[100005], ans[100005], dis[100005], tme[100005];bool vis[100005];ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = ret * 10 + ch - '0'; ch = getchar(); &#125; return ret * flag;&#125;void insert(ll u, ll v, ll w) &#123; to[++len] = v, val[len] = w, pre[len] = head[u], head[u] = len;&#125; void insert2(ll u, ll v) &#123; t2[++l2] = v, p2[l2] = h2[u], h2[u] = l2;&#125; void dijkstra() &#123; for (re int i = 1; i &lt;= n; i++) dis[i] = 0x7fffffff; dis[1] = tme[1] = ans[1] = 0; priority_queue&lt; pair&lt;ll, ll&gt; , vector&lt; pair&lt;ll, ll&gt; &gt; , greater&lt; pair&lt;ll, ll&gt; &gt; &gt; q; q.push(make_pair(0, 1)); while (!q.empty()) &#123; ll c = q.top().second; q.pop(); if (vis[c]) continue; vis[c] = 1; for (re ll i = head[c]; i != 0; i = pre[i]) &#123; if (ans[c] + val[i] &lt; dis[to[i]]) &#123; dis[to[i]] = ans[c] + val[i]; if (!in[to[i]]) &#123; ans[to[i]] = max(dis[to[i]], tme[to[i]]); q.push(make_pair(ans[to[i]], to[i])); &#125; &#125; &#125; for (re ll i = h2[c]; i != 0; i = p2[i]) &#123; if (in[t2[i]]) &#123; in[t2[i]]--; tme[t2[i]] = max(tme[t2[i]], ans[c]); if (!in[t2[i]]) &#123; ans[t2[i]] = max(dis[t2[i]], tme[t2[i]]); q.push(make_pair(ans[t2[i]], t2[i])); &#125; &#125; &#125; &#125;&#125;int main() &#123; n = read(); m = read(); ll u, v, w; for (re int i = 1; i &lt;= m; i++) &#123; u = read(), v = read(), w = read(); insert(u, v, w); &#125; for (re int i = 1; i &lt;= n; i++) &#123; in[i] = read(); for (re int j = 1; j &lt;= in[i]; j++) &#123; u = read(); insert2(u, i); &#125; &#125; dijkstra(); printf(\"%lld\\n\", ans[n]); return 0;&#125;","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"逛公园「NOIP2017」","slug":"逛公园「NOIP2017」","date":"2019-08-06T14:23:00.000Z","updated":"2020-10-08T12:16:08.787Z","comments":true,"path":"post/fdd8486f.html/","link":"","permalink":"http://akdream.tk/post/fdd8486f.html/","excerpt":"","text":"大家好我叫蒟蒻，这是我的第一篇信竞题解blog 【题目描述】策策同学特别喜欢逛公园。 公园可以看成一张$N$个点$M$条边构成的有向图，且没有自环和重边。其中$1$号点是公园的入口，$N$号点是公园的出口，每条边有一个非负权值，代表策策经过这条边所要花的时间。 策策每天都会去逛公园，他总是从$1$号点进去，从$N$号点出来。 策策喜欢新鲜的事物，他不希望有两天逛公园的路线完全一样，同时策策还是一个特别热爱学习的好孩子，他不希望每天在逛公园这件事上花费太多的时间。如果$1$号点到$N$号点的最短路长为$d$，那么策策只会喜欢长度不超过$d + K$的路线。 策策同学想知道总共有多少条满足条件的路线，你能帮帮他吗？ 为避免输出过大，答案对$P$取模。 如果有无穷多条合法的路线，请输出$-1$。 【输入格式】第一行包含一个整数$T$, 代表数据组数。 接下来$T$组数据，对于每组数据： 第一行包含四个整数$N,M,K,PN,M,K,P$， 每两个整数之间用一个空格隔开。 接下来$m$行，每行三个整数$a_i,b_i,c_i$， 代表编号为$a_i,b_i$的点之间有一条权值为$c_i$的有向边，每两个整数之间用一个空格隔开。 【输出格式】输出文件包含$T$行，每行一个整数代表答案。 【思路点拨】是个人应该都能看出此题是要先求出最短路.jpg亲测此题SPFA跑的比Dijkstra快为什么？我人品好最短路只能求出路径长度，计算路径条数似乎做不到——然后就gg了据说NOIP2017 Day1三题都没有DP 作为Day2压轴题 DP是压轴出场What is DP? Is that Dui Pai? 考虑DP的子状态 肯定有一维是要存储当前的点编号注意到此题$k \\le 50$第二维可以存储当前路径1-i的长度超出了1-i最短路多少于是$dp[i][j]$就表示$1-i$路径长度为$dis[i]$($1-i$最短路)$+ j$的方案数 对于任意一个$u$, 设它有一条路径连向$v$。则可以推出$dp[u][l] = \\sum dp[v][dis[u]-dis[v]+l-edge(u, v)] (1 \\le l \\le k)$然后就可以开始快乐DP了 如何判断$0$环？dfs的时候记录一下就行了要记得加记忆化搜索 贴心提示 日常全开$long long$是好习惯 多卡常 出奇迹【代码实现】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#define ri register long longusing namespace std;typedef long long ll; ll t, n, m, k, p, ans;ll head[200005], pre[800005], to[800005], val[800005], len;ll head2[200005], pre2[800005], to2[800005], val2[800005], len2;ll dis[200005], dis2[200005], visit[200005][61];ll dp[200005][61];//又到了我们最喜欢的DP时间 bool vis[200005], ok;inline ll read() &#123; ll ret = 0, flag = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 1) + (ret &lt;&lt; 3) + (ch ^ '0'); ch = getchar(); &#125; return ret * flag;&#125; inline void write(ll num) &#123; if (num &gt; 9) write(num / 10); putchar(num % 10 + '0');&#125;inline void insert(ll u, ll v, ll w) &#123; pre[++len] = head[u]; head[u] = len; to[len] = v; val[len] = w;&#125;inline void insert2(ll u, ll v, ll w) &#123; pre2[++len2] = head2[u]; head2[u] = len2; to2[len2] = v; val2[len2] = w;&#125;inline void add(ll &amp;a, ll b) &#123; //究极玄学卡常 a += b; if (a &gt; p) &#123; a -= p; &#125;&#125;inline void SPFA() &#123; vis[1] = 1; dis[1] = 0; queue&lt;ll&gt; q; q.push(1); while (!q.empty()) &#123; ll x = q.front(); q.pop(); for (ri i = head[x]; i != 0; i = pre[i]) &#123; ll y = to[i]; if (dis[y] &gt; dis[x] + val[i]) &#123; dis[y] = dis[x] + val[i]; if (!vis[y]) &#123; vis[y] = 1; q.push(y); &#125; &#125; &#125; vis[x] = 0; &#125;&#125;ll dfs(ll c, ll nowk) &#123; if (dp[c][nowk] != -1) return dp[c][nowk]; visit[c][nowk] = 1; dp[c][nowk] = 0; for (ri i = head2[c]; i; i = pre2[i]) &#123; ll next = dis[c] - dis[to2[i]] + nowk - val2[i]; if (next &lt; 0) continue; if (visit[to2[i]][next]) &#123; ok = 1; &#125; add(dp[c][nowk], dfs(to2[i], next)); &#125; visit[c][nowk] = 0; return dp[c][nowk];&#125;void This_is_a_dp() &#123; dp[1][0] = 1; for (ri i = 0; i &lt;= k; i++) &#123; add(ans, dfs(n, i)); &#125;&#125;int main() &#123; t = read(); while (t--) &#123; memset(head, 0, sizeof(head)); memset(head2, 0, sizeof(head2)); memset(dp, -1, sizeof(dp)); memset(visit, 0, sizeof(visit)); memset(vis, 0, sizeof(vis)); memset(dis, 0x7f, sizeof(dis)); ok = 0; len = ans = len2 = 0; n = read(); m = read(); k = read(); p = read(); for (ri i = 1; i &lt;= m; i++) &#123; ll u, v, w; u = read(); v = read(); w = read(); insert(u, v, w); insert2(v, u, w); &#125; SPFA(); /*DP!*/ This_is_a_dp(); dfs(n, k + 1); if (ok) &#123; puts(\"-1\"); continue; &#125; write(ans); puts(\"\"); &#125; return 0;&#125; 时间复杂度$O((k+x)m)$$(x$为$SPFA$玄学次数$)$","categories":[],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}],"categories":[],"tags":[{"name":"强/双连通分量","slug":"强-双连通分量","permalink":"http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"虚树","slug":"虚树","permalink":"http://akdream.tk/tags/%E8%99%9A%E6%A0%91/"},{"name":"01分数规划","slug":"01分数规划","permalink":"http://akdream.tk/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"FWT","slug":"FWT","permalink":"http://akdream.tk/tags/FWT/"},{"name":"仙人掌","slug":"仙人掌","permalink":"http://akdream.tk/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"线段树","slug":"线段树","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","permalink":"http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://akdream.tk/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"数位DP","slug":"数位DP","permalink":"http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"http://akdream.tk/tags/Link-cut-Tree/"},{"name":"莫队","slug":"莫队","permalink":"http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"},{"name":"Trie树","slug":"Trie树","permalink":"http://akdream.tk/tags/Trie%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://akdream.tk/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"点/边分治","slug":"点-边分治","permalink":"http://akdream.tk/tags/%E7%82%B9-%E8%BE%B9%E5%88%86%E6%B2%BB/"},{"name":"平衡树","slug":"平衡树","permalink":"http://akdream.tk/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"FFT","slug":"FFT","permalink":"http://akdream.tk/tags/FFT/"},{"name":"数论","slug":"数论","permalink":"http://akdream.tk/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯函数","slug":"莫比乌斯函数","permalink":"http://akdream.tk/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"},{"name":"树上启发式合并","slug":"树上启发式合并","permalink":"http://akdream.tk/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"博弈论","slug":"博弈论","permalink":"http://akdream.tk/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://akdream.tk/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"状压DP","slug":"状压DP","permalink":"http://akdream.tk/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"网络流","slug":"网络流","permalink":"http://akdream.tk/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"cdq分治","slug":"cdq分治","permalink":"http://akdream.tk/tags/cdq%E5%88%86%E6%B2%BB/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://akdream.tk/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://akdream.tk/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"计算几何","slug":"计算几何","permalink":"http://akdream.tk/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"二分答案","slug":"二分答案","permalink":"http://akdream.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://akdream.tk/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"KMP","slug":"KMP","permalink":"http://akdream.tk/tags/KMP/"},{"name":"差分约束","slug":"差分约束","permalink":"http://akdream.tk/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"概率DP","slug":"概率DP","permalink":"http://akdream.tk/tags/%E6%A6%82%E7%8E%87DP/"}]}