<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AK-dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://akdream.tk/"/>
  <updated>2020-10-06T12:29:08.000Z</updated>
  <id>http://akdream.tk/</id>
  
  <author>
    <name>AK-dream</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mr Panda and Survey[HDU6001]</title>
    <link href="http://akdream.tk/post/d3259d46.html/"/>
    <id>http://akdream.tk/post/d3259d46.html/</id>
    <published>2020-10-06T12:25:41.000Z</published>
    <updated>2020-10-06T12:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6001" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6001</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设$f(S)$表示有多少种选问卷的情况使得$S$中所有元素都不是好问题</p><p>设$ans[S]$表示选择的问题集合是$S$时，有多少种选择问卷的方案使得它们全部是好问题</p><p>那么由容斥原理，$ans[S]=2^n+\sum\limits_{S_2\subseteq S}(-1)^{t(S)}f(S)$，其中$t(S)$为$S$中元素个数</p><p>考虑如何预处理$f(S)$</p><p>对于每个问卷$x$，设$tag[x]=\sum\limits_{i=1}^{m}2^i[a[x][i]=Y]$，即如果第$i$个问题答案是yes那第$i$位就是$1$</p><p>设$cnt[p]$表示有多少$x$的$cnt[x]=p$</p><p>那么对于一种使得所有问题<strong>都不是好问题</strong>的选择方案，选择的所有问卷的$tag$一定相等</p><p>所以容易得出$f(2^n-1)=1+\sum\limits_{i=0}^{2^m-1}(2^{cnt[i]}-1)$</p><p>最前面那个$1$表示取空集</p><p>假设我们已经算出$f(S)$，考虑$S$去掉一个元素$i$得到的新集合$S_2$</p><p>那么此时$i$是不是好问题就无所谓了，所以可以直接把$i$这一位给“删掉”</p><p>具体实现中，可以对于所有包含$i$的集合$T$，让$cnt[T-i]+=cnt[T]$，然后这个$cnt[T]$就当它不存在，这样就相当于默认第$i$位是$0$(操作A)</p><p>(这里不是做减法，只是表示$T$集合去掉元素$i$)</p><p> 那么对于$f(S_2)$，枚举$S_2$的所有子集$S_3$(显然除了$S_3$以外的那些集合$T$的$cnt[T]$已经被我们当成不存在了)，有$f(S_2)=1+\sum\limits_{S_3\subseteq S_2}(2^{cnt[S_3]}-1)$</p><p>然后考虑用一个dfs，我们已经算出$f(S)$了，这时进行上面那个操作A，然后往$S_2$递归，就能算出$f(S_2)$</p><p>这一步的复杂度是$O(m^3)$的，这样就处理出了所有的$f(S)$</p><p>然后回到上面$ans[S]=2^n+\sum\limits_{S_2\subseteq S}(-1)^{t(S)}f(S)$，这一步的复杂度也是$O(m^3)$的，总时间复杂度为$O(tm^3)$(时限40s?)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>暂时还没有</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6001&quot; targe
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩阵游戏[NOI2013]</title>
    <link href="http://akdream.tk/post/cd282ac6.html/"/>
    <id>http://akdream.tk/post/cd282ac6.html/</id>
    <published>2020-09-27T14:26:06.000Z</published>
    <updated>2020-09-27T14:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足一个神奇的性质：若用$F[i][j]$来表示矩阵中第$i$行第$j$列的元素，则$F[i][j]$满足下面的递推式:</p><p>$$F[1][1]=1$$</p><p>$$F[i,j]=a\times F[i][j-1]+b (j\neq 1)$$</p><p>$$F[i,1]=c\times F[i-1][m]+d (i\neq 1)$$</p><p>递推式中$a,b,c,d$都是给定的常数。</p><p>现在婷婷想知道$F[n][m]$的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出$F[n][m]$除以$1,000,000,007$的余数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑$F[i][1]$和$F[i][m]$之间的关系：</p><p>$$F[i][m]=a(a(\cdots(a\times F[i][1]+b)\cdots)+b)+b$$<br>$$=a^{m-1}\times F[i][1] + a^{m-2}b + a^{m-3}b + \cdots + b$$<br>$$=a^{m-1}\times F[i][1] + \dfrac{a^{m-1}-1}{a-1}\times b$$</p><p>由此可得<br>$$F[i+1][1]=a^{m-1}c\times F[i][1] + \dfrac{a^{m-1}-1}{a-1}\times bc + d$$</p><p>设$A=a^{m-1}c,\ B=\dfrac{a^{m-1}-1}{a-1}\times bc + d$，则</p><p>$$F[i+1][1]=A\times F[i][1]+B$$</p><p>如法炮制，可得</p><p>$$F[n][1]=A^{n-1}\times F[1][1] + \dfrac{A^{n-1}-1}{A-1}\times B$$</p><p>由于$F[1][1]=1$，所以可以先把$F[n][1]$算出来，然后再使用上面那个$F[i][1]$和$F[i][m]$的关系式来推出$F[n][m]$即可</p><p>如何算$a^{m-1}$?</p><p>由于$a^{p-1}\equiv 1 \pmod p$，所以$a^{m-1}\equiv a^{(m-1)\bmod (p-1)} \pmod p$</p><p>那么对$m-1$取模$p-1$后再进行快速幂即可，$A^{n-1}$同理</p><p>注意特判$a=1$或者$A=1$的情况!!!</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">char</span> n[<span class="number">1000005</span>], m[<span class="number">1000005</span>];</span><br><span class="line">ll N, M, _N, _M;</span><br><span class="line">ll a, b, c, d, nl, ml, am, asum, B, A, Am, Asum;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; t; t &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, n + <span class="number">1</span>, m + <span class="number">1</span>);</span><br><span class="line">read(a); read(b); read(c); read(d);</span><br><span class="line">a %= mod; b %= mod; c %= mod; d %= mod;</span><br><span class="line">nl = <span class="built_in">strlen</span>(n + <span class="number">1</span>); ml = <span class="built_in">strlen</span>(m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i++) &#123;</span><br><span class="line">M = (M * <span class="number">10</span> % mod + m[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i++) &#123;</span><br><span class="line">_M = (_M * <span class="number">10</span> % (mod<span class="number">-1</span>) + m[i] - <span class="string">'0'</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nl; i++) &#123;</span><br><span class="line">N = (N * <span class="number">10</span> % mod + n[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nl; i++) &#123;</span><br><span class="line">_N = (_N * <span class="number">10</span> % (mod<span class="number">-1</span>) + n[i] - <span class="string">'0'</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">am = fpow(a, _M<span class="number">-1</span>); <span class="comment">//a^(p-1)==1 (mod p)</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) asum = M - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> asum = (am - <span class="number">1</span>) * fpow(a - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">B = (b * c % mod * asum % mod + d) % mod;</span><br><span class="line">A = am * c % mod;</span><br><span class="line"></span><br><span class="line">Am = fpow(A, _N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">1</span>) Asum = N - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> Asum = (Am - <span class="number">1</span>) * fpow(A - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">ans = (Am + B * Asum % mod) % mod; <span class="comment">// f[n][1]</span></span><br><span class="line">ans = (am * ans % mod + b * asum % mod) % mod; <span class="comment">//f[n][n]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>方伯伯的商场之旅[SCOI2014]</title>
    <link href="http://akdream.tk/post/b941660e.html/"/>
    <id>http://akdream.tk/post/b941660e.html/</id>
    <published>2020-09-26T14:05:25.000Z</published>
    <updated>2020-09-26T14:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第$j$堆的石子的数量，刚好是$i$写成$K$进制后的第$j$位。</p><p>现在方伯伯要玩一个游戏，商场会给方伯伯两个整数$L,R$。方伯伯要把位置在$[L,R]$中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量$\times$移动的距离。商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅有一行，包含三个用空格分隔的整数$L$，$R$，$K$，表示商场给方伯伯的两个整数，以及进制数。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个整数，表示最少的代价。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑用$1\sim R$的答案减掉$1\sim L-1$的答案，即$\operatorname{solve}(R) - \operatorname{solve}(L-1)$。</p><p>考虑$\operatorname{solve}(n)$，先计算把每个人的石子都全部合并到第$1$堆所需的代价</p><p>这个是可以通过一次数位dp解决的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(ll d, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs1(d<span class="number">-1</span>, sum + i * (d - <span class="number">1</span>), lim &amp; (i == mx)); </span><br><span class="line"><span class="comment">//第d位有i个石子要移动到第1位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这样一个性质：对于一个人$x$，假设他把所有石子最终全部移到第$k$位，我们把$k$叫做$x$的集合点，这样移动的代价是$f_x(k)$，那么$f_x$一定是一个单谷函数</p><p>不妨把$x$的最优集合点叫做$p_x$</p><p>所以我们可以执行这样的操作：</p><p><code>for i=2~n</code>，每次把所有 “集合点在$i$时比在$i-1$时更优 (即$f_x(i-1)&gt;f_x(i)$)” 的那些$x$的集合点全部从$i-1$变为$i$，也就是说让答案减去$f_x(i-1)-f_x(i)$</p><p>这样一来，由于$f_x$是单谷函数，那么一个人$x$一定在$i=2\sim p_x$的时候集合点被移动，那么$x$的最终代价就会是$f_x(p_x)$，所以这个做法是正确的</p><p>然后考虑如何进行这个”挪动集合点”的操作 其实和上面的那个计算集合点全为1的数位dp区别不大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(ll d, ll sum, ll p, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> max(<span class="number">0l</span>l, sum); <span class="comment">//如果sum&lt;0则说明不把集合点从p-1挪到p比较优</span></span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs2(d<span class="number">-1</span>, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll k, len, a[<span class="number">60</span>];</span><br><span class="line">ll L, R, f[<span class="number">60</span>][<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(ll d, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs1(d<span class="number">-1</span>, sum + i * (d - <span class="number">1</span>), lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(ll d, ll sum, ll p, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> max(<span class="number">0l</span>l, sum);</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs2(d<span class="number">-1</span>, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">ll tmp = n;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">a[++len] = tmp % k;</span><br><span class="line">tmp /= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">ll ret = dfs1(len, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">ret -= dfs2(len, <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;L, &amp;R, &amp;k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(R) - solve(L<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第
      
    
    </summary>
    
    
    
      <category term="数位DP" scheme="http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>树的计数[NOI2013]</title>
    <link href="http://akdream.tk/post/c65ab714.html/"/>
    <id>http://akdream.tk/post/c65ab714.html/</id>
    <published>2020-09-23T13:14:37.000Z</published>
    <updated>2020-09-26T14:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 <code>1 2 4 5 3</code>，BFS 序都是 <code>1 2 3 4 5</code>。</p><p><img src="http://akdream.tk/img/103_1.png" class="lazyload" data-srcset="http://akdream.tk/img/103_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有$K$棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是$h_1,h_2,\cdots,h_K$，那么请你输出：</p><p>$$\dfrac{h_1+h_2+\cdots +h_K}{K}$$</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含$n$个正整数 ，表示树的节点个数。</p><p>第二行包含$n$个正整数，是一个$1\dots n$的排列，表示树的 DFS 序。</p><p>第三行包含$n$个正整数，是一个$1\dots n$的排列，表示树的 BFS 序。</p><p>输入保证至少存在一棵树符合给定的两个序列。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出$1$个实数，四舍五入保留恰好三位小数，表示树高的平均值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于给出的dfs序和bfs序，一定有一种方法给点重新标号，使得bfs序变成$1,2,3,\cdots,n$这个样子</p><p>以样例为例：dfs序为$1,2,4,5,3$，bfs序为$1,2,3,4,5$</p><p>发现深度相同的点，在bfs序中一定是连续一段的，所以原题目可以看作给bfs序进行分段，使得分段后满足dfs序</p><p>样例中$n=5$，有4个分段点</p><p>经过观察，有如下几个分段的限制条件：</p><h3 id="条件一"><a href="#条件一" class="headerlink" title="条件一"></a>条件一</h3><p>深度为1的点一定只有一个(根)，所以$1$后面要进行分段。变为$1 | 2 3 4 5$</p><h3 id="条件二"><a href="#条件二" class="headerlink" title="条件二"></a>条件二</h3><p>设$p[i]$表示$i$在dfs序中在第几个，如$p[3]=5,p[4]=3$</p><p>对于$i \in [1, n)$，如果$p[i]&gt;p[i+1]$，那么有如下两种情况：</p><p>(以样例$p[3]&gt;p[4]$为例)</p><p><img src="http://akdream.tk/img/103_2.png" class="lazyload" data-srcset="http://akdream.tk/img/103_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>得到限制条件：对于$i \in [1, n)$，如果$p[i]&gt;p[i+1]$，那么$i$与$i+1$之间要分段</p><p>样例中，$3$和$4$之间必须要有分割线，即$1|23|45$</p><p>样例中，只有$3$满足$p[i]&gt;p[i+1]$，所以已经确定的必须要有的分割线为$1|23|45$</p><h3 id="条件三"><a href="#条件三" class="headerlink" title="条件三"></a>条件三</h3><p>dfs序为$12453$，$2$后一个为$4$，所以点$4$的深度最多比点$2$多$1$</p><p>在bfs序中，这就等价于说$2$和$4$之间最多有一条分割线</p><p>形式化地，设dfs序数组为$d[N]$，那么对于$i\in [1,n)$，如果$d[i]+1&lt;d[i+1]$，那么在bfs序中$d[i]$与$d[i+1]$之间最多有一条分割线</p><p>发现在样例中，$24$连在一起，那么$3$要不在$2$前面，要不在$4$后面</p><p>如果$3$在$2$前面，那么有$p[2]&gt;p[3]$，出现条件二的情况，$2$和$3$之间必须有分割线</p><p>如果$3$在$4$后面，那么有$p[3]&gt;p[4]$，出现条件二的情况，$3$和$4$之间必须有分割线</p><p>样例中就有$p[3]&gt;p[4]$，所以$3$和$4$之间必须有分割线</p><p>所以可以得出结论：$2$和$4$之间必定至少有一条 由条件二得出的必须存在的分割线</p><p>又因为$2$与$4$之间最多有一条分割线，所以$2\sim 4$之间别的未确定的空隙中就必定是没有分割线的</p><hr><p>以上就是3个分割条件，然后考虑如何实现</p><p>先找出所有的必须存在的分割线(条件一，二)</p><p>样例中必须存在的分割线就是$1|23|45$</p><p>然后根据条件三，$2\sim 4$之间剩余的空隙就不能填分割线，这里也就是$2$和$3$之间的那个空隙一定不能填</p><p>我们把所有 必须填/必须不填 的分割点打上标记，而可以自由选择填或不填的就不打标记</p><p>对于条件一，二，有必须要填的分割线，把必须要填的地方打上标记，并且让答案+1(必须多分割出一层)</p><p>对于条件三，有必须不填的分割线，把必须不填的地方打上差分标记</p><p>然后扫一遍，如果有可以自由选择填或不填的分割点，就让答案加上0.5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N], sum[N];</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); ans = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">read(x); b[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">a[i] = b[a[i]]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">b[a[i]] = i; </span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">1</span>]++; sum[<span class="number">2</span>]--; <span class="comment">//ban:1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; b[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//情况1：i后面必须分段</span></span><br><span class="line">ans++;</span><br><span class="line">sum[i]++; sum[i+<span class="number">1</span>]--;  <span class="comment">//ban:i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] + <span class="number">1</span> &lt; a[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//a[i]~a[i+1]只能分一次段， 且肯定至少有一个情况1</span></span><br><span class="line"><span class="comment">//若有大于等于两个情况1则无解 </span></span><br><span class="line">sum[a[i]]++; sum[a[i+<span class="number">1</span>]]--; <span class="comment">//ban:a[i]~a[i+1]-1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">now += sum[i]; <span class="comment">//差分 </span></span><br><span class="line"><span class="keyword">if</span> (!now) ans += <span class="number">0.5</span>; <span class="comment">//now==0表示可以自由选择在i后面分割 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>方伯伯的玉米田[SCOI2014]</title>
    <link href="http://akdream.tk/post/1dcb3735.html/"/>
    <id>http://akdream.tk/post/1dcb3735.html/</id>
    <published>2020-09-14T10:57:09.000Z</published>
    <updated>2020-09-14T10:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有$N$株，它们的高度参差不齐。<br>方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。<br>问能最多剩多少株玉米，来构成一排美丽的玉米。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数$N$，$K$，分别表示这排玉米的数目以及最多可进行多少次操作。<br>第二行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，最多剩下的玉米数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>有一个显而易见的贪心：即每次都是拔高以$n$结尾的一段区间是最优的</p><p>如果拔高了区间$[i,j]$，其中$j&lt;n$，那么换成拔高$[i,n]$一定不会让答案变得更劣</p><p>所以现在的问题就变成每次选择一段后缀上的玉米进行拔高</p><p>设$dp[i][j]$表示第$i$株玉米总计被拔高了$j$次时，以第$i$株玉米结尾的最长不降子序列的长度(这个子状态有亿点点难想到)</p><p>转移方程：$dp[i][j]=\max(dp[k][l])+1$，其中$k&lt;i,\ l\le j,\ a_k+l\le a_i+j$</p><p>那这个max怎么快速求得呢？似乎要用树套树 不过这题由于空间够用，所以树状数组套树状数组就行了</p><p>答案就是整个dp数组中的最大值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, a[N], dp[N][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">505</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">y++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= <span class="number">10000</span>; i += lowbit(i)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= <span class="number">501</span>; j += lowbit(j)) &#123;</span><br><span class="line">tr[i][j] = max(tr[i][j], v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">y++; <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j -= lowbit(j)) &#123;</span><br><span class="line">ret = max(ret, tr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">dp[i][j] = Query(a[i] + j, j) + <span class="number">1</span>;</span><br><span class="line">Update(a[i] + j, j, dp[i][j]);</span><br><span class="line">ans = max(ans, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有$N$株，它们的高度参差不齐。&lt;br&gt;方伯伯认为
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LCT的进阶应用</title>
    <link href="http://akdream.tk/post/cee3a0d7.html/"/>
    <id>http://akdream.tk/post/cee3a0d7.html/</id>
    <published>2020-08-08T14:59:38.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于LCT的进阶应用</p><p>不光是写算法思路，<del>因为已经有很多人写过了</del>，更重要的是代码写法中的细节，不然LCT各种奇怪应用的细节够你一题调一个小时</p><p><del>本篇文章将助你考试一遍过样例！</del></p><p>当然，还有一些基础应用比如维护路径信息或者维护联通性，但是代码都相对比较模板，所以也没什么好写</p><h2 id="一-LCT维护边双连通分量"><a href="#一-LCT维护边双连通分量" class="headerlink" title="一. LCT维护边双连通分量"></a>一. LCT维护边双连通分量</h2><p>有些题目中会动态加边并有形如“x到y之间有多少必经边” “某个边双内有多少点”的询问，这时候需要用LCT来维护边双联通分量</p><h3 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>注意到，如果把所有边双缩成点，那么一定会构成一个森林</p><p>此时如果新增了一条边$x,y$，一种情况是$x,y$不在同一棵树里，此时直接<code>link(x,y)</code>即可</p><p>一种情况是$x,y$在同一棵树中，但不在同一个边双中，那么就会形成一个新的边双</p><p>找出$x,y$所在的边双所缩成的点$fx,fy$，然后把$fx$到$fy$这条路径上的所有点缩成一个新点，并让这个新点来记录新的边双中的点的权值之和</p><p>实现时可以用并查集来记录每个点在哪个边双中</p><p>注意，维护边双时不支持删边操作，因为无法快速确定删除某个边双内部的一条边后会分裂成几个新的边双</p><h3 id="代码剖析"><a href="#代码剖析" class="headerlink" title="代码剖析"></a>代码剖析</h3><p>相信大家都已经记住原版LCT是怎么写的了 </p><p>这里来看一下维护边双的LCT和原版有哪些区别</p><h4 id="1-并查集维护每个点在哪个边双中"><a href="#1-并查集维护每个点在哪个边双中" class="headerlink" title="1. 并查集维护每个点在哪个边双中"></a>1. 并查集维护每个点在哪个边双中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;</span><br><span class="line"><span class="comment">//记得初始化并查集</span></span><br></pre></td></tr></table></figure><h4 id="2-access操作写法发生变化"><a href="#2-access操作写法发生变化" class="headerlink" title="2. access操作写法发生变化"></a>2. access操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = find(fa[x])) &#123; <span class="comment">//x每次跳到find(fa[x])而不是fa[x]</span></span><br><span class="line">splay(x); ch[x][<span class="number">1</span>] = i; </span><br><span class="line"><span class="keyword">if</span> (i) fa[i] = x; <span class="comment">//一定要把新的重儿子i的父亲设为x</span></span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-新增操作merge：将x到y的路径缩为一个点"><a href="#3-新增操作merge：将x到y的路径缩为一个点" class="headerlink" title="3. 新增操作merge：将x到y的路径缩为一个点"></a>3. 新增操作merge：将x到y的路径缩为一个点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">split(x, y); <span class="comment">//将x到y的路径提取出来</span></span><br><span class="line">q.push(y);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">//用bfs在二叉树上遍历x到y路径上的所有点</span></span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">Fa[find(u)] = y; <span class="comment">//维护并查集</span></span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">0</span>]) q.push(ch[u][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">1</span>]) q.push(ch[u][<span class="number">1</span>]);</span><br><span class="line">ch[u][<span class="number">0</span>] = ch[u][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">val[y] = sum[y]; <span class="comment">//y成为这个边双的代表元</span></span><br><span class="line"><span class="comment">//如果还有其它信息也是要全部让y来存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-连边-x-y-时的分类讨论"><a href="#4-连边-x-y-时的分类讨论" class="headerlink" title="4. 连边$x,y$时的分类讨论"></a>4. 连边$x,y$时的分类讨论</h4><p>伪代码如下 维护两点联通性可以再开一个并查集，也可以用<code>findroot</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LINK</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>; <span class="comment">//x,y已在同一边双中</span></span><br><span class="line"><span class="keyword">if</span> (x,y不在同一棵树中) &#123;</span><br><span class="line">link(x,y); <span class="comment">//如果用另一个并查集维护联通性记得更新并查集</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">merge(fx,fy); <span class="comment">//是fx,fy 不是x,y!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-进行任何修改-询问操作时都一定是对-fx-find-x-进行，而不是-x-本身！"><a href="#5-进行任何修改-询问操作时都一定是对-fx-find-x-进行，而不是-x-本身！" class="headerlink" title="5. 进行任何修改/询问操作时都一定是对$fx=find(x)$进行，而不是$x$本身！"></a>5. 进行任何修改/询问操作时都一定是对$fx=find(x)$进行，而不是$x$本身！</h4><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://darkbzoj.tk/problem/2959" target="_blank" rel="noopener">[bzoj2959]长跑</a><br><a href="https://www.luogu.com.cn/problem/P2542" target="_blank" rel="noopener">[AHOI2005]航线规划</a></p><h2 id="二-LCT维护子树信息"><a href="#二-LCT维护子树信息" class="headerlink" title="二. LCT维护子树信息"></a>二. LCT维护子树信息</h2><p>LCT一般用来维护路径信息而不是子树信息，因为LCT维护子树信息非常不方便。。。</p><p>但是有些毒瘤题可能在询问子树信息的同时还有加边删边操作，或者可能有换根操作，就只能被迫使用LCT了</p><h3 id="思路讲解-1"><a href="#思路讲解-1" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>假设现在需要用LCT维护原树中一个子树的$siz$</p><p>为了方便查询，一般会把原树中一条重链的顶端$x$的子树信息存储在 ($x$在LCT中所在的二叉树的根) 的位置<br><img src="http://akdream.tk/img/99_2.png" class="lazyload" data-srcset="http://akdream.tk/img/99_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如上图，原树中的$siz[1]$实际上存在LCT中的$siz[3]$里</p><p>但是一个点子树的$siz$不仅包含自己所在的那条重链的$siz$啊 如何维护轻子树的大小？</p><p>我们记$lsiz[x]$表示LCT中$x$的所有轻子树的$siz$之和，这样$siz[x]$就等于$siz[lson]+siz[rson]+lsiz[x]+1$</p><p>如果我们希望查询$x$点的子树信息，只需要<code>access(x)</code>，然后此时$x$就会位于一条重链的底端，那么$siz[lson]$和$siz[rson]$都为$0$，$siz[x]=lsiz[x]+1$，而此时LCT中$x$的轻子树一定一一对应着原树中$x$的子树，所以此时的$siz[x]$就是$x$在原树中的$siz$</p><p>如果需要查询以$x$为根时整棵子树的信息，只需<code>makeroot(x)</code>，然后直接查询</p><p>接下来的问题就在于如何维护这个$lsiz$了 来看一下代码</p><h3 id="代码剖析-1"><a href="#代码剖析-1" class="headerlink" title="代码剖析"></a>代码剖析</h3><h4 id="1-pushup操作写法发生变化"><a href="#1-pushup操作写法发生变化" class="headerlink" title="1. pushup操作写法发生变化"></a>1. pushup操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + lsum[x] + val[x]; <span class="comment">//lsum表示轻子树的权值和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-access操作写法发生变化-1"><a href="#2-access操作写法发生变化-1" class="headerlink" title="2. access操作写法发生变化"></a>2. access操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">lsum[x] += (siz[ch[x][<span class="number">1</span>]] - siz[i]); <span class="comment">//ch[x][1]变为轻儿子，而i不再是轻儿子</span></span><br><span class="line">ch[x][<span class="number">1</span>] = i; pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-link操作写法发生变化"><a href="#3-link操作写法发生变化" class="headerlink" title="3. link操作写法发生变化"></a>3. link操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); makeroot(y); <span class="comment">//x,y都要makeroot!</span></span><br><span class="line">fa[x] = y;</span><br><span class="line">lsum[y] += sum[x]; <span class="comment">//x成为y的轻儿子</span></span><br><span class="line">pushup(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-单点修改-x-时先-makeroot-x-！"><a href="#4-单点修改-x-时先-makeroot-x-！" class="headerlink" title="4. 单点修改$x$时先 makeroot(x)！"></a>4. 单点修改$x$时先 <code>makeroot(x)</code>！</h4><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P4219" target="_blank" rel="noopener">[BJOI2014]大融合</a><br><a href="https://www.luogu.com.cn/problem/P4299" target="_blank" rel="noopener">[bzoj3510]首都</a></p><h2 id="3-LCT维护形态树-权值树"><a href="#3-LCT维护形态树-权值树" class="headerlink" title="3. LCT维护形态树+权值树"></a>3. LCT维护形态树+权值树</h2><p>这类题目一般是要求维护树上路径信息，但是经常会对路径上的点权做一些奇怪的操作</p><p>如[BZOJ3159]决战：路径翻转操作<br> [GDSOI2017]中学生数据结构题：路径循环移位操作</p><h3 id="思路讲解-2"><a href="#思路讲解-2" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>众所周知，LCT上的Splay以原树中的节点深度为关键字，随便你怎么<code>rotate</code>，只要节点的相对次序不变，那么就只有辅助树的形态会发生改变，而对应的原树形态不变</p><p>在<code>makeroot(x)</code>操作中，我们翻转了以$x$为根的Splay，节点的相对次序发生了改变，所以其实在原树中就体现为原树的根变成了$x$</p><p>但是在这种题里，如果你还是为了维护权值胡乱操作辅助树Splay，那说不定什么时候你就不小心把哪个点变成原树的根了。。。</p><p>所以我们要再建出一棵辅助树来维护权值，使得在这棵辅助树上进行操作一定不会影响原树形态，我们把这棵辅助树叫做权值树，而LCT那棵叫形态树</p><p>这里我选择了非旋Treap来维护权值树</p><p>现在需要解决的问题就是 我们希望形态树和权值树是时刻对应的</p><p>比如说，现在LCT被分为这样几棵Splay：$[1,2],[3,5,6],[4,7]$，那么此时权值树一定也是被这样划分为3棵的</p><p>还有一个东西也要对应，就是形态树的中序遍历序列要时刻与权值树的中序遍历序列相同，这样才能够保证形态树中某棵平衡树排名第$k$的点和权值树中对应平衡树的第$k$个点是同一个点，方便进行修改</p><p>比如说此时形态树中3棵平衡树的中序遍历分别为$[1,2],[6,3,5],[7,4]$，那么权值树也要一样，绝不可能是$[1,2],[5,3,6],[4,7]$</p><p>为了实现这个功能，我们需要在LCT更改轻边重边时同样维护权值树的连边</p><p>同时为了方便查询，还需要动态维护每棵形态树中的平衡树对应着权值树中的哪一棵平衡树</p><p>用$rt[x]$来维护这个信息，一定要保证形态树中每棵平衡树的树根的$rt[x]$是权值树对应的那棵平衡树的树根，这样才能正确修改和查询</p><h3 id="代码剖析-2"><a href="#代码剖析-2" class="headerlink" title="代码剖析"></a>代码剖析</h3><h4 id="1-权值树该怎么写怎么写，写一个正常的平衡树就行"><a href="#1-权值树该怎么写怎么写，写一个正常的平衡树就行" class="headerlink" title="1. 权值树该怎么写怎么写，写一个正常的平衡树就行"></a>1. 权值树该怎么写怎么写，写一个正常的平衡树就行</h4><h4 id="2-splay操作写法发生变化"><a href="#2-splay操作写法发生变化" class="headerlink" title="2. splay操作写法发生变化"></a>2. splay操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">q[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">int</span> i; <span class="keyword">for</span> (i = x; !isroot(i); i = fa[i]) q[++top] = fa[i];</span><br><span class="line">swap(rt[i], rt[x]); <span class="comment">//x将会变成平衡树的根，把原来根的rt值给x</span></span><br><span class="line"><span class="keyword">while</span> (top) pushdown(q[top--]); </span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ((ch[z][<span class="number">1</span>] == y) ^ (ch[y][<span class="number">1</span>] == x)) ? rotate(x) : rotate(y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-划重点！access操作写法"><a href="#3-划重点！access操作写法" class="headerlink" title="3. 划重点！access操作写法"></a>3. 划重点！access操作写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">VAL::split(rt[x], siz[x] - siz[ch[x][<span class="number">1</span>]], rt[x], rt[ch[x][<span class="number">1</span>]]);</span><br><span class="line"><span class="comment">//x的重儿子不再是ch[x][1]，把它的子树从x对应的平衡树中删去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">rt[x] = VAL::merge(rt[x], rt[i]); </span><br><span class="line"><span class="comment">//i成为x的重儿子，把它的子树加入x对应的平衡树</span></span><br><span class="line"><span class="comment">//注意merge顺序</span></span><br><span class="line">&#125;</span><br><span class="line">ch[x][<span class="number">1</span>] = i; pushup(x); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-makeroot操作写法发生变化"><a href="#3-makeroot操作写法发生变化" class="headerlink" title="3. makeroot操作写法发生变化"></a>3. makeroot操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">access(x); splay(x); rev(x); </span><br><span class="line">VAL::Rev(rt[x]); <span class="comment">//为了保证中序遍历相同，权值树也要翻转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-对于任何修改-查询，先split-x-y-，然后在权值树的对应平衡树上修改-查询"><a href="#4-对于任何修改-查询，先split-x-y-，然后在权值树的对应平衡树上修改-查询" class="headerlink" title="4. 对于任何修改/查询，先split(x,y)，然后在权值树的对应平衡树上修改/查询"></a>4. 对于任何修改/查询，先split(x,y)，然后在权值树的对应平衡树上修改/查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll v)</span> </span>&#123; split(x, y); VAL::Add(rt[y], v); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); VAL::Rev(rt[y]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Qsum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> VAL::sum[rt[y]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Qmax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> VAL::mx[rt[y]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Qmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> VAL::mn[rt[y]]; &#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="https://darkbzoj.tk/problem/3159" target="_blank" rel="noopener">[bzoj3159]决战</a></p><h2 id="4-LCT维护边权信息"><a href="#4-LCT维护边权信息" class="headerlink" title="4. LCT维护边权信息"></a>4. LCT维护边权信息</h2><p>LCT怎么维护边权？LCT维护不了边权。</p><p>但是可以把边拆成点，然后就变成维护点权了（</p><p>多用于维护生成树</p><h3 id="思路讲解-3"><a href="#思路讲解-3" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>新科技：KrusLCT算法$O(m\log m)$求最小生成树！</p><p>对于一条边$(u,v)$，新建一个点$w$，把$w$的点权设为边权，$u,v$的点权视题目设成正无穷，负无穷，$0$之类的，然后连边$(u,w)$，$(w,v)$</p><p>这样有什么好处呢？如果我想要查询$x$到$y$路径上的最大边权，只需要在LCT上查询$x$到$y$的最大点权就好了</p><p>所以可以口胡出一个最小生成树算法：</p><p>按顺序考虑每一条边$u,v$：若$u,v$不连通，则在LCT中连上$u,v$</p><p>否则找出LCT上$u,v$路径上的最大点权，若这个”点”权大于当前边$u,v$的边权，就把那条边断开，连上这条边</p><p>当然这就是LCT维护边权的一个应用，其实理解起来非常简单</p><h3 id="代码剖析-3"><a href="#代码剖析-3" class="headerlink" title="代码剖析"></a>代码剖析</h3><p>实在是没有什么好写的了 因为和普通的LCT没有什么区别，唯一的区别就是连边/删边要删两条？</p><h4 id="1-我到底应该删哪两条边？"><a href="#1-我到底应该删哪两条边？" class="headerlink" title="1. 我到底应该删哪两条边？"></a>1. 我到底应该删哪两条边？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 map&lt;pair&lt;int, int&gt; , int&gt; !!!</span></span><br></pre></td></tr></table></figure><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P2387" target="_blank" rel="noopener">[NOI2014]魔法森林</a><br><a href="https://www.luogu.com.cn/problem/P4172" target="_blank" rel="noopener">[WC2006]水管局长</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于LCT的进阶应用&lt;/p&gt;
&lt;p&gt;不光是写算法思路，&lt;del&gt;因为已经有很多人写过了&lt;/del&gt;，更重要的是代码写法中的细节，不然LCT各种奇怪应用的细节够你一题调一个小时&lt;/p&gt;
&lt;p&gt;&lt;del&gt;本篇文章将助你考试一遍过样例！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;当然，还有一些基
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>长跑[BZOJ2959]</title>
    <link href="http://akdream.tk/post/f9901713.html/"/>
    <id>http://akdream.tk/post/f9901713.html/</id>
    <published>2020-08-06T12:38:27.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加3000米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。为了让同学们更好地监督自己，学校推行了刷卡机制。学校中有$n$个地点，用$1$到$n$的整数表示，每个地点设有若干个刷卡机。有以下三类事件：</p><ol><li>修建了一条连接A地点和B地点的跑道。</li><li>A点的刷卡机台数变为了B。</li><li>进行了一次长跑。问一个同学从A出发，最后到达B最多可以刷卡多少次。具体的要求如下：</li></ol><p>当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从A地点到B地点能刷卡的最多次数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个正整数$n,m$，表示地点的个数和操作的个数。</p><p>第二行包含$n$个非负整数，其中第$i$个数为第个地点最开始刷卡机的台数。</p><p>接下来有$m$行，每行包含三个非负整数$P,A,B$，$P$为事件类型，$A,B$为事件的两个参数。</p><p>最初所有地点之间都没有跑道。</p><p>每行相邻的两个数之间均用一个空格隔开。表示地点编号的数均在$1$到$n$之间，每个地点的刷卡机台数始终不超过$10000$，$P=1,2,3$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出的行数等于第3类事件的个数，每行表示一个第3类事件。如果该情况下存在一种设定跑道方向的方案和路径的方案，可以到达，则输出最多可以刷卡的次数。如果A不能到达B，则输出$-1$。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>LCT维护边双连通分量</p><p>说是叫边双连通分量，其实就是在连边导致产生环时把环缩成一个点</p><p>例如此题，显然，如果进入了一个环的某个点，那么就一定能把这个环上所有点全部走完，然后再从任意一个点出去</p><p>所以可以把所有环缩成点，点权为环上所有点权之和，这样原图就变成了一棵树，每次直接查询A所在的环到B所在的环之间路径的点权和即可</p><p>然后此题就做完了</p><p>实现也非常简单，可以开并查集来记录两个点是否在同一个边双里，大部分操作与普通的LCT无异，但是有一些细节：</p><ol><li><p>LCT内部维护一个并查集记录两个点是否在同一个边双内，外部还要维护一个并查集记录两个点当前是否联通</p></li><li><p><code>access</code>时跳父亲要跳到find(fa[x])上，更改重儿子时还要记得把新的重儿子的父亲设为自己！</p></li><li><p>如果在两点之间连边时，两点已在同一棵树中，但不在同一个边双中，则要把两点之间的路径上的点合并为一个点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">split(x, y);</span><br><span class="line">q.push(y);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">Fa[find(u)] = y;</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">0</span>]) q.push(ch[u][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">1</span>]) q.push(ch[u][<span class="number">1</span>]);</span><br><span class="line">ch[u][<span class="number">0</span>] = ch[u][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//把儿子清零避免pushup时出错！</span></span><br><span class="line">&#125;</span><br><span class="line">val[y] = sum[y]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行任何操作时(例如<code>link</code>,<code>split</code>)，都是对find(x)进行修改，而不是$x$！</p></li></ol><p>更多细节详见代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">return</span> x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line"><span class="keyword">int</span> Fa[N], fa[N], ch[N][<span class="number">2</span>], sum[N], val[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]); tag[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>; tag[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) rev(ch[x][<span class="number">0</span>]); <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) rev(ch[x][<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], k = (ch[y][<span class="number">1</span>]==x);</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y;</span><br><span class="line">ch[x][!k] = y; fa[y] = x;</span><br><span class="line">pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ((ch[y][<span class="number">1</span>]==x)^(ch[z][<span class="number">1</span>]==y)) ? rotate(x) : rotate(y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = find(fa[x])) &#123;</span><br><span class="line">splay(x); ch[x][<span class="number">1</span>] = i; </span><br><span class="line"><span class="keyword">if</span> (i) fa[i] = x; </span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">access(x); splay(x); rev(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); access(y); splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">split(x, y);</span><br><span class="line">q.push(y);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">Fa[find(u)] = y;</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">0</span>]) q.push(ch[u][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">1</span>]) q.push(ch[u][<span class="number">1</span>]);</span><br><span class="line">ch[u][<span class="number">0</span>] = ch[u][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">val[y] = sum[y]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Fa[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = LCT::find(x), fy = LCT::find(y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> u = find(x), v = find(y);</span><br><span class="line"><span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">Fa[u] = v;</span><br><span class="line">LCT::link(fx, fy);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LCT::merge(fx, fy);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = read(), m = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = LCT::val[i] = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Fa[i] = LCT::Fa[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tp, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">tp = read(); x = read(); y = read();</span><br><span class="line"><span class="keyword">if</span> (tp == <span class="number">1</span>) &#123;</span><br><span class="line">Link(x, y);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tp == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> v = y - a[x];</span><br><span class="line">a[x] = y;</span><br><span class="line"><span class="keyword">int</span> fx = LCT::find(x);</span><br><span class="line">LCT::makeroot(fx);</span><br><span class="line">LCT::val[fx] += v;</span><br><span class="line">LCT::pushup(fx);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (find(x) != find(y)) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> fx = LCT::find(x), fy = LCT::find(y);</span><br><span class="line">LCT::split(fx, fy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCT::sum[fy]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>我们的CPU遭到攻击[LOJ558]</title>
    <link href="http://akdream.tk/post/53e0f243.html/"/>
    <id>http://akdream.tk/post/53e0f243.html/</id>
    <published>2020-08-06T12:36:25.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个有$n$个点的森林，点有黑白两种颜色，初始时所有点都是白色，森林的每条边有边权，初始时这个森林有$m$条边。  </p><p>对这个森林进行$k$次操作，操作有三种：</p><ul><li><code>L u v w</code>：添加一条连接$u$和$v$，长度为$w$的边。</li><li><code>C u v</code>：删除连接$u$和$v$的边（保证存在）。</li><li><code>F u</code>：反转点$u$的颜色（黑变白，白变黑）。</li><li><code>Q u</code>：询问所有与$u$相连的黑点到$u$的距离之和。（相连指的是在同一连通块中）</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行三个非负整数，分别表示$n,m,k$。<br>以下$m$行，每行三个整数$u,v,w$，表示初始时有一条边连接$u$和$v$，长度为$w$。<br>以下$k$行，每行描述一个操作，格式如上所述。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个 Q 操作，单独一行输出一个整数表示答案。</p><p>保证任何时候这个图都是一个森林。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>LCT维护子树信息</p><p>假设现在需要用LCT维护原树中一个子树的$siz$</p><p>为了方便查询，一般会把原树中一条重链的顶端$x$这个点的子树信息存储在($x$在LCT中所在的二叉树的根)的位置<br><img src="http://akdream.tk/img/99_2.png" class="lazyload" data-srcset="http://akdream.tk/img/99_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如上图，原树中的$siz[1]$实际上存在LCT中的$siz[3]$里，而$siz[1]$里存的其实是$1$和$2$的权值和</p><p>但是一个点子树的$siz$不仅包含自己所在的那条重链啊 如何维护轻子树的大小？</p><p>很简单，我们记$lsiz[x]$表示LCT中$x$的所有轻子树的$siz$之和，这样$siz[x]$就等于$siz[lson]+siz[rson]+lsiz[x]+1$</p><p>如何维护$lsiz$呢？首先，在<code>link(x,y)</code>操作时$y$会变成$x$的一个新的轻儿子，所以$lsiz[x]$要加上$siz[y]$</p><p>其次，<code>access</code>时经过的点的重儿子变成了轻儿子，而某个轻儿子变成了重儿子，要注意更新$lsiz$</p><p>总之记住轻儿子发生变化的时候记得更新$lsiz$即可</p><p>但是实际应用中我们肯定不会用LCT去维护子树$siz$这种这么简单的东西的<del>(好像还真有，而且不少)</del>，所以来看看这道题</p><p>对于询问操作，其实我们可以通过LCT来做一个<code>makeroot(u)</code>的操作，这样每次询问就变成了询问所有黑点到根的距离之和了</p><p>对于每条边$u,v$，新建一个点$w$，把$w$的点权设为边权，把$u,v$的点权设为$0$，然后在LCT中连$u,w$和$w,v$，这样询问路径长度就变成询问路径上的点权和了</p><p><img src="http://akdream.tk/img/99_1.png" class="lazyload" data-srcset="http://akdream.tk/img/99_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对于点$x$如何统计答案？</p><p>这里是一张LCT的部分图，图中的箭头表示某一个点走到根应该沿什么方向走</p><p>由于LCT中左子树的点在原树中深度较小，所以应该向左走</p><p>我们设$sum[x]$表示LCT中$x$子树的点权和，$siz[x]$表示有多少个黑点，$lsiz[x]$表示$x$的所有轻子树中共有多少个黑点</p><p>不难发现，如果图中所有点想要从$x$开始走到$x$所在重链的顶端，那么需要走过的路径长度是$sum[lson]+val[x]$</p><p>有多少个点要走过去呢？$lsiz[x]+siz[rson]$个，如果$x$也是黑点就还要额外+1</p><p>所以这里$x$的答案就是$(sum[lson]+val[x])*(lsiz[x]+siz[rson]+color[x])$</p><p>累加答案也可以用类似的方法 即$ans[x]=ans[lson]+ans[rson]+lightans[x]$；$lightans[x]$就是轻子树的答案之和</p><p>然后是一些细节：</p><p>进行<code>access</code>时，某个重儿子变成了轻儿子，而轻儿子变成了重儿子，所以要记得更新$lsiz[x]$之类的东西</p><p>注意，执行<code>makeroot</code>操作时翻转了整棵LCT，所以我们不仅要记录从右子树向左子树走的答案，还要记录从左到右的答案，这样才能$O(1)$翻转</p><p>时间复杂度$O(n\log n)$</p><p>代码还算较为好写 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> cch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; cch &gt; <span class="string">'9'</span> || cch &lt; <span class="string">'0'</span>; cch = getchar()) <span class="keyword">if</span> (cch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; cch &lt;= <span class="string">'9'</span> &amp;&amp; cch &gt;= <span class="string">'0'</span>; cch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (cch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), num = -num;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">9</span>) write(num / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(num % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tot, m, q, ch[N][<span class="number">2</span>], fa[N];</span><br><span class="line">ll siz[N], lsiz[N], tp[N], sum[N], val[N], lans[N], rans[N], light[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">siz[x] = lsiz[x] + siz[ch[x][<span class="number">0</span>]] + siz[ch[x][<span class="number">1</span>]] + tp[x];</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">lans[x] = lans[ch[x][<span class="number">0</span>]] + lans[ch[x][<span class="number">1</span>]] + light[x];</span><br><span class="line">lans[x] += (sum[ch[x][<span class="number">0</span>]] + val[x]) * (lsiz[x] + siz[ch[x][<span class="number">1</span>]] + tp[x]);</span><br><span class="line">rans[x] = rans[ch[x][<span class="number">0</span>]] + rans[ch[x][<span class="number">1</span>]] + light[x];</span><br><span class="line">rans[x] += (sum[ch[x][<span class="number">1</span>]] + val[x]) * (lsiz[x] + siz[ch[x][<span class="number">0</span>]] + tp[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">swap(lans[x], rans[x]);</span><br><span class="line">tag[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) rev(ch[x][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) rev(ch[x][<span class="number">0</span>]);</span><br><span class="line">tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], k = (ch[y][<span class="number">1</span>] == x);</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][k] = ch[x][k^<span class="number">1</span>]; fa[ch[x][k^<span class="number">1</span>]] = y;</span><br><span class="line">ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) &#123;</span><br><span class="line">((ch[y][<span class="number">1</span>] == z) ^ (ch[z][<span class="number">1</span>] == y)) ? rotate(x) : rotate(y);</span><br><span class="line">&#125;</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">lsiz[x] -= (siz[i] - siz[ch[x][<span class="number">1</span>]]);</span><br><span class="line">light[x] -= (lans[i] - lans[ch[x][<span class="number">1</span>]]);</span><br><span class="line">ch[x][<span class="number">1</span>] = i; pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">access(x); splay(x); rev(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); makeroot(y);</span><br><span class="line">fa[x] = y;</span><br><span class="line">lsiz[y] += siz[x]; </span><br><span class="line">light[y] += lans[x];</span><br><span class="line">pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); access(y); splay(y);</span><br><span class="line">ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>;</span><br><span class="line">pushup(y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; , <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m); read(q);</span><br><span class="line">tot = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">read(u); read(v); read(val[++tot]);</span><br><span class="line">link(u, tot); link(v, tot);</span><br><span class="line">mp[make_pair(u, v)] = mp[make_pair(v, u)] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'L'</span>) &#123;</span><br><span class="line">read(x); read(y); read(val[++tot]);</span><br><span class="line">link(x, tot); link(y, tot);</span><br><span class="line">mp[make_pair(x, y)] = mp[make_pair(y, x)] = tot;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">read(x); read(y);</span><br><span class="line"><span class="keyword">int</span> z = mp[make_pair(x, y)];</span><br><span class="line">mp[make_pair(x, y)] = mp[make_pair(y, x)] = <span class="number">0</span>;</span><br><span class="line">cut(x, z); cut(y, z);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'F'</span>) &#123;</span><br><span class="line">read(x);</span><br><span class="line">makeroot(x);</span><br><span class="line">tp[x] ^= <span class="number">1</span>;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">read(x);</span><br><span class="line">makeroot(x);</span><br><span class="line">write(lans[x]); </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一个有$n$个点的森林，点有黑白两种颜色，初始时所有点都是白色，森林的每条边有边权，初始时这个森林有$m$条边。  &lt;/
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>历史[ZJOI2018]</title>
    <link href="http://akdream.tk/post/5fefa37.html/"/>
    <id>http://akdream.tk/post/5fefa37.html/</id>
    <published>2020-08-06T12:34:59.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述-amp-输入-输出格式"><a href="#题目描述-amp-输入-输出格式" class="headerlink" title="题目描述&amp;输入/输出格式"></a>题目描述&amp;输入/输出格式</h3><p><a href="https://www.luogu.com.cn/problem/P4338" target="_blank" rel="noopener">[ZJOI2018]历史</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，没有修改时的答案可以使用树形DP解决</p><p><img src="http://akdream.tk/img/98_1.png" class="lazyload" data-srcset="http://akdream.tk/img/98_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>上图中，红色数字表示$a_x$，蓝色数字表示$x$子树的点权和$sum_x$</p><p>观察点$2$，显然只有$2,5,6$”崛起”时才有可能在$2$发动战争</p><p>显然，当操作顺序形如$5,2,5,6$时，会在$2$进行三次战争，为最大值。</p><p>再来看点$1$，其实我们可以把$2,5,6$三个点看作一个点，因为$2,5,6$两两的LCA都为$2$，若某时刻$6$在$5$之后一个崛起，则只会在$2$进行战争，而不会在$1$进行战争</p><p>于是此时可以把$sum_2$的点权看作$2$的点权，则此时一种最优的操作顺序为$2,1,2,3,2,2$，在$1$发动五次战争</p><p>接着再来找找规律，发现$sum_2=4$，而存在一种操作方案(即上面的$5,2,5,6$)使得相邻两次崛起的城市不相同，所以此时最多在$2$发动$sum_2-1$次战争</p><p>而$1$就不存在一种相邻元素不相同的操作方案了，因为来自$2$的操作次数过多</p><p>我们记$mx[u]=\max(, \max_{u,v\in E} \ sum[v]\ , ,, a[u])$，比如$mx[1]=\max(sum[2],sum[3],sum[4],a[1])=4$，$ans[x]$为最多在$x$发动多少次战争，则存在这样一个规律：</p><p>若$mx[x]*2\ge sum[x]+1$，则$ans[x]=2*(sum[x]-mx[x])$<br>否则$ans[x]=sum[x]-1$</p><p>然后按照上面的式子进行DP即可拿到30分的暴力分</p><p>如何处理修改？</p><p>发现每个点$x$最多有一个儿子$y$满足$sum[y]*2\ge sum[x]+1$，我们定义这个儿子$y$为$x$的”重”儿子</p><p>注意 一个点$x$可能没有任何”重”儿子</p><p>维护一棵没有makeroot操作的伪LCT，初始时每个点$x$向”重”儿子连实边，向其他儿子连轻边</p><p>每次修改时，从被修改的点$x$开始向上access，沿途把某些满足上述条件的轻边修改为重边，把不满足条件的重边修改成轻边</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">CCF -= ans[x]; <span class="comment">//不要在意变量名</span></span><br><span class="line"><span class="keyword">if</span> (son[x]) ans[x] = <span class="number">2</span> * (sum[x] - sum[son[x]]); <span class="comment">//如果有"重"儿子 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ans[x] = <span class="number">2</span> * (sum[x] - a[x]); <span class="comment">//如果自己点权过大 </span></span><br><span class="line"><span class="keyword">else</span> ans[x] = sum[x] - <span class="number">1</span>; <span class="comment">//没有点权过大的点或子树 </span></span><br><span class="line">CCF += ans[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">a[x] += v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) sum[ch[x][<span class="number">0</span>]] += v, tag[ch[x][<span class="number">0</span>]] += v; </span><br><span class="line"><span class="comment">//给重链上的祖先打标记</span></span><br><span class="line"><span class="comment">//要打标记是因为没有makeroot,没法用split把路径分割出来 </span></span><br><span class="line"><span class="comment">//只能通过把重链打上标记来加 </span></span><br><span class="line"><span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = son[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = son[x]; !isroot(j); j = fa[j]) stk[++top] = fa[j];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]); </span><br><span class="line"><span class="comment">//pushdown确保sum[son[x]]的值正确 </span></span><br><span class="line"><span class="keyword">if</span> (sum[son[x]] * <span class="number">2</span> &lt;= sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = <span class="number">0</span>, son[x] = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//判断还有没有"重"儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F = findroot(i); </span><br><span class="line"><span class="comment">//找到轻子树的深度最小的节点 </span></span><br><span class="line"><span class="comment">//它的sum才是整棵轻子树的sum </span></span><br><span class="line"><span class="keyword">if</span> (sum[F] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = F, son[x] = F; </span><br><span class="line"><span class="comment">//找到新的"重"儿子</span></span><br><span class="line">calc(x); <span class="comment">//更新答案 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个<code>CCF</code>变量维护的就是答案</p><p>注释应该足够详细了 LCT中的其他操作，例如<code>findroot</code>和<code>pushdown</code>，与原来无异</p><p>关于此题时间复杂度</p><p>复杂度由于重边轻边的不确定性，非常玄学。。。也许是$O(1000ms)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ccf = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ccf &gt; <span class="string">'9'</span> || ccf &lt; <span class="string">'0'</span>; ccf = getchar()) <span class="keyword">if</span> (ccf == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ccf &lt;= <span class="string">'9'</span> &amp;&amp; ccf &gt;= <span class="string">'0'</span>; ccf = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ccf ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), num = -num;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">9</span>) write(num / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(num % <span class="number">10</span> +<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line">ll CCF, a[N], sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; </span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Main&#123;</span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], ch[N][<span class="number">2</span>];</span><br><span class="line">ll tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">CCF -= ans[x];</span><br><span class="line"><span class="keyword">if</span> (son[x]) ans[x] = <span class="number">2</span> * (sum[x] - sum[son[x]]); <span class="comment">//如果有"重"儿子 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ans[x] = <span class="number">2</span> * (sum[x] - a[x]); <span class="comment">//如果自己点权过大 </span></span><br><span class="line"><span class="keyword">else</span> ans[x] = sum[x] - <span class="number">1</span>; <span class="comment">//没有点权过大的点或子树 </span></span><br><span class="line">CCF += ans[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sum[x] = a[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">fa[y] = x; dfs(y);</span><br><span class="line">sum[x] += sum[y];</span><br><span class="line"><span class="keyword">if</span> (!son[x] || sum[son[x]] &lt; sum[y]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum[son[x]] * <span class="number">2</span> &lt;= sum[x] + <span class="number">1</span>) son[x] = <span class="number">0</span>;</span><br><span class="line">calc(x);</span><br><span class="line">ch[x][<span class="number">1</span>] = son[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !tag[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) &#123;</span><br><span class="line">tag[ch[x][<span class="number">0</span>]] += tag[x];</span><br><span class="line">sum[ch[x][<span class="number">0</span>]] += tag[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">tag[ch[x][<span class="number">1</span>]] += tag[x];</span><br><span class="line">sum[ch[x][<span class="number">1</span>]] += tag[x];</span><br><span class="line">&#125;</span><br><span class="line">tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], k = (ch[y][<span class="number">1</span>]==x);</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y;</span><br><span class="line">ch[x][!k] = y; fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ((ch[y][<span class="number">1</span>]==x)^(ch[z][<span class="number">1</span>]==y))?rotate(x):rotate(y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">a[x] += v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) sum[ch[x][<span class="number">0</span>]] += v, tag[ch[x][<span class="number">0</span>]] += v; </span><br><span class="line"><span class="comment">//给重链上的祖先打标记</span></span><br><span class="line"><span class="comment">//要打标记是因为没有makeroot,没法用split把路径分割出来 </span></span><br><span class="line"><span class="comment">//只能通过把重链打上标记来加 </span></span><br><span class="line"><span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = son[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = son[x]; !isroot(j); j = fa[j]) stk[++top] = fa[j];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]); </span><br><span class="line"><span class="comment">//pushdown确保sum[son[x]]的值正确 </span></span><br><span class="line"><span class="keyword">if</span> (sum[son[x]] * <span class="number">2</span> &lt;= sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = <span class="number">0</span>, son[x] = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//判断还有没有"重"儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F = findroot(i); </span><br><span class="line"><span class="comment">//找到轻子树的深度最小的节点 </span></span><br><span class="line"><span class="comment">//它的sum才是整棵轻子树的sum </span></span><br><span class="line"><span class="keyword">if</span> (sum[F] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = F, son[x] = F; </span><br><span class="line"><span class="comment">//找到新的"重"儿子</span></span><br><span class="line">calc(x); <span class="comment">//更新答案 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, CCF);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, w; i &lt;= m; i++) &#123;</span><br><span class="line">read(x); read(w);</span><br><span class="line">access(x, w); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, CCF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) &#123;</span><br><span class="line">read(u); read(v);</span><br><span class="line">addedge(u, v);</span><br><span class="line">&#125;</span><br><span class="line">Main::solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述-amp-输入-输出格式&quot;&gt;&lt;a href=&quot;#题目描述-amp-输入-输出格式&quot; class=&quot;headerlink&quot; title=&quot;题目描述&amp;amp;输入/输出格式&quot;&gt;&lt;/a&gt;题目描述&amp;amp;输入/输出格式&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
      <category term="树形DP" scheme="http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>字符串[LOJ6517]</title>
    <link href="http://akdream.tk/post/b4d563a7.html/"/>
    <id>http://akdream.tk/post/b4d563a7.html/</id>
    <published>2020-08-02T14:15:29.000Z</published>
    <updated>2020-09-08T11:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有$N$个字符串，每个字符串有一个权值$v_i$。随后给出$M$次询问，每次对一个区间进行检测。令最长的字符串长度为$L$，那么会给出$g_1,\cdots,g_L$表示每个长度的字符串的「识别值」。</p><p>对若干个字符串构成的集合$P$进行测试的过程如下：</p><p>对字符串$S$定义$f(S)$表示$S$在$P$中以其为前缀出现的串的权值和。 那么如果$S$在$P$中作为前缀出现过，并且$B*f(S)+A*\mathrm{len}(S)\ge C$，那么则将$g_{\mathrm{len}(S)}$加入集合。</p><p>最后随机选择一个区间$[x,y]\ (1\le x\le y\le L)$，如果 $[x, y] \bigcap G =\not \emptyset$，那么测试成功，否则测试失败。输出测试成功的概率并用最简分数表示。</p><p>特别地，整数$k$表示为$k/1$。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行四个数$N, A, B, C$。</p><p>接下来一行$N$个数$v_1, \cdots, v_N$</p><p>接下来一行一个数$M$。</p><p>接下来$M$行，每行两个数$l,r$，表示对第$l$到第$r$个字符串进行测试。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>$M$个数表示答案。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先对题目中的$n$个串建出Trie树。显然如果在某一个$P$中有一个串以$S$为前缀出现，那么$S$一定是Trie树上的一个节点，也就是说Trie树上的每个节点都代表着一个$S$</p><p>考虑暴力做法，可以暴力在Trie树上查询$[l,r]$之间的字符串，在Trie树上查询串$i$时，对Trie树上经过的每个节点$S$，令$f(S)$加上$v_i$，然后判断是否满足$B*f(S)+A*\mathrm{len}(S)\ge C$，如果满足就把$g_{\mathrm{len}(S)}$加入集合$G$。</p><p>然后考虑怎么统计答案 显然测试成功的概率=1-测试失败的概率 </p><p>假设集合$G$中从小到大排序有$b_1,b_2,\cdots,b_k$这$k$个元素，那么测试失败的情况数就是$\sum\limits_{i=2}^{k} \dfrac{(b_i-b_{i-1})(b_i-b_{i-1}-1)}{2}$</p><p>因为如果测试失败，则$[x,y]$必然满足：对于某一个$i$，$b_i &lt; x \le y &lt; b_{i+1}$</p><p><img src="http://akdream.tk/img/97_1.png" class="lazyload" data-srcset="http://akdream.tk/img/97_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>这样我们就得到了一个$O(nm)$的算法</p><p>接下来考虑如何优化</p><p>发现询问是区间询问 可以用莫队来处理 需要支持每次在$P$中加入或删除一个字符串</p><p>修改时$f(S)$显然是可以在Trie树上维护的 可以证明时间复杂度的上限是$O(L\sqrt{N})$的</p><p>考虑如何维护集合$G$</p><p>我们设$V(x)=\dfrac{x(x+1)}{2}$，那么如果我们在集合$G$的$b_i$与$b_{i+1}$两个元素中插入一个元素$y$，那么答案就需要减去$V(b_{i+1}-b_i-1)$，然后加上$V(b_{i+1}-y-1)$和$V(y-b_i-1)$</p><p>删除$G$中的一个元素时同理</p><p>于是就可以想到一个用<code>set</code>维护$G$的naive做法 每次删除/插入元素$y$时找出它的前驱和后继来修改当前答案</p><p>不过这样时间复杂度是$O(M\sqrt{N}\log{N})$的 我们需要找到一个可以$O(1)$维护集合$G$的数据结构</p><p>链表这种数据结构 删除元素或查找前驱后继是$O(1)$的 但是如果要在指定位置插入元素就会很慢</p><p>所以我们可以换用只删除不插入的回滚莫队 这样插入操作就去和梁非凡共进晚餐了</p><p>然后我们就把$O(\log n)$修改的<code>set</code>成功换成了$O(1)$修改的链表 这样就得到了一个上限为$O((M+L)\sqrt{N})$的<del>大常数？</del>算法 可以通过此题</p><p>如果没有找到正确思路，代码非常非常难写。。。所以在这里放上注释过的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;nnum)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> cch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; cch &gt; <span class="string">'9'</span> || cch &lt; <span class="string">'0'</span>; cch = getchar()) <span class="keyword">if</span> (cch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; cch &lt;= <span class="string">'9'</span> &amp;&amp; cch &gt;= <span class="string">'0'</span>; cch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (cch ^ <span class="string">'0'</span>);</span><br><span class="line">nnum = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, st[N], ed[N], bst[N], bed[N], g[N&lt;&lt;<span class="number">2</span>], len[N&lt;&lt;<span class="number">2</span>], m, L, Q, sz, bcnt; </span><br><span class="line"><span class="keyword">char</span> s[N&lt;&lt;<span class="number">2</span>], t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ch[N&lt;&lt;<span class="number">2</span>][<span class="number">26</span>], tot, in[N], rnk[N&lt;&lt;<span class="number">2</span>], pre[N&lt;&lt;<span class="number">2</span>], nxt[N&lt;&lt;<span class="number">2</span>], num[N&lt;&lt;<span class="number">2</span>], top;</span><br><span class="line">ll ans1[N], ans2[N], v[N], cnt[N&lt;&lt;<span class="number">2</span>], nowans, a, b, c;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; changed[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//建Trie树</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ch[x][s[i]-<span class="string">'a'</span>]) &#123;</span><br><span class="line">ch[x][s[i]-<span class="string">'a'</span>] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line">x = ch[x][s[i]-<span class="string">'a'</span>];</span><br><span class="line">len[x] = i - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">V</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * b * cnt[x] + <span class="number">1l</span>l * a * len[x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123; <span class="comment">//删除操作，修改点权+修改链表+修改答案</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">x = ch[x][s[i]-<span class="string">'a'</span>];</span><br><span class="line">cnt[x] -= v[id];</span><br><span class="line"><span class="keyword">if</span> (V(x) &lt; c &amp;&amp; vis[x]) &#123; <span class="comment">//若当前节点不满足条件且现在在集合G里</span></span><br><span class="line"><span class="keyword">if</span> (!(--num[g[len[x]]])) &#123; <span class="comment">//将g[len_S]的出现次数-1</span></span><br><span class="line"><span class="keyword">int</span> y = g[len[x]], _pre = pre[y], _nxt = nxt[y];</span><br><span class="line">nowans -= calc(y - _pre - <span class="number">1</span>) + calc(_nxt - y - <span class="number">1</span>);</span><br><span class="line">nowans += calc(_nxt - _pre - <span class="number">1</span>); <span class="comment">//修改当前答案</span></span><br><span class="line">changed[++top] = make_pair(_pre, make_pair(pre[_pre], nxt[_pre])); </span><br><span class="line">changed[++top] = make_pair(_nxt, make_pair(pre[_nxt], nxt[_nxt]));</span><br><span class="line">                                <span class="comment">//记录一下哪些链表元素被修改了 回滚时暴力修改回去</span></span><br><span class="line">nxt[_pre] = _nxt; pre[_nxt] = _pre;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123; <span class="comment">//增加操作，仅修改点权，不修改链表和答案</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">x = ch[x][s[i]-<span class="string">'a'</span>];</span><br><span class="line">cnt[x] += v[id];</span><br><span class="line"><span class="keyword">if</span> (V(x) &gt;= c &amp;&amp; !vis[x]) &#123; <span class="comment">//若当前节点已满足条件且不在集合G里</span></span><br><span class="line">num[g[len[x]]]++;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node bb) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> in[l] != in[bb.l] ? l &lt; bb.l : r &gt; bb.r; </span><br><span class="line">                <span class="comment">//由于是只删不增的回滚莫队 所以右端点从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(a); read(b); read(c);</span><br><span class="line">sz = <span class="built_in">sqrt</span>(n); bcnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % sz == <span class="number">1</span>) bst[bcnt] = i;</span><br><span class="line">in[i] = bcnt;</span><br><span class="line"><span class="keyword">if</span> (i % sz == <span class="number">0</span>) bed[bcnt] = i, bcnt++;</span><br><span class="line">                <span class="comment">//表示一个块的起始和结束位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % sz == <span class="number">0</span>) bcnt--;</span><br><span class="line">bed[bcnt] = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, t + <span class="number">1</span>); l = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">L = max(L, l);</span><br><span class="line">st[i] = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l; j++) &#123;</span><br><span class="line">s[++m] = t[j];</span><br><span class="line">&#125;</span><br><span class="line">ed[i] = m; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; i++) &#123;</span><br><span class="line">read(g[i]);</span><br><span class="line">&#125;</span><br><span class="line">read(Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line">read(q[i].l); read(q[i].r); </span><br><span class="line">q[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">insert(st[i], ed[i]);</span><br><span class="line">&#125;</span><br><span class="line">num[L+<span class="number">1</span>] = <span class="number">114514</span>; <span class="comment">//哼哼啊啊啊啊</span></span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>, nl = <span class="number">0</span>, nr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i++) &#123;</span><br><span class="line">nowans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bst[i]; j &lt;= n; j++) &#123;</span><br><span class="line">add(st[j], ed[j], j); <span class="comment">//将 当前块的起始位置 ~ N 的所有字符串加入集合P</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= L + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num[j]) &#123; <span class="comment">//预处理出初始链表和初始答案</span></span><br><span class="line">pre[j] = lst; nxt[lst] = j; </span><br><span class="line">nowans += calc(j - lst - <span class="number">1</span>);</span><br><span class="line">lst = j;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">nr = n; <span class="comment">//当前右端点从N开始向左移动</span></span><br><span class="line"><span class="keyword">while</span> (in[q[now].l] == i) &#123;</span><br><span class="line"><span class="keyword">while</span> (nr &gt; q[now].r) del(st[nr], ed[nr], nr), nr--;</span><br><span class="line">top = <span class="number">0</span>; <span class="comment">//右端点的修改不用回滚！</span></span><br><span class="line">                        ll tmp = nowans; <span class="comment">//记录当前答案 方便查询完这次之后直接改回去</span></span><br><span class="line">nl = bst[i];</span><br><span class="line"><span class="keyword">while</span> (nl &lt; q[now].l) del(st[nl], ed[nl], nl), nl++; </span><br><span class="line">                        <span class="comment">//删除时 点权，链表，答案可以一起修改 但是撤销时最好要一个一个撤销比较好写</span></span><br><span class="line">ans1[q[now].id] = nowans;</span><br><span class="line">ans2[q[now].id] = <span class="number">1l</span>l * L * (L+<span class="number">1</span>) / <span class="number">2</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q[now].l - <span class="number">1</span>; j &gt;= bst[i]; j--) add(st[j], ed[j], j); <span class="comment">//撤销对Trie树上点权的修改</span></span><br><span class="line"><span class="keyword">while</span> (top) &#123; <span class="comment">//撤销对链表的修改</span></span><br><span class="line">pre[changed[top].first] = changed[top].second.first;</span><br><span class="line">nxt[changed[top].first] = changed[top].second.second;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">nowans = tmp; <span class="comment">//撤销对答案的修改</span></span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (nr &gt;= bst[i]) &#123; <span class="comment">//把剩余字符串全部删掉 相当于让P集合回到空集</span></span><br><span class="line">del(st[nr], ed[nr], nr);</span><br><span class="line">nr--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line">ans1[i] = ans2[i] - ans1[i];</span><br><span class="line"><span class="keyword">if</span> (ans1[i] == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"0/1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans1[i] == ans2[i]) <span class="built_in">puts</span>(<span class="string">"1/1"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll gcd = __gcd(ans1[i], ans2[i]);</span><br><span class="line">ans1[i] /= gcd; ans2[i] /= gcd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, ans1[i], ans2[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;有$N$个字符串，每个字符串有一个权值$v_i$。随后给出$M$次询问，每次对一个区间进行检测。令最长的字符串长度为$L$，
      
    
    </summary>
    
    
    
      <category term="莫队" scheme="http://akdream.tk/tags/%E8%8E%AB%E9%98%9F/"/>
    
      <category term="Trie树" scheme="http://akdream.tk/tags/Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>奥运公交[LOJ3255]</title>
    <link href="http://akdream.tk/post/b8eba3fa.html/"/>
    <id>http://akdream.tk/post/b8eba3fa.html/</id>
    <published>2020-07-31T14:18:32.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>JOI 王国共有$N$个城市，这些城市从$1$到$N$编号。共有$M$条公交线路连接这些城市，这些线路从$1$到$M$编号。第$i$条公交线是从城市$U_i$到城市$V_i$的，票价为$C_i$日元。如果乘客乘坐第$i$条公交线，他只能在城市$U_i$上车，在城市$V_i$下车。从一个城市到另一个城市可能有多条公交线。</p><p>不久，JOI 王国将举办奥运会。K 理事长是 JOI 王国交通部部长。他会在奥运会之前选择最多一条公交线，并翻转这条公交线的起点和终点，但不改变票价。换句话说，如果他选择第  条公交线，在奥运会期间它将不会从$U_i$城市开往$V_i$城市，而是从$V_i$城市开往$U_i$城市，但票价仍为$C_i$日元。翻转一条公交线需要$D_i$日元，并且这个钱是 K 理事长出的。为了避免迷惑行为，在奥运会期间不允许翻转公交线。</p><p>因为 K 理事长是 JOI 王国的交通部部长，在奥运会期间他会使用这些公交线在城市$1$和城市$N$之间往返。通过恰当地选择翻转某条（或不翻转任何）公交线，他想要最小化往返城市$1$和城市$N$的公交总票价与翻转公交线的代价和。</p><p>现给定城市数和公交线情况，写一个程序求出这个最小代价和。如果不能通过翻转某条公交线来达到往返城市$1$与城市$N$的目的，请输出$-1$。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数$N,M$，意义如题目描述；</p><p>接下来$M$行，每行四个整数$U_i,V_i,C_i,D_i$，意义如题目描述。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数，如果可以通过翻转某条（或不翻转任何）公交线使得可以往返于城市$1$与城市$N$，输出往返所需公交总票价与翻转公交线的代价和的最小值，否则输出$-1$。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>翻转一条边$u,v$后$1$到$N$的最短路：</p><h4 id="1-不经过翻转后的边-v-u-："><a href="#1-不经过翻转后的边-v-u-：" class="headerlink" title="(1) 不经过翻转后的边$v,u$："></a>(1) 不经过翻转后的边$v,u$：</h4><p>由于这种情况中我们不经过这条边 所以可以看作是删除了这条边</p><p>如果$u,v$在以$1$为源的最短路树上，那么删除这条边之后$1$到$N$的最短路可能会发生变化，需要重新跑一次 dijkstra (注意是不经过边$u,v$的)</p><p>如果不在最短路树上，则删除该边后$1$到$N$的最短路一定和原来的一样</p><h4 id="2-经过翻转后的边-v-u-："><a href="#2-经过翻转后的边-v-u-：" class="headerlink" title="(2) 经过翻转后的边$v,u$："></a>(2) 经过翻转后的边$v,u$：</h4><p>此时$1$到$N$的最短路为：</p><p>$1$到$v$的不经过边$u,v$的最短路 +$u$到$N$的不经过边$u,v$的最短路 +$\mathrm{dis}(v,u)$</p><p>求$1$到$v$的不经过边$u,v$的最短路同(1) </p><p>求$u$到$N$的不经过边$u,v$的最短路 可以在反图上找出以$N$为源的最短路树，然后判断$u,v$是否在这棵最短路树上，同(1)一样进行分类讨论</p><p>对于每条边$i$，我们可以开一个$mn[i]$取上面两种情况的最小值，这就是翻转边$u_i,v_i$后$1$到$N$的最短路</p><p>翻转某边后$N$到$1$的最短路同理，可以存在$mn2[i]$中</p><p>那么答案就是$\min_{i=1}^{m} mn[i]+mn2[i]+D_i$</p><p>最后记得计算一下不翻转边时的总代价</p><p>p.s. <code>inf</code>最好不要设得太大 不然好几个<code>inf</code>加一起就爆longlong了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">205</span>][<span class="number">2</span>], lst[<span class="number">205</span>][<span class="number">2</span>], from[M][<span class="number">2</span>], pre[M][<span class="number">2</span>], to[M][<span class="number">2</span>], sz[<span class="number">2</span>]; <span class="comment">//0:原图 1:反图 </span></span><br><span class="line">ll c[M][<span class="number">2</span>], d[M][<span class="number">2</span>], ans, mn[M][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> ok[M][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w, ll w2, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">pre[++sz[tp]][tp] = head[u][tp]; head[u][tp] = sz[tp]; ok[sz[tp]][tp] = <span class="number">1</span>;</span><br><span class="line">from[sz[tp]][tp] = u; to[sz[tp]][tp] = v; c[sz[tp]][tp] = w; d[sz[tp]][tp] = w2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;ll, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">ll dis[<span class="number">205</span>][<span class="number">2</span>], tmp[<span class="number">205</span>]; </span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">205</span>], tag[M][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i][tp] = inf;</span><br><span class="line">dis[s][tp] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x][tp]; i; i = pre[i][tp]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i][tp];</span><br><span class="line"><span class="keyword">if</span> (dis[y][tp] &gt; dis[x][tp] + c[i][tp]) &#123;</span><br><span class="line">dis[y][tp] = dis[x][tp] + c[i][tp];</span><br><span class="line">lst[y][tp] = i;</span><br><span class="line">q.push(make_pair(-dis[y][tp], y));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tmp_dij</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tmp[i] = inf;</span><br><span class="line">tmp[s] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x][tp]; i; i = pre[i][tp]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i][tp];</span><br><span class="line"><span class="keyword">if</span> (!ok[i][tp]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp[y] &gt; tmp[x] + c[i][tp]) &#123;</span><br><span class="line">tmp[y] = tmp[x] + c[i][tp];</span><br><span class="line">q.push(make_pair(-tmp[y], y));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">dijkstra(s, <span class="number">0</span>); </span><br><span class="line">dijkstra(t, <span class="number">1</span>); </span><br><span class="line"><span class="built_in">memset</span>(tag, <span class="number">0</span>, <span class="keyword">sizeof</span>(tag));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tag[lst[i][<span class="number">0</span>]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">tag[lst[i][<span class="number">1</span>]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz[<span class="number">0</span>]; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = from[i][<span class="number">0</span>], v = to[i][<span class="number">0</span>];</span><br><span class="line">ll now = c[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (!tag[i][<span class="number">0</span>]) &#123;</span><br><span class="line">mn[i][o] = dis[t][<span class="number">0</span>];</span><br><span class="line">now += dis[v][<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ok[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">tmp_dij(s, <span class="number">0</span>);</span><br><span class="line">ok[i][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">mn[i][o] = tmp[t]; </span><br><span class="line">now += tmp[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!tag[i][<span class="number">1</span>]) &#123;</span><br><span class="line">now += dis[u][<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ok[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">tmp_dij(t, <span class="number">1</span>);</span><br><span class="line">ok[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">now += tmp[u];</span><br><span class="line">&#125;</span><br><span class="line">mn[i][o] = min(mn[i][o], now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">ll cc, dd;</span><br><span class="line">read(u); read(v); read(cc); read(dd);</span><br><span class="line">addedge(u, v, cc, dd, <span class="number">0</span>);</span><br><span class="line">addedge(v, u, cc, dd, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans = inf; ll now = <span class="number">0</span>;</span><br><span class="line">dijkstra(<span class="number">1</span>, <span class="number">0</span>); now += dis[n][<span class="number">0</span>];</span><br><span class="line">dijkstra(n, <span class="number">0</span>); now += dis[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">ans = min(ans, now);</span><br><span class="line">solve(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">solve(n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">ans = min(ans, mn[i][<span class="number">0</span>] + mn[i][<span class="number">1</span>] + d[i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans &gt;= inf ? <span class="number">-1</span> : ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;JOI 王国共有$N$个城市，这些城市从$1$到$N$编号。共有$M$条公交线路连接这些城市，这些线路从$1$到$M$编号。
      
    
    </summary>
    
    
    
      <category term="最短路" scheme="http://akdream.tk/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>BLO-Blockade[POI2008]</title>
    <link href="http://akdream.tk/post/5959e41f.html/"/>
    <id>http://akdream.tk/post/5959e41f.html/</id>
    <published>2020-07-31T13:50:45.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在Byteotia有$n$个城镇。 一些城镇之间由无向边连接。在城镇外没有十字路口，尽管可能有桥，隧道或者高架公路（反正不考虑这些）。每两个城镇之间至多只有一条直接连接的道路。人们可以从任意一个城镇直接或间接到达另一个城镇。每个城镇都有一个公民，他们被孤独所困扰。事实证明，每个公民都想拜访其他所有公民一次（在主人所在的城镇）。所以，一共会有$n*(n-1)$次拜访。</p><p>不幸的是，一个程序员总罢工正在进行中，那些程序员迫切要求购买某个软件。作为抗议行动，程序员们计划封锁一些城镇，阻止人们进入，离开或者路过那里。正如我们所说，他们正在讨论选择哪些城镇会导致最严重的后果。</p><p>编写一个程序：</p><p>读入Byteotia的道路系统，对于每个被决定的城镇，如果它被封锁，有多少访问不会发生，输出结果。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行读入$n，m (1\le n\le 100\ 000, 1\le m\le 500\ 000)$，分别是城镇数目和道路数目</p><p>城镇编号$1\sim n$</p><p>接下来$m$行每行两个数字$a,b (1\le a&lt;b\le n)$，表示$a$和$b$之间有一条无向边</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出$n$行，每行一个数字，为第$i$个城镇被锁时不能发生的访问的数量。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然，只有被封锁的点为割点时，才会出现无法访问的情况</p><p>所以求出所有点双连通分量，对原图建出圆方树，只需要找出对于每个非叶子的圆点(原图中的割点)，有多少条圆点到圆点的路径经过它。当这个割点被封锁后，这些路径就无法访问了</p><p>把圆点的权值看作$1$，方点权值看作$0$，然后维护子树权值和就可以求出答案</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nn, m;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100005</span>], pre[<span class="number">1000005</span>], to[<span class="number">1000005</span>], sz;</span><br><span class="line"><span class="keyword">int</span> siz[<span class="number">200005</span>];</span><br><span class="line">ll ans[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; </span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">100005</span>], low[<span class="number">100005</span>], tme, q[<span class="number">100005</span>], top;</span><br><span class="line"><span class="keyword">bool</span> gd[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++tme;</span><br><span class="line">q[++top] = x;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">tarjan(y);</span><br><span class="line">low[x] = min(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &lt;= low[y]) &#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">z = q[top];</span><br><span class="line">e[n].push_back(z);</span><br><span class="line">e[z].push_back(n);</span><br><span class="line">top--;</span><br><span class="line">&#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">e[n].push_back(x);</span><br><span class="line">e[x].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low[x] = min(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= nn) siz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x]) &#123;</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= nn) &#123;</span><br><span class="line">ans[x] += <span class="number">1l</span>l * siz[x] * siz[y];</span><br><span class="line">&#125; </span><br><span class="line">siz[x] += siz[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= nn) &#123;</span><br><span class="line">ans[x] += <span class="number">1l</span>l * siz[x] * (nn - siz[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); nn = n; read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">read(a); read(b);</span><br><span class="line">addedge(a, b);</span><br><span class="line">&#125;</span><br><span class="line">tarjan(<span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i] * <span class="number">2</span>); <span class="comment">//u-&gt;v和v-&gt;u都要算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在Byteotia有$n$个城镇。 一些城镇之间由无向边连接。在城镇外没有十字路口，尽管可能有桥，隧道或者高架公路（反正不考
      
    
    </summary>
    
    
    
      <category term="强/双连通分量" scheme="http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>压力[BJOI2013]</title>
    <link href="http://akdream.tk/post/239a758c.html/"/>
    <id>http://akdream.tk/post/239a758c.html/</id>
    <published>2020-07-31T13:30:21.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如今,路由器和交换机构建起了互联网的骨架。处在互联网的骨干位置的核心路由器典型的要处理100Gbit/s的网络流量。他们每天都生活在巨大的压力之下。小强建立了一个模型。这世界上有$N$个网络设备,他们之间有$M$个双向的链接。这个世界是连通的。在一段时间里,有$Q$个数据包要从一个网络设备发送到另一个网络设备。一个网络设备承受的压力有多大呢?很显然,这取决于$Q$个数据包各自走的路径。不过,某些数据包无论走什么路径都不可避免的要通过某些网络设备。你要计算：对每个网络设备,必须通过(包括起点、终点)他的数据包有多少个?</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含3个由空格隔开的正整数$N,M,Q$。 接下来$M$行,每行两个整数$u,v$,表示第$u$个网络设备(从$1$开始编号)和第$v$个网络设备之间有一个链接。$u$不会等于$v$。两个网络设备之间可能有多个链接。 接下来$Q$行,每行两个整数$p,q$,表示第$p$个网络设备向第$q$个网络设备发 送了一个数据包。$p$不会等于$q$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出$N$行,每行$1$个整数,表示必须通过某个网络设备的数据包的数量。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果有一条路径必须经过某个点$x$，那么显然点$x$必为一个割点。</p><p>所以建出原图的圆方树，其中每个非叶子的圆点必然代表着原图的一个割点</p><p>然后对于一次$x$到$y$的数据传输，必须经过圆方树上$x,y$两点之间的路径，所以使用树上差分统计每个非叶子圆点被经过多少次即可</p><p>时间复杂度$O(n\log n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nn, m, Q;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">400005</span>], pre[<span class="number">400005</span>], to[<span class="number">400005</span>], sz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; </span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">400005</span>], low[<span class="number">400005</span>], tme, q[<span class="number">400005</span>], top;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">400005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++tme;</span><br><span class="line">q[++top] = x;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">tarjan(y);</span><br><span class="line">low[x] = min(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &lt;= low[y]) &#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">z = q[top];</span><br><span class="line">e[n].push_back(z);</span><br><span class="line">e[z].push_back(n);</span><br><span class="line">top--;</span><br><span class="line">&#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">e[n].push_back(x);</span><br><span class="line">e[x].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low[x] = min(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">400005</span>], p[<span class="number">400005</span>][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = e[x][i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">p[y][<span class="number">0</span>] = x;</span><br><span class="line">dfs1(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[x] - (<span class="number">1</span> &lt;&lt; i) &gt;= d[y]) x = p[x][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[x][i] != p[y][i]) &#123;</span><br><span class="line">x = p[x][i]; y = p[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = e[x][i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x);</span><br><span class="line">f[x] += f[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); nn = n; read(m); read(Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">read(a); read(b);</span><br><span class="line">addedge(a, b);</span><br><span class="line">&#125;</span><br><span class="line">tarjan(<span class="number">1</span>);</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; l) &lt;= n; l++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">p[i][l] = p[p[i][l<span class="number">-1</span>]][l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, lca;</span><br><span class="line">read(x); read(y);</span><br><span class="line">lca = LCA(x, y);</span><br><span class="line">f[x]++; f[y]++; f[lca]--; f[p[lca][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;如今,路由器和交换机构建起了互联网的骨架。处在互联网的骨干位置的核心路由器典型的要处理100Gbit/s的网络流量。他们每天
      
    
    </summary>
    
    
    
      <category term="强/双连通分量" scheme="http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Earthquake[USACO01OPEN]</title>
    <link href="http://akdream.tk/post/958dddf1.html/"/>
    <id>http://akdream.tk/post/958dddf1.html/</id>
    <published>2020-07-31T13:28:45.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一场地震把约翰家的牧场摧毁了， 坚强的约翰决心重建家园。 约翰已经重建了$n$个牧场，现在他希望能修建一些道路把它们连接起来。研究地形之后，约翰发现可供修建的道路有$m$条。碰巧的是，奶牛们最近也成立一个工程队，专门从事修复道路。而然，奶牛们很有经济头脑，如果无利可图，它们是不会干的。</p><p>奶牛们关注的是挣钱速度，即总利润和总施工时间的比值。约翰和奶牛达成了协议，奶牛负责修建道路，将所有牧场连通，而约翰需要支付$f$元。每条道路都有自己的施工时间和建造成本。连接两个相同的牧场的道路可能有多条。保证所有的牧场必定是可连通的，不过也有可能一些道路的建造成本之和会超过$f$。</p><p>请帮助奶牛们选择修复哪些道路，才能使单位时间的利润最大？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行三个整数$n,m,f$。</p><p>第二行到第$m+1$行，第$i+1$行表示第$i$条道路的信息。每行有四个整数$u_i,v_i,c_i,t_i$，$u_i$和$v_i$表示这条道路连接的牧场编号，$c_i$表示修建道路的成本，$t_i$表示道路修建所需要的时间。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行，一个保留四位小数的浮点数，表示奶牛们能挣到的最大单位时间利润，如果奶牛们无钱可赚，则输出 <code>0.0000</code>。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们想要求出$\dfrac{f-\sum c_ix_i}{\sum t_ix_i}$的最大值，其中$x_i=0$或$1$表示第$i$条路修或者不修</p><p>不妨设最大值为$P$，则有$\dfrac{f-\sum c_ix_i}{\sum t_ix_i} \le P$</p><p>变形一下得$\sum x_i(P*t_i+c_i) \ge f$</p><p>二分答案$mid$放到不等式中代替$P$，如果$mid &lt; P$，那么不等式左边就会偏小，我们需要找到有没有一种分配$x_i$的情况使得这个不等式不成立，即$\sum x_i(Pt_i+c_i) &lt; f$</p><p>如果能找到这样的解，则表示$mid &lt; P$，否则$mid \ge P$</p><p>由于我们想让左式尽可能小，所以把每条边的边权重新设为$mid*t_i+c_i$，然后再跑最小生成树求出左式的最小值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, F;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, c, t;</span><br><span class="line"><span class="keyword">double</span> val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125; e[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">405</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">e[i].val = e[i].c * <span class="number">1.0</span> + k * e[i].t;</span><br><span class="line">&#125;</span><br><span class="line">sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = find(e[i].u), ty = find(e[i].v);</span><br><span class="line"><span class="keyword">if</span> (tx != ty) &#123;</span><br><span class="line">ret += e[i].val;</span><br><span class="line">fa[ty] = tx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret &lt; F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m); read(F);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">read(e[i].u); read(e[i].v); read(e[i].c); read(e[i].t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">l = mid + <span class="number">0.000001</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> r = mid - <span class="number">0.000001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一场地震把约翰家的牧场摧毁了， 坚强的约翰决心重建家园。 约翰已经重建了$n$个牧场，现在他希望能修建一些道路把它们连接起来
      
    
    </summary>
    
    
    
      <category term="最小生成树" scheme="http://akdream.tk/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="01分数规划" scheme="http://akdream.tk/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>暴力写挂[CTSC2018]</title>
    <link href="http://akdream.tk/post/476e6451.html/"/>
    <id>http://akdream.tk/post/476e6451.html/</id>
    <published>2020-07-27T14:43:35.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两棵树$T$和$T’$</p><p>求<br>$$\max(\operatorname{depth}(x) + \operatorname{depth}(y) - ({\operatorname{depth}(\operatorname{LCA}(x,y))}+{\operatorname{depth’}(\operatorname{LCA’}(x,y))}))$$</p><p>注：带[$’$]的表示第二棵树</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>注意到题目给的这个<br>$$\operatorname{depth}(x) + \operatorname{depth}(y) - {\operatorname{depth}(\operatorname{LCA}(x,y))}-{\operatorname{depth’}(\operatorname{LCA’}(x,y))}$$<br>似乎不太好算</p><p>我们把前3项转换一下 发现上面这个式子实际上等于<br>$$\dfrac{1}{2}(\operatorname{depth}(x) + \operatorname{depth}(y) + \operatorname{dis}(x,y) - 2* \operatorname{depth’}(\operatorname{LCA’}(x,y)))$$</p><p>这样一来，前三项可以通过边分治处理出来，然后最后一项则需要在第二棵树上来计算</p><p>具体地说，我们对第一棵树进行边分治，然后将当前分治边左边的点标为黑点，右边标为白点</p><p><img src="https://img2020.cnblogs.com/blog/1755573/202007/1755573-20200726211701613-1994676982.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1755573/202007/1755573-20200726211701613-1994676982.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>假设一个点$x$到分治边的距离为$\operatorname{d}(x)$，分治边的长度是$v$，那么上面式子的前3项实际上就等于$\operatorname{depth}(x) + \operatorname{depth}(y) + (\operatorname{d}(x) + \operatorname{d}(y) + v)$</p><p>所以把每个点的点权$\operatorname{val}(x)$设为$\operatorname{depth}(x) + \operatorname{d}(x)$，然后就可以去处理第二棵树了</p><p>在第二棵树中枚举每个点作为lca，那么现在目标就是找到两个颜色不同，且在两个不同儿子子树里的点使得它们的$\operatorname{val}$之和最大</p><p>设$f[x][0]$表示$x$子树中最大的黑点权值，$f[x][1]$表示最大白点权值；然后就可以在第二棵树上进行dp来得到最大值 具体dp转移见代码</p><p>但是dp一次是$O(n)$的 所以我们还需要在dp之前对第二棵树建虚树 在虚树上dp</p><p>这样总时间复杂度就是$O(n\log^2 n)$的 依然会被卡掉。。。</p><p>如果想要$O(n\log n)$可以加上欧拉序+ST表求LCA以及基数排序建虚树来强行降低复杂度 这里我只写了个$O(1)$求LCA 吸氧后勉强卡过 基数排序什么的表示不懂</p><p>代码难度非常非常大 写到心态爆炸</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NN 370005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q[NN], tp[NN], tot;</span><br><span class="line">ll ww[NN], ans = <span class="number">-0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">namespace</span> p2&#123;</span><br><span class="line"><span class="keyword">int</span> head[NN], dfn[NN], pre[NN&lt;&lt;<span class="number">1</span>], to[NN&lt;&lt;<span class="number">1</span>], sz = <span class="number">1</span>, tme;</span><br><span class="line">ll val[NN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[NN], p[<span class="number">1000005</span>][<span class="number">21</span>], lg2[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> stk[NN], top;</span><br><span class="line">ll dep[NN], f[NN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> tag[NN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">p[++tme][<span class="number">0</span>] = x;</span><br><span class="line">dfn[x] = tme;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">dep[y] = dep[x] + val[i];</span><br><span class="line">dfs(y, x);</span><br><span class="line">p[++tme][<span class="number">0</span>] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dfn[x] &gt; dfn[y]) swap(x, y);</span><br><span class="line"><span class="keyword">int</span> l = dfn[x], r = dfn[y], len = dfn[y] - dfn[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[p[l][lg2[len]]] &lt; d[p[r-(<span class="number">1</span>&lt;&lt;lg2[len])+<span class="number">1</span>][lg2[len]]]) &#123;</span><br><span class="line"><span class="keyword">return</span> p[l][lg2[len]];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> p[r-(<span class="number">1</span>&lt;&lt;lg2[len])+<span class="number">1</span>][lg2[len]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tme; i++) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; l) &lt;= tme; l++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tme; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[p[i][l<span class="number">-1</span>]] &lt; d[p[i+(<span class="number">1</span>&lt;&lt;(l<span class="number">-1</span>))][l<span class="number">-1</span>]]) &#123;</span><br><span class="line">p[i][l] = p[i][l<span class="number">-1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> p[i][l] = p[i+(<span class="number">1</span>&lt;&lt;(l<span class="number">-1</span>))][l<span class="number">-1</span>];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">sz = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dfn[x] &lt; dfn[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildtree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sz = <span class="number">1</span>;</span><br><span class="line">sort(q + <span class="number">1</span>, q + tot + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) tag[q[i]] = <span class="number">1</span>;</span><br><span class="line">stk[top=<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">1</span>) &#123;</span><br><span class="line">stk[++top] = q[i]; </span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lca = LCA(stk[top], q[i]);</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[stk[top<span class="number">-1</span>]] &gt;= dfn[lca]) &#123;</span><br><span class="line">addedge(stk[top], stk[top<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lca != stk[top]) &#123;</span><br><span class="line">addedge(stk[top], lca, <span class="number">0</span>);</span><br><span class="line">stk[top] = lca;</span><br><span class="line">&#125;</span><br><span class="line">stk[++top] = q[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123;</span><br><span class="line">addedge(stk[top], stk[top<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, ll len)</span> </span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = <span class="number">-0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">if</span> (tag[x]) f[x][tp[x]] = ww[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dp(y, x, len);</span><br><span class="line">ll now = max(f[x][<span class="number">0</span>] + f[y][<span class="number">1</span>], f[x][<span class="number">1</span>] + f[y][<span class="number">0</span>]);</span><br><span class="line">ans = max(ans, len + now - <span class="number">2</span> * dep[x]);</span><br><span class="line">f[x][<span class="number">0</span>] = max(f[x][<span class="number">0</span>], f[y][<span class="number">0</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] = max(f[x][<span class="number">1</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">tag[x] = <span class="number">0</span>; head[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll len)</span> </span>&#123;</span><br><span class="line">buildtree();</span><br><span class="line">dp(<span class="number">1</span>, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> p1&#123;</span><br><span class="line"><span class="keyword">int</span> head[NN&lt;&lt;<span class="number">2</span>], pre[NN&lt;&lt;<span class="number">3</span>], to[NN&lt;&lt;<span class="number">3</span>], sz = <span class="number">1</span>, N;</span><br><span class="line">ll val[NN&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, ll&gt; &gt; son[NN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[NN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[NN&lt;&lt;<span class="number">2</span>], ct, mn, sum;</span><br><span class="line">ll dep[NN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">son[x].push_back(make_pair(y, val[i]));</span><br><span class="line">dep[y] = dep[x] + val[i];</span><br><span class="line">dfs1(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)); sz = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k = son[i].size();</span><br><span class="line"><span class="keyword">if</span> (k &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">addedge(i, son[i][j].first, son[i][j].second);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">addedge(i, ++N, <span class="number">0</span>); addedge(i, ++N, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &amp; <span class="number">1</span>) son[N<span class="number">-1</span>].push_back(son[i][j]);</span><br><span class="line"><span class="keyword">else</span> son[N].push_back(son[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findct</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">siz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa || vis[i&gt;&gt;<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">findct(y, x);</span><br><span class="line">siz[x] += siz[y];</span><br><span class="line"><span class="keyword">int</span> now = max(siz[y], sum - siz[y]);</span><br><span class="line"><span class="keyword">if</span> (now &lt; mn) &#123;</span><br><span class="line">mn = now;</span><br><span class="line">ct = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, ll dis, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= n) &#123;</span><br><span class="line">q[++tot] = x;</span><br><span class="line">ww[x] = dep[x] + dis;</span><br><span class="line">tp[x] = o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa || vis[i&gt;&gt;<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x, dis + val[i], o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> _siz)</span> </span>&#123;</span><br><span class="line">ct = <span class="number">0</span>; mn = <span class="number">0x7fffffff</span>; </span><br><span class="line">sum = _siz;</span><br><span class="line">findct(x, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ct) <span class="keyword">return</span>;</span><br><span class="line">vis[ct&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l = to[ct], r = to[ct^<span class="number">1</span>];</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line">dfs(l, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); dfs(r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!tot) <span class="keyword">return</span>;</span><br><span class="line">p2::solve(val[ct]);</span><br><span class="line">divide(l, siz[to[ct]]); divide(r, _siz - siz[to[ct]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); </span><br><span class="line">p1::N = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">read(u); read(v); read(w);</span><br><span class="line">p1::addedge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">read(u); read(v); read(w);</span><br><span class="line">p2::addedge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">p1::dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">p1::rebuild();</span><br><span class="line">p2::init();</span><br><span class="line">p1::divide(<span class="number">1</span>, p1::N);</span><br><span class="line">ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans = max(ans, p1::dep[i] - p2::dep[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定两棵树$T$和$T’$&lt;/p&gt;
&lt;p&gt;求&lt;br&gt;$$\max(\operatorname{depth}(x) + \op
      
    
    </summary>
    
    
    
      <category term="点/边分治" scheme="http://akdream.tk/tags/%E7%82%B9-%E8%BE%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="虚树" scheme="http://akdream.tk/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>维修数列[NOI2005]</title>
    <link href="http://akdream.tk/post/c8d4ab6b.html/"/>
    <id>http://akdream.tk/post/c8d4ab6b.html/</id>
    <published>2020-07-27T14:20:34.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写题解了 来水一篇题解</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请写一个程序，要求维护一个数列，支持以下 6 种操作： </p><p><img src="http://akdream.tk/img/91_1.png" class="lazyload" data-srcset="http://akdream.tk/img/91_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第1行包含两个数$N$和$M(M \leq 20 000)$，$N$表示初始时数列中数的个数，$M$表示要进行的操作数目。</p><p>第2行包含$N$个数字，描述初始时的数列。</p><p>以下$M$行，每行一条命令，格式参见问题描述中的表格。</p><p>任何时刻数列中最多含有$500000$个数，数列中任何一个数字均在$[-1 000, 1 000]$内。</p><p>插入的数字总数不超过$4 000 000$个，输入文件大小不超过20MB。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于输入数据中的GET-SUM和MAX-SUM操作，向输出文件依次打印结果，每个答案（数字）占一行。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一道平衡树维护各种标记以及pushup,pushdown的模板题？</p><p>我这里用的是<del>飞旋</del>非旋Treap，Splay也可以做，但是显然非旋Treap要比较好写</p><p>维护最大子段和的套路就是维护区间最大前缀和以及最大后缀和，pushup时：</p><p>最大前缀和 = max（左儿子最大前缀和，左儿子区间和+当前节点权值+右儿子最大前缀和）<br>最大后缀和 = max（右儿子最大后缀和，右儿子区间和+当前节点权值+左儿子最大后缀和）<br>最大子段和 = max（ max（左儿子最大子段和，右儿子最大子段和），左儿子最大后缀和+当前节点权值+右儿子最大前缀和）</p><p>此题细节特别多：</p><ul><li><p>最大子段不能为空 所以修改时要注意不能让它不含任何元素而子段和等于$0$，尤其是pushup的时候注意</p></li><li><p>最大前缀和以及最大后缀和可以为空，所以最小也是$0$，不会为负</p></li><li><p>覆盖标记的初始值不能设成$0$！因为一次操作可能会要求把一段区间全部赋为$0$，可以把覆盖标记初始值设成inf</p></li><li><p>区间翻转的时候，不光要交换左右儿子，还要交换最大前缀和与最大后缀和！</p></li><li><p>在树的结构即将发生变化时，一定要记得先pushdown！</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 4000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nowtot;</span><br><span class="line"><span class="keyword">int</span> rt, tot, siz[M], val[M], rnd[M], ch[M][<span class="number">2</span>], tag[M], rev[M];</span><br><span class="line"><span class="keyword">int</span> mx[M], sum[M], lmx[M], rmx[M];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">siz[tot] = <span class="number">1</span>; val[tot] = sum[tot] = v; rnd[tot] = rand(); </span><br><span class="line">ch[tot][<span class="number">0</span>] = ch[tot][<span class="number">1</span>] = <span class="number">0</span>; tag[tot] = inf; rev[tot] = <span class="number">0</span>;</span><br><span class="line">lmx[tot] = rmx[tot] = max(<span class="number">0</span>, v); mx[tot] = v;</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">siz[x] = siz[ch[x][<span class="number">0</span>]] + siz[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">lmx[x] = max(lmx[ch[x][<span class="number">0</span>]], sum[ch[x][<span class="number">0</span>]] + val[x] + lmx[ch[x][<span class="number">1</span>]]);</span><br><span class="line">rmx[x] = max(rmx[ch[x][<span class="number">1</span>]], sum[ch[x][<span class="number">1</span>]] + val[x] + rmx[ch[x][<span class="number">0</span>]]);</span><br><span class="line">lmx[x] = max(lmx[x], <span class="number">0</span>); rmx[x] = max(rmx[x], <span class="number">0</span>);</span><br><span class="line">mx[x] = rmx[ch[x][<span class="number">0</span>]] + val[x] + lmx[ch[x][<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) mx[x] = max(mx[x], mx[ch[x][<span class="number">0</span>]]);</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) mx[x] = max(mx[x], mx[ch[x][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">val[x] = v; </span><br><span class="line">sum[x] = siz[x] * v;</span><br><span class="line">lmx[x] = rmx[x] = max(<span class="number">0</span>, siz[x] * v); </span><br><span class="line">mx[x] = max(v, siz[x] * v);</span><br><span class="line">tag[x] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">swap(lmx[x], rmx[x]);</span><br><span class="line">swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tag[x] != inf) &#123;</span><br><span class="line"><span class="keyword">int</span> v = tag[x]; tag[x] = inf;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) change(ch[x][<span class="number">0</span>], v);</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) change(ch[x][<span class="number">1</span>], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) Rev(ch[x][<span class="number">0</span>]); </span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) Rev(ch[x][<span class="number">1</span>]); </span><br><span class="line">rev[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!now) &#123;</span><br><span class="line">x = y = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(now);</span><br><span class="line"><span class="keyword">if</span> (k &gt; siz[ch[now][<span class="number">0</span>]]) &#123;</span><br><span class="line">x = now; split(ch[now][<span class="number">1</span>], k - siz[ch[now][<span class="number">0</span>]] - <span class="number">1</span>, ch[now][<span class="number">1</span>], y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y = now; split(ch[now][<span class="number">0</span>], k, x, ch[now][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">pushup(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">pushdown(x); pushdown(y); </span><br><span class="line"><span class="keyword">if</span> (rnd[x] &lt; rnd[y]) &#123;</span><br><span class="line">ch[x][<span class="number">1</span>] = merge(ch[x][<span class="number">1</span>], y);</span><br><span class="line">pushup(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ch[y][<span class="number">0</span>] = merge(x, ch[y][<span class="number">0</span>]);</span><br><span class="line">pushup(y);</span><br><span class="line"><span class="keyword">return</span> y; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v, x, y; i &lt;= n; i++) &#123;</span><br><span class="line">read(v); x = y = <span class="number">0</span>;</span><br><span class="line">split(rt, i - <span class="number">1</span>, x, y);</span><br><span class="line">rt = merge(merge(x, newnode(v)), y);</span><br><span class="line">&#125;</span><br><span class="line">nowtot = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>, cnt = <span class="number">0</span>, v = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'I'</span>) &#123;</span><br><span class="line">read(pos); read(cnt);</span><br><span class="line">nowtot += cnt;</span><br><span class="line">split(rt, pos, x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">read(v); </span><br><span class="line">x = merge(x, newnode(v));</span><br><span class="line">&#125;</span><br><span class="line">rt = merge(x, y);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'D'</span>) &#123;</span><br><span class="line">read(pos); read(cnt);</span><br><span class="line">nowtot -= cnt;</span><br><span class="line">split(rt, pos - <span class="number">1</span>, x, y);</span><br><span class="line">split(y, cnt, y, z);</span><br><span class="line">rt = merge(x, z);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'R'</span>) &#123;</span><br><span class="line">read(pos); read(cnt);</span><br><span class="line">split(rt, pos - <span class="number">1</span>, x, y);</span><br><span class="line">split(y, cnt, y, z);</span><br><span class="line">Rev(y);</span><br><span class="line">rt = merge(x, merge(y, z));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line">read(pos); read(cnt);</span><br><span class="line">split(rt, pos - <span class="number">1</span>, x, y);</span><br><span class="line">split(y, cnt, y, z);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum[y]);</span><br><span class="line">rt = merge(x, merge(y, z));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>] == <span class="string">'K'</span>) &#123;</span><br><span class="line">read(pos); read(cnt); read(v);</span><br><span class="line">split(rt, pos - <span class="number">1</span>, x, y);</span><br><span class="line">split(y, cnt, y, z);</span><br><span class="line">change(y, v);</span><br><span class="line">rt = merge(x, merge(y, z));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx[rt]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没写题解了 来水一篇题解&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请写一个程序，要求维护一个数列，支持以下 6 种操作： &lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
    
      <category term="平衡树" scheme="http://akdream.tk/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>分零食[JSOI2012]</title>
    <link href="http://akdream.tk/post/dc9b58a7.html/"/>
    <id>http://akdream.tk/post/dc9b58a7.html/</id>
    <published>2020-06-23T10:39:29.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P5075" target="_blank" rel="noopener">题面太长</a><br>有$n$个人，$m$颗糖，要求给前若干个人分糖(把所有糖分完)，如果一个人得到了$x$颗糖，那他的欢乐度就是$Ox^2+Sx+U$，一个分糖方案的总欢乐度是所有分到糖的人的欢乐度的乘积，求所有可行分糖方案的总欢乐度的总和。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先有一个显然的dp方程：</p><p>设$dp[i][j]$表示给前$i$个人分了$j$颗糖，设$f(x)=Ox^2+Sx+U$，<br>则$dp[i][j]=\sum\limits_{k=1}^{j-i+1} dp[i-1][j-k]*f(k)$</p><p>答案即为$\sum\limits_{i=1}^{n} dp[i][m]$</p><p>考虑如何优化这个式子</p><p>如果把$dp[i-1][j-k]*f(k)$看作一个卷积形式的话，我们会发现$dp[i]$这一个数组就是$dp[i-1]$和$f$的卷积</p><p>我们把$f$以及$dp[i]$看作一个多项式，那么有$f=f(1)x+f(2)x^2+f(3)x^3+\dots+f(m)x^m$</p><p>由于$dp[i]=dp[i-1]*f$，所以显然$dp[i]=f^i$(这里的乘方是指$i$次卷积，不是指$i$次方。。。)</p><p>可以使用FFT优化卷积</p><p>但是$n\le 10^8$，这样还是跑不过，还需要进行优化：</p><p>卷积满足交换律，所以可以进行快速幂优化。但是我们要求的答案是$\sum\limits_{i=1}^{n} dp[i][m]$，如果用快速幂的话没法计算答案啊</p><p>所以我们再定义一个多项式$sum[i]=\sum\limits_{j=1}^i dp[i]$，也就是前缀和</p><p>首先要意识到，根据上面的定义$dp[i]=f^i$，那么显然$dp[a+b]=dp[a]*dp[b]$</p><p>然后看一下$sum$是怎么快速幂递推的</p><p>假设现在在计算$sum[x]$和$dp[x]$</p><h4 id="若-x-为偶，"><a href="#若-x-为偶，" class="headerlink" title="若$x$为偶，"></a>若$x$为偶，</h4><p>则$dp[x]=dp[\frac{x}{2}]*dp[\frac{x}{2}]$；</p><p>$sum[x]=sum[\frac{x}{2}]+\sum\limits_{i=x/2+1}^x dp[i]$<br>$=sum[\frac{x}{2}]+dp[\frac{x}{2}]\sum\limits_{i=1}^{x/2} dp[i]$<br>$=sum[\frac{x}{2}]+dp[\frac{x}{2}]*sum[\frac{x}{2}]$</p><h4 id="若-x-为奇"><a href="#若-x-为奇" class="headerlink" title="若$x$为奇"></a>若$x$为奇</h4><p>那就先把$dp[x-1]$和$sum[x-1]$用上面的方法算出来，然后$dp[x]=dp[x-1]*f$，$sum[x]=sum[x-1]+dp[x]$</p><p>最后的答案就是$sum[n][m]$</p><p>时间复杂度$O(m\log m\log n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>, G = <span class="number">3</span>, invg = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> N, m, lim, l, rev[<span class="number">100005</span>], tot;</span><br><span class="line">ll dp[<span class="number">100005</span>], sum[<span class="number">100005</span>], F[<span class="number">100005</span>], tmp[<span class="number">100005</span>], invn, O, S, U, p;</span><br><span class="line">ll aa[<span class="number">100005</span>], bb[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; t; t &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *c, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i]) swap(c[i], c[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> r = mid&lt;&lt;<span class="number">1</span>; </span><br><span class="line">ll wn = fpow(~tp?G:invg, (mod<span class="number">-1</span>)/r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += r) &#123;</span><br><span class="line">ll w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * wn % mod) &#123;</span><br><span class="line">ll x = c[j+k], y = w * c[j+k+mid] % mod;</span><br><span class="line">c[j+k] = (x + y) % mod;</span><br><span class="line">c[j+k+mid] = (x - y + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tp == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">c[i] = c[i] * invn % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x * x % p * O % p + x * S % p + U) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(ll *a, ll *b, ll *c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) aa[i] = a[i], bb[i] = b[i];</span><br><span class="line">NTT(aa, <span class="number">1</span>); NTT(bb, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) aa[i] = aa[i] * bb[i] % mod;</span><br><span class="line">NTT(aa, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) c[i] = aa[i] % p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[i] = sum[i] = F[i];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">solve(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">tot++;</span><br><span class="line">Mul(dp, sum, tmp);</span><br><span class="line">Mul(dp, dp, dp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">sum[i] = (sum[i] + tmp[i]) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">Mul(dp, F, tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">dp[i] = tmp[i];</span><br><span class="line">sum[i] = (sum[i] + tmp[i]) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %lld %d %lld %lld %lld"</span>, &amp;m, &amp;p, &amp;N, &amp;O, &amp;S, &amp;U);</span><br><span class="line">lim = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lim &lt;= m + m) &#123;</span><br><span class="line">lim &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">invn = fpow(lim, mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) F[i] = calc(i);</span><br><span class="line">solve(N);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum[m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5075&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="FFT" scheme="http://akdream.tk/tags/FFT/"/>
    
  </entry>
  
  <entry>
    <title>Problem b[HAOI2011]</title>
    <link href="http://akdream.tk/post/93e29827.html/"/>
    <id>http://akdream.tk/post/93e29827.html/</id>
    <published>2020-06-23T10:37:57.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于给出的$n$个询问，每次求有多少个数对$(x,y)$，满足$a \le x \le b$，$c \le y \le d$，且$\gcd(x,y) = k$，$\gcd(x,y)$函数为$x$和$y$的最大公约数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>莫比乌斯反演</p><p>我们可以用二维前缀和的思想，我们设</p><p>$f(n,m)=\sum\limits_{i=1}^n \sum\limits_{j=1}^m [\gcd(i,j)=k]$，</p><p>那答案应为</p><p>$f(b,d)-f(b,c-1)-f(a-1,d)+f(a-1,c-1)$</p><p>接下来看看$f(n,m)$怎么求：</p><p>$\sum\limits_{i=1}^n \sum\limits_{j=1}^m [\gcd(i,j)=k]$</p><p>$=\sum\limits_{i=1}^{n/k} \sum\limits_{j=1}^{m/k} [\gcd(i,j)=1]$</p><p>使用莫比乌斯反演</p><p>$=\sum\limits_{i=1}^{n/k} \sum\limits_{j=1}^{m/k} \sum\limits_{d|gcd(i,j)}\mu(d)$</p><p>把$d$放到前面枚举，设$i=xd,\ j=yd$</p><p>$=\sum\limits_{d} \mu(d) * \sum\limits_{x=1}^{n/kd} \sum\limits_{y=1}^{m/kd} 1$</p><p>$=\sum\limits_{d} \mu(d) * \lfloor \frac{n}{kd}\rfloor * \lfloor \frac{m}{kd}\rfloor$</p><p>预处理$\mu(d)$的前缀和，使用除法分块即可做到时间复杂度$O(\sqrt{n})$</p><p>总时间复杂度$O(n\sqrt{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, a, b, c, d, k;</span><br><span class="line"><span class="keyword">int</span> pr[<span class="number">50005</span>], mb[<span class="number">50005</span>], sum[<span class="number">50005</span>], tot;</span><br><span class="line"><span class="keyword">bool</span> np[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mb[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">50000</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!np[i]) pr[++tot] = i, mb[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pr[j] &lt;= <span class="number">50000</span>; j++) &#123;</span><br><span class="line">np[i*pr[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">mb[i*pr[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> mb[i*pr[j]] = -mb[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50000</span>; i++) sum[i] = sum[i<span class="number">-1</span>] + mb[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> mm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, n = nn / k, m = mm / k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= min(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(n / (n / l), m / (m / l));</span><br><span class="line">ret += (sum[r] - sum[l<span class="number">-1</span>]) * (n / l) * (m / l); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d"</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(b, d) + solve(a<span class="number">-1</span>, c<span class="number">-1</span>) - solve(b, c<span class="number">-1</span>) - solve(a<span class="number">-1</span>, d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;对于给出的$n$个询问，每次求有多少个数对$(x,y)$，满足$a \le x \le b$，$c \le y \le d$
      
    
    </summary>
    
    
    
      <category term="数论" scheme="http://akdream.tk/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯函数" scheme="http://akdream.tk/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>树[省选联考2020]</title>
    <link href="http://akdream.tk/post/da9385f9.html/"/>
    <id>http://akdream.tk/post/da9385f9.html/</id>
    <published>2020-06-23T10:36:46.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵$n$个结点的有根树$T$，结点从$1$开始编号，根结点为$1$号结点，每个结点有一个正整数权值$v_i$。</p><p>设$x$号结点的子树内（包含$x$自身）的所有结点编号为$c_1,c_2,\dots,c_k$，定义$x$的价值为：</p><p>$val(x)=(v_{c_1}+d(c_1,x)) \oplus (v_{c_2}+d(c_2,x)) \oplus \cdots \oplus (v_{c_k}+d(c_k, x))$</p><p>其中$d(x,y)$表示树上$x$号结点与$y$号结点间唯一简单路径所包含的边数，$d(x,x) = 0$。⊕ 表示异或运算。</p><p>请你求出$\sum\limits_{i=1}^n val(i)$的值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数$n$表示树的大小。</p><p>第二行$n$个正整数表示$v_i$。</p><p>接下来一行$n-1$个正整数，依次表示$2$号结点到$n$号结点，每个结点的父亲编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅一行一个整数表示答案。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很显然的想法是考虑如何让父亲节点利用儿子的$val$信息从而快速计算出父亲的$val$</p><p>考场上首先想的是如何处理这个所有点的点权+1后异或和的变化</p><p>我们按二进制位来考虑</p><p>假设现在有一个数，二进制末三位为$011$，那么给它+1之后变成$100$，相当于它的二进制第1位，第2位，第3位都取反了</p><p>然后很容易发现一个规律，如果一个数字$a \equiv 2^k-1 \mod 2^k$，那么a+1之后第$k+1$位就会取反</p><p>那么我们可以把当前子树内所有点的权值装进$\log n$个桶里，$buc[i][j]$表示当前权值(即点权+当前深度)$\ \equiv i \mod 2^j$的点有多少个</p><p>为了方便，我们设$v_i=c_i+d(i,1)$，即第$v_i$是自己的权值+自己到根的距离，把这个权值放进上面的桶里面</p><p>那么假设我们在计算$val_x$，那么子树中所有点现在的点权应该是$v_i-dis(x,1)$，我们要对于每个$j$，找出有多少个点满足$v_i-dis(x,1)-1 \equiv 2^j - 1\mod 2^j$</p><p>化简一下就是$v_i \equiv dis(x,1) \mod 2^j$</p><p>所以我们对于每个$j$找到$buc[dis(x,1)\bmod 2^j][j]$，那么第$j+1$位实际上要取反这么多次 这个就很好处理了</p><p>整理一下思路：首先把$val_x$赋为所有儿子$val$的异或和，然后对于每个$j$找到子树中的所有点(不包括自己)有多少个点满足$v_i\equiv dis(x,1)\mod 2^j$，然后如果是奇数个就把第$j+1$位取反，否则不变<br>最后把$val_x$异或上$x$的点权</p><p>最后关于怎么维护这个桶，用树上启发式合并啊 </p><p>时间复杂度$O(n\log^2 n)$，一个是启发式合并的log，另一个是枚举二进制位的log</p><p>不过常数很小，洛谷上最慢点跑了1.3s，<del>相信少爷机上更快</del></p><p>代码体感是挺好写的</p><h4 id="考场上桶开小了导致100pts-gt-30pts-心态爆炸"><a href="#考场上桶开小了导致100pts-gt-30pts-心态爆炸" class="headerlink" title="考场上桶开小了导致100pts-&gt;30pts 心态爆炸"></a>考场上桶开小了导致100pts-&gt;30pts 心态爆炸</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 530005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">int</span> d[N], siz[N], son[N], fa[N];</span><br><span class="line"><span class="keyword">int</span> buc[N&lt;&lt;<span class="number">1</span>][<span class="number">22</span>], ans[N]; <span class="comment">//开两倍大！！！</span></span><br><span class="line"><span class="keyword">int</span> two[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">siz[x] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">fa[y] = x; d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">dfs1(y);</span><br><span class="line">siz[x] += siz[y];</span><br><span class="line"><span class="keyword">if</span> (!son[x] || siz[son[x]] &lt; siz[y]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">buc[a[x]&amp;two[i]][i] += tp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (to[i] != fa[x]) calc(to[i], tp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (to[i] != fa[x]) ans[x] ^= ans[to[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">ans[x] ^= ((buc[d[x]&amp;two[i]][i] &amp; <span class="number">1</span>) &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line">ans[x] ^= (a[x] - d[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (to[i] == fa[x] || to[i] == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(to[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[x]) dfs(son[x], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (to[i] == fa[x] || to[i] == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">calc(to[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getans(x);</span><br><span class="line"><span class="keyword">if</span> (cl) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (to[i] == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">calc(to[i], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">buc[a[x]&amp;two[i]][i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">read(x); addedge(i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) two[i] = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>;</span><br><span class="line">dfs1(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += d[i];</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">Ans += ans[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一棵$n$个结点的有根树$T$，结点从$1$开始编号，根结点为$1$号结点，每个结点有一个正整数权值$v_i$。&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="树上启发式合并" scheme="http://akdream.tk/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>移动金币「SDOI2019」</title>
    <link href="http://akdream.tk/post/fda2729a.html/"/>
    <id>http://akdream.tk/post/fda2729a.html/</id>
    <published>2020-06-14T13:28:06.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个$1\times n$的棋盘上最初摆放有$m$枚金币。其中每一枚金币占据了一个独立的格子，任意一个格子内最多只有一枚金币。</p><p>Alice 和 Bob 将要进行如下的一场游戏。二人轮流操作，且 Alice 先行。当轮到一个玩家的时候，他可以选择一枚金币，并将其向左移动任意多格，且至少移动一格。金币不能被移出棋盘，也不能越过其它金币。</p><p>如果轮到一个玩家的时候他已经无法做出任何有效操作了（显然这个时候$m$枚金币恰好落在最左侧的$m$个格子中），则被判定为输家。已经知道 Alice 和 Bob 都是极致聪明的人，他们在任何局面下总能做出最优的操作。那么有多少初始状态能保证 Alice 必胜呢？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅有一行并包含两个正整数，依次为$n$和$m$，如题目所述。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示有多少初始状态可以保证 Alice 作为先手方能先手必胜。由于答案可能很大，请输出关于$10^9+9$取模后的值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先不难发现，把金币向左移改成向右移是没有区别的</p><p>然后把题目看作是$m$枚金币把$n-m$个空位分成了$m+1$个部分(编号从$0\sim m$)，那么每次把第$i$枚硬币向右移动就相当于是把若干个空位从第$i$部分移动到了第$i-1$部分</p><p>然后这显然是一个阶梯$nim$模型，即每次可以选择一个$i\neq 0$，将若干个物品从第$i$堆移到第$i-1$堆</p><p>我们其实不用管$m$枚金币具体在哪些位置，所以我们现在需要解决的问题是：将$n-m$个物品分成编号从$0\sim m$的$m+1$堆，要求所有奇数堆的异或和不为$0$，有多少种方案？</p><p>容斥一下，可以用总方案数减去奇数堆异或和为$0$的方案数</p><p>设$dp[i][j]$表示所有奇数堆的二进制前$i$位的异或和为0，共用了$j$个物品的方案数</p><p>在二进制的每一位上，为了异或和为$0$，必须要放偶数个$1$</p><p>假设$m+1$堆中有$a$个奇数堆，$b$个偶数堆，</p><p>那么转移方程为：$dp[i][j]=\sum\limits_{k%2=0} dp[i-1][j-k*2^{i-1}] * C(a, k)$</p><p>表示在第$i$位上放$k$个1，所以在$a$个奇数位上任选$k$个放上1</p><p>然后填好所有奇数堆后，剩下的没有用到的物品就可以用插板法随意地分到偶数堆里</p><p>时间复杂度$O(nm\log n)$，但是实际上跑得很快</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000009</span>;</span><br><span class="line">ll fac[<span class="number">150005</span>], invf[<span class="number">150005</span>], dp[<span class="number">21</span>][<span class="number">150005</span>], ans; <span class="comment">// 放了二进制前i位 用了j个物品 </span></span><br><span class="line"><span class="keyword">int</span> n, m, l; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; t; t &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll _n, ll _m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[_n] * invf[_m] % mod * invf[_n - _m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = invf[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">150000</span>; i++) &#123;</span><br><span class="line">fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line">invf[<span class="number">150000</span>] = fpow(fac[<span class="number">150000</span>], mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">149999</span>; i; i--) &#123;</span><br><span class="line">invf[i] = invf[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line">n -= m;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">1</span>; <span class="keyword">while</span> (tmp &lt;= n) &#123; l++; tmp &lt;&lt;= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> a = (m + <span class="number">1</span>) / <span class="number">2</span>, b = (m + <span class="number">2</span>) / <span class="number">2</span>; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= a &amp;&amp; k * (<span class="number">1</span> &lt;&lt; i) + j &lt;= n; k += <span class="number">2</span>) &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+k*(<span class="number">1</span>&lt;&lt;i)] = (dp[i+<span class="number">1</span>][j+k*(<span class="number">1</span>&lt;&lt;i)] + dp[i][j] * C(a, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans = (ans + dp[l][i] * C((n-i) + b - <span class="number">1</span>, b - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">ans = (C(n+m, m) - ans + mod) % mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一个$1\times n$的棋盘上最初摆放有$m$枚金币。其中每一枚金币占据了一个独立的格子，任意一个格子内最多只有一枚金币
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位DP" scheme="http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
      <category term="博弈论" scheme="http://akdream.tk/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
</feed>
