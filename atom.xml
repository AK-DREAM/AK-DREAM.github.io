<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AK-dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://akdream.tk/"/>
  <updated>2020-12-11T13:50:22.420Z</updated>
  <id>http://akdream.tk/</id>
  
  <author>
    <name>AK-dream</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>征途[SDOI2016]</title>
    <link href="http://akdream.tk/post/d391bdf.html/"/>
    <id>http://akdream.tk/post/d391bdf.html/</id>
    <published>2020-12-11T13:48:10.000Z</published>
    <updated>2020-12-11T13:50:22.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Pine 开始了从 $S$ 地到 $T$ 地的征途。</p><p>从 $S$ 地到 $T$ 地的路可以划分成 $h$ 段，相邻两段路的分界点设有休息站。<br>Pine 计划用 $m$ 天到达 $T$ 地。除第 $n$ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。<br>Pine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。</p><p>帮助 Pine 求出最小方差是多少。</p><p>设方差是 $v$ ，可以证明，$v<em>m^2$ 是一个整数。为了避免精度误差，输出结果时输出 $v</em>m^2$。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个数 $n$ 、$m$ 。<br>第二行 $n$ 个数，表示 $n$ 段路的长度。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>CCF不考DP了(悲)</del></p><p>假设有一个序列 $a<em>1\sim a_n$ ，平均数是 $v$ ，那么它的方差就是 $\dfrac{\sum\limits</em>{i=1}^{n}(a_i)^2}{n}-v^2$</p><p>所以原问题就变成：将 $n$ 个数分为 $m$ 段，假设第 $i$ 段内的所有数之和为 $b<em>i$ ，求 $\sum\limits</em>{i=1}^{m} (b_i)^2$ 的最小值</p><p>设 $f_{i,j}$ 表示将前 $j$ 个数分成 $i$ 段的最小平方和</p><p>容易得到转移方程： $f<em>{i,j} = \min\limits</em>{0\le k&lt;j} (f_{i-1,k} + (S_j-S_k)^2)$ ， $S$ 表示前缀和</p><p>变换一下得到 $f<em>{i-1,k}+(S_k)^2=2<em>S_j</em>S_k+(f</em>{i,j}-(S_j)^2)$ </p><p>这样就可以进行斜率优化，维护 $f_{i-1}$ 的凸壳来转移出 $f_i$</p><p>由于 $S$ 数组单调递增，所以直接用单调队列维护下凸壳即可</p><p>时间复杂度 $O(nm)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, head, tail, q[N];</span><br><span class="line">ll a[N], f[<span class="number">2</span>][N], x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x[p] == x[q]) <span class="keyword">return</span> <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1.0</span> * (y[p] - y[q]) / (x[p] - x[q]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]); a[i] += a[i<span class="number">-1</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> o = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">o = i &amp; <span class="number">1</span>;</span><br><span class="line">head = <span class="number">1</span>; tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[tail<span class="number">-1</span>], q[tail]) &gt; slope(q[tail], j)) tail--;</span><br><span class="line">q[++tail] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[head], q[head+<span class="number">1</span>]) &lt; (<span class="keyword">double</span>)a[j]) head++;</span><br><span class="line"><span class="keyword">int</span> k = q[head];</span><br><span class="line">f[o][j] = f[!o][k] + (a[j]-a[k]) * (a[j]-a[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">f[!o][j] = <span class="number">0</span>;</span><br><span class="line">x[j] = <span class="number">2</span> * a[j]; y[j] = f[o][j] + a[j] * a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[m&amp;<span class="number">1</span>][n] * m - a[n] * a[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Pine 开始了从 $S$ 地到 $T$ 地的征途。&lt;/p&gt;
&lt;p&gt;从 $S$ 地到 $T$ 地的路可以划分成 $h$ 段，
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="斜率优化" scheme="http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>区间[NOI2016]</title>
    <link href="http://akdream.tk/post/ba8b5f94.html/"/>
    <id>http://akdream.tk/post/ba8b5f94.html/</id>
    <published>2020-12-04T11:31:41.000Z</published>
    <updated>2020-12-04T11:33:44.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数轴上有<script type="math/tex">n</script>个闭区间从<script type="math/tex">1</script>至<script type="math/tex">n</script>编号，第<script type="math/tex">i</script>个闭区间为<script type="math/tex">[l_i,r_i]</script></p><p>现在要从中选出<script type="math/tex">m</script>个区间，使得这<script type="math/tex">m</script>个区间共同包含至少一个位置。换句话说，就是使得存在一个<script type="math/tex">x</script>，使得对于每一个被选中的区间<script type="math/tex">[l_i,r_i]</script></p><p>对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间<script type="math/tex">[l_i,r_i]</script>的长度定义为<script type="math/tex">(r_i-l_i)</script>即等于它的右端点的值减去左端点的值。</p><p>求所有合法方案中最小的花费。如果不存在合法的方案，输出<script type="math/tex">−1</script>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数，分别代表<script type="math/tex">n</script>和<script type="math/tex">m</script>。</p><p>第<script type="math/tex">2</script>到第<script type="math/tex">(n + 1)</script>行，每行两个整数表示一个区间，第<script type="math/tex">(i + 1)</script>行的整数<script type="math/tex">l_i, r_i</script>分别代表第<script type="math/tex">i</script>个区间的左右端点。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数表示答案。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将区间按长度从小到大排序，记为<script type="math/tex">p_1,p_2,\cdots p_n</script></p><p>假设最后选的区间中长度最短和最长的分别是<script type="math/tex">p_l, p_r</script>，那么答案就是<script type="math/tex">p_r</script>的长度减<script type="math/tex">p_l</script>的长度，在<script type="math/tex">p_{l+1}\sim p_{r-1}</script>中选哪些并不会给答案造成影响</p><p>判定一个答案是否合法的方法：假设现在有一个长度为1e9的序列，每个位置的值都是<script type="math/tex">0</script>，如果我们对于<script type="math/tex">p_l \sim p_r</script>的每个区间，都把这个区间中的每个位置+1，那么操作完后如果有某个位置的值大于<script type="math/tex">m</script>，那么就说明这个位置被<script type="math/tex">p_l \sim p_r</script>中的至少<script type="math/tex">m</script>个区间覆盖了，也就是说存在一种合法方案只选择了<script type="math/tex">m</script>个<script type="math/tex">p_l\sim p_r</script>中的区间，就可以用 (<script type="math/tex">p_r</script>的长度减<script type="math/tex">p_l</script>的长度) 来更新答案</p><p>如果选择的最短区间为<script type="math/tex">p_l</script>时，使得代价最小的方案中选择的的最长区间是<script type="math/tex">p_r</script>，那么选择的最短区间固定为<script type="math/tex">p_{l+1}</script>时，此时的最优方案选择的最长区间一定比<script type="math/tex">p_r</script>长</p><p>证明：假设最短区间固定为<script type="math/tex">p_{l+1}</script>时，此时的最优方案选择的最长区间是<script type="math/tex">p_k</script>，且<script type="math/tex">k < r</script>，那么按照上面那个判合法性的方法，选择<script type="math/tex">p_l\sim p_k</script>也一定是合法的，矛盾</p><p>所以可以使用双指针的方法，每次固定左指针(即最短区间)，然后移动右指针找到第一个满足条件的最长区间，然后更新答案</p><p>上面的判定合法的方法需要区间加，查询全局最大值，用线段树维护即可</p><p>为方便线段树维护，可以先给区间端点进行离散化</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, len[N], srt[N], mx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intv</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(intv x, intv y)</span> </span>&#123; <span class="keyword">return</span> x.r-x.l &lt; y.r-y.l; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fCuCcFk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) srt[++mx] = p[i].l, srt[++mx] = p[i].r;</span><br><span class="line">sort(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>);</span><br><span class="line">mx = unique(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>) - srt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">len[i] = p[i].r - p[i].l + <span class="number">1</span>;</span><br><span class="line">p[i].l = lower_bound(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>, p[i].l) - srt;</span><br><span class="line">p[i].r = lower_bound(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>, p[i].r) - srt; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> mx, tag;</span><br><span class="line">&#125; tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">tr[ind].mx = tr[ind].tag = <span class="number">0</span>; <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(ind&lt;&lt;<span class="number">1</span>, l, mid); build(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[ind].tag) <span class="keyword">return</span>; <span class="keyword">int</span> v = tr[ind].tag; tr[ind].tag = <span class="number">0</span>;</span><br><span class="line">tr[ind&lt;&lt;<span class="number">1</span>].mx += v; tr[ind&lt;&lt;<span class="number">1</span>].tag += v;</span><br><span class="line">tr[ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx += v; tr[ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">tr[ind].mx += v; tr[ind].tag += v; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(ind); <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update(ind&lt;&lt;<span class="number">1</span>, l, mid, x, y, v);</span><br><span class="line"><span class="keyword">if</span> (mid &lt; y) update(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, v);</span><br><span class="line">tr[ind].mx = max(tr[ind&lt;&lt;<span class="number">1</span>].mx, tr[ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(p[i].l); read(p[i].r);</span><br><span class="line">&#125;</span><br><span class="line">sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">fCuCcFk(); <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, mx);</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, mx, p[<span class="number">1</span>].l, p[<span class="number">1</span>].r, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; n &amp;&amp; tr[<span class="number">1</span>].mx &lt; m) &#123;</span><br><span class="line">j++;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, mx, p[j].l, p[j].r, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">1</span>].mx &gt;= m) ans = min(ans, len[j] - len[i]);</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, mx, p[i].l, p[i].r, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在数轴上有&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个闭区间从&lt;script type=&quot;math
      
    
    </summary>
    
    
    
      <category term="线段树" scheme="http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>文件路径[BOI2015]</title>
    <link href="http://akdream.tk/post/832a20d9.html/"/>
    <id>http://akdream.tk/post/832a20d9.html/</id>
    <published>2020-12-04T11:27:34.000Z</published>
    <updated>2020-12-04T11:33:44.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P6843" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P6843</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目实际在求这样一个东西：给定一棵树和边权，你可以在树中加上一条长为<script type="math/tex">S</script>的有向边</p><p>对于每个叶子节点问：是否能构造出一条从根节点出发以该节点为终点的长为<script type="math/tex">K</script>的路径</p><p>设有一个叶子节点<script type="math/tex">x</script></p><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>根到<script type="math/tex">x</script>的路径长等于`$K$</p><p>那显然答案就是 <code>Yes</code></p><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p>走了一次附加的有向边使得路径长为`$K$</p><p>考虑这条有向边的终点在哪里：由于走过这条有向边之后还要从它的终点走到<script type="math/tex">x$，所以有向边的终点一定要是`$x</script>的一个祖先</p><p>记点<script type="math/tex">p</script>的深度是<script type="math/tex">d_p$，那么假设走了一条`$p\rightarrow q</script>的有向边，总长度就是`$d_p+S+(d_x-d_q)$</p><p>其中，$p$<code>是树上的任意一个非叶子节点，$q$</code>必须是<script type="math/tex">x</script>的祖先</p><p>要判断是否有<script type="math/tex">p,q</script>满足<script type="math/tex">d_p+S+(d_x-d_q)=K</script>，可以考虑枚举<script type="math/tex">q</script>，这样就确定了<script type="math/tex">d_x-d_q</script>，预处理出<script type="math/tex">d_p+S</script>可以取哪些值(存在一个 <code>bool</code> 数组里)，如果存在某个<script type="math/tex">p</script>使得<script type="math/tex">d_p+S=K-(d_x-d_q)</script>那么<script type="math/tex">x</script>的答案就是 <code>Yes</code></p><p>一个例子</p><p><img src="https://akdream.tk/img/113_1.png" class="lazyload" data-srcset="https://akdream.tk/img/113_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.png"></p><h4 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h4><p>当然，可能可以走很多次附加的有向边(在一个环上一直绕)</p><p>如果一条有向边可以走很多次，那么必须满足它的终点是起点的祖先</p><p>又因为终点要是<script type="math/tex">x</script>的祖先，所以现在需要找到这样一条路径<script type="math/tex">p\rightarrow q</script>：</p><p>满足<script type="math/tex">d_x+t*(d_p-d_q+S)=K</script>(<script type="math/tex">t</script>为一个正整数)</p><p>其中<script type="math/tex">q</script>是<script type="math/tex">x</script>的祖先，<script type="math/tex">p</script>是<script type="math/tex">q</script>子树中一个非叶子节点</p><p>在dfs时，每到一个非叶子节点就再把以它为根的子树遍历一遍，把所有合法的<script type="math/tex">d_p-d_q+S</script>存在 <code>bool</code> 数组里，并在回溯时清除贡献</p><p>枚举<script type="math/tex">K-d_x</script>的所有约数，判断是否有满足条件的<script type="math/tex">d_p-d_q+S</script>即可</p><p><img src="https://akdream.tk/img/113_2.png" class="lazyload" data-srcset="https://akdream.tk/img/113_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>时间复杂度<script type="math/tex">O((n+m)^2+m\sqrt{K})</script></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, ff = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ff = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ccf, K, S, a[N], d[N];</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">int</span> ok[<span class="number">1000005</span>], ok2[<span class="number">1000005</span>], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x]+S &lt;= <span class="number">1000000</span> &amp;&amp; x &lt;= ccf) ok[d[x]+S]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">d[y] = d[x] + a[y];</span><br><span class="line">dfs1(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> rt, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; ccf) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> now = d[x] - d[rt] + S;</span><br><span class="line"><span class="keyword">if</span> (now &lt;= <span class="number">1000000</span>) ok2[now] += v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y != fa) dfs3(y, x, rt, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x] == K) &#123;</span><br><span class="line">ans[x] = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = stk[i];</span><br><span class="line"><span class="keyword">int</span> v = d[x] - d[y];</span><br><span class="line"><span class="keyword">if</span> (v &lt;= K &amp;&amp; ok[K-v]) ans[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[x] &lt; K) &#123;</span><br><span class="line"><span class="keyword">int</span> v = K - d[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= v; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (v % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ok2[i] || ok2[v/i]) ans[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; ccf) &#123;</span><br><span class="line">solve(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">stk[++top] = x;</span><br><span class="line">dfs3(x, fa, x, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y != fa) dfs2(y, x);</span><br><span class="line">&#125;</span><br><span class="line">dfs3(x, fa, x, <span class="number">-1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(ccf); read(K); read(S); S++;</span><br><span class="line">swap(ccf, n); n += ccf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p; i &lt;= n; i++) &#123;</span><br><span class="line">read(p); read(a[i]); a[i]++;</span><br><span class="line">addedge(p, i);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ccf + <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">puts</span>(ans[i]?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6843&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>仙人掌[ZJOI2017]</title>
    <link href="http://akdream.tk/post/75f14cc2.html/"/>
    <id>http://akdream.tk/post/75f14cc2.html/</id>
    <published>2020-11-29T14:18:56.000Z</published>
    <updated>2020-11-29T14:31:31.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P3687" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3687</a></p><p><del>题面里咋还有张图啊，就不放这了</del></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，如果原图不是仙人掌，显然答案为<script type="math/tex">0</script></p><p>如果原图是一棵树，那么我们可以选择若干条边不相交的路径，如果某条路径长度大于一，就将路径的两个端点间加一条边，那么这样构造出来的图一定是一个仙人掌</p><p>所以原问题实际在问有多少种方案用若干条边不相交的路径覆盖原图</p><p>设<script type="math/tex">f[x]</script>表示考虑<script type="math/tex">x</script>的子树内和<script type="math/tex">x</script>到父亲的那条边，有多少种方案把这些边划分成若干条路径</p><p>假设<script type="math/tex">x</script>有<script type="math/tex">k</script>个儿子，那么如果<script type="math/tex">x</script>不为根，就有<script type="math/tex">k+1</script>条从<script type="math/tex">x</script>连出的边，这些边可以两两配对连接形成穿过<script type="math/tex">x</script>的路径，也可以不配对</p><p>设<script type="math/tex">p_i</script>表示将<script type="math/tex">i</script>条边两两配对(或不配对)有多少种方案，考虑最后一条边是否和另一条边配对，易得递推式：<script type="math/tex">p_i=p_{i-1}+(i-1)*p_{i-2}</script></p><p>那么对于树边，有<script type="math/tex">f[x]=(\prod\limits_{y\in son(x)} f[y]) * p_{k+1}</script>(如果<script type="math/tex">x</script>是根那么最后乘的应该是<script type="math/tex">p_k</script>)</p><p>如果原图不是树而是仙人掌呢？</p><p>考虑仙人掌上的环，从上面那个”路径覆盖”的角度思考，发现环的要求就是环上的边不能被路径覆盖，而树边必须被覆盖</p><p>所以直接把所有环上的边删掉得到一个森林，把每棵树的根的答案乘在一起就是最终答案了</p><p>当然这样做有点麻烦，维护一个<script type="math/tex">g[x]</script>表示只考虑<script type="math/tex">x</script>的子树内的边 (<script type="math/tex">x</script>到父亲的边可能是环边)，有多少种方案把这些边划分成若干条路径</p><p>然后在碰到环时特殊处理一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, ff = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ff = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> ttt, n, m;</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], stk[N], top, c[N], tot, tme;</span><br><span class="line">ll f[N], g[N], p[N];</span><br><span class="line"><span class="keyword">bool</span> tmp[N], flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) head[i] = <span class="number">0</span>; sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dfn[i] = low[i] = <span class="number">0</span>, f[i] = <span class="number">0</span>;</span><br><span class="line">    tme = top = <span class="number">0</span>; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是仙人掌</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) tmp[c[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = c[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[x]; j; j = pre[j]) <span class="keyword">if</span> (tmp[to[j]]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != tot * <span class="number">2</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) tmp[c[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//维护DP值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) f[X] = f[X] * g[c[i]] % mod; <span class="comment">//c[1]~c[tot-1]为环上除x之外的其它点</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tme; stk[++top] = x;</span><br><span class="line">    f[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x] = min(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] == low[y]) &#123;</span><br><span class="line">                <span class="keyword">int</span> z = <span class="number">0</span>; tot = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    z = stk[top--];</span><br><span class="line">                    c[++tot] = z;</span><br><span class="line">                &#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">                c[++tot] = x;</span><br><span class="line">                <span class="keyword">if</span> (tot &gt; <span class="number">2</span>) solve(x); <span class="comment">//找到环</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    f[x] = f[x] * f[y] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    g[x] = f[x] * p[cnt] % mod;</span><br><span class="line">    f[x] = f[x] * p[cnt+(x!=<span class="number">1</span>)] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(ttt);</span><br><span class="line">    p[<span class="number">0</span>] = p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">500000</span>; i++) p[i] = (p[i<span class="number">-1</span>] + p[i<span class="number">-2</span>] * (i<span class="number">-1</span>) % mod) % mod;</span><br><span class="line">    <span class="keyword">while</span> (ttt--) &#123;</span><br><span class="line">        read(n); read(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">            read(u); read(v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[<span class="number">1</span>]);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3687&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="树形DP" scheme="http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>寻找车位[Code+#3]</title>
    <link href="http://akdream.tk/post/e3b2cbf5.html/"/>
    <id>http://akdream.tk/post/e3b2cbf5.html/</id>
    <published>2020-11-28T14:10:40.000Z</published>
    <updated>2020-11-28T14:13:28.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>access_globe 有一个巨大的停车场，这个停车场有<script type="math/tex">N</script>行，每行有<script type="math/tex">M</script>个车位。为了美观，access_globe 在建立这个停车场时，规定这个停车场必须是长条形的，即<script type="math/tex">N\ge M</script>。每个车位都是一个正方形的区域。</p><p>最近，access_globe 正在为抽不到 Missing Poster 而苦恼，因此他请你帮他维护这个停车场。你需要支持两个事件：</p><ul><li>一辆车停到某一个车位中，或一辆车从某个车位开走</li><li>查询一个矩形区域内最大的只包含空车位的正方形区域</li></ul><p>如果你能帮 access_globe 高效地解决这个问题，access_globe 一定会好好奖励你的。</p><script type="math/tex; mode=display">N \times M \le 4*10^6,Q\le 2000</script><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>线段树神题</p><p>对<script type="math/tex">N</script>这一维开一棵线段树，然后线段树上的每个节点维护3个数组：<code>lm[M]</code>, <code>rm[M]</code>, <code>val[M]</code></p><p>假设线段树的某个节点表示的是<script type="math/tex">[l,r]</script>这段区间 (<script type="math/tex">1\le l\le r\le N</script>) ，那么这个节点的 <code>lm[i]</code> 表示第<script type="math/tex">i</script>列中，从第<script type="math/tex">l</script>个车位开始往后数有多少个连续的<script type="math/tex">1</script>，<code>rm[i]</code> 表示从第<script type="math/tex">r</script>个车位往前数有多少个连续的`$1$</p><p>这个节点的 <code>val[i]</code> 表示如果以第<script type="math/tex">i</script>列作为正方形的右边界，且正方形的上下边界在<script type="math/tex">[l,r]</script>内 (这里的<script type="math/tex">l,r</script>实际上是竖着的一段区间) ，全1的正方形的边长最大是多少</p><p><code>lm[M]</code> 和 <code>rm[M]</code> 都很容易通过左右儿子的值求出来，如何求出 <code>val[M]</code> ?</p><p>假设<script type="math/tex">mid=\dfrac{l+r}{2}</script>，先考虑这个正方形的上下边界都在<script type="math/tex">[l,mid]</script>或者都在`$[mid+1,r]$</p><p>显然此时 <code>val[i]</code> 等于左右儿子的 <code>val[i]</code> 的较大值</p><p>如果正方形跨过了<script type="math/tex">mid</script>呢?</p><p>假设我们现在已经知道了正方形的上下边界在<script type="math/tex">[l,r]</script>内，如果正方形的右边界在<script type="math/tex">i</script>，左边界在<script type="math/tex">j</script>(即边长为<script type="math/tex">i-j+1</script>) ，如何判断是否存在合法的正方形？</p><p><img src="https://akdream.tk/img/111_1.png" class="lazyload" data-srcset="https://akdream.tk/img/111_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>如图 我们对于<script type="math/tex">[j,i]</script>中的每一列，找到从第<script type="math/tex">mid</script>行开始有多少个向上延申的连续的<script type="math/tex">1</script>(蓝线)，同理找到向下延申的，然后分别找到向上和向下最少的 (绿线) ， 记为<script type="math/tex">a,b</script>，如果<script type="math/tex">i-j+1\le a+b</script>，就表示一定存在合法的正方形</p><p>容易发现如果以<script type="math/tex">i</script>为右边界可以构成的最大全1正方形的左边界在<script type="math/tex">j</script>，那么以<script type="math/tex">i+1</script>为右边界可以构成的最大全1正方形的左边界不可能小于<script type="math/tex">j</script></p><p>所以这个每次查询区间<script type="math/tex">[j,i]</script>的最小值可以使用单调队列来维护，枚举右端点<script type="math/tex">i</script>并且维护另外一个指针<script type="math/tex">j</script>，如果此时<script type="math/tex">i-j+1</script>大于上下两个最小值之和，那就说明不满足条件，<script type="math/tex">j</script>继续右移，找到第一个满足条件的<script type="math/tex">j</script>，那么<script type="math/tex">[l,r]</script>这个线段树节点的 <code>val[i]</code> 就等于<script type="math/tex">j</script></p><p>这样就通过合并左右儿子两个区间算出了当前节点的值了</p><p>注意这样 <code>pushup</code> 一次的复杂度是<script type="math/tex">O(m)</script>的，所以进行一次修改或查询</p><p>那么怎么查询答案呢？</p><p>假设询问是<script type="math/tex">x1,y1,x2,y2</script>，将<script type="math/tex">[x1,x2]</script>在线段树上分为<script type="math/tex">\log N</script>个区间，然后在线段树上合并这些区间即可</p><p>一种比较聪明的做法是用一个没有用的节点暂时储存一下这<script type="math/tex">\log N</script>个区间合并得到的答案，最后只需要找出这个临时节点 <code>val[y1]</code> 到 <code>val[y2]</code> 之间的最大值即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Q;</span><br><span class="line"><span class="keyword">int</span> len[N&lt;&lt;<span class="number">2</span>], q1[N], q2[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A[N];</span><br><span class="line"><span class="keyword">int</span> lm[N&lt;&lt;<span class="number">2</span>], rm[N&lt;&lt;<span class="number">2</span>], val[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">o</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x*m+y; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1 = <span class="number">1</span>, h2 = <span class="number">1</span>, t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span>; r &lt;= m; r++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; rm[o(ls,q1[t1])] &gt; rm[o(ls,r)]) t1--;</span><br><span class="line">        q1[++t1] = r;</span><br><span class="line">        <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; lm[o(rs,q2[t2])] &gt; lm[o(rs,r)]) t2--;</span><br><span class="line">        q2[++t2] = r;</span><br><span class="line">        <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; rm[o(ls,q1[h1])] + lm[o(rs,q2[h2])] &lt; r-l+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1[h1] == l) h1++;</span><br><span class="line">            <span class="keyword">if</span> (q2[h2] == l) h2++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        val[o(ind,r)] = max(max(val[o(ls,r)], val[o(rs,r)]), r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) lm[o(ind,i)] = lm[o(ls,i)] + (lm[o(ls,i)]==len[ls]?lm[o(rs,i)]:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) rm[o(ind,i)] = rm[o(rs,i)] + (rm[o(rs,i)]==len[rs]?rm[o(ls,i)]:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    len[ind] = r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) lm[o(ind,i)] = rm[o(ind,i)] = val[o(ind,i)] = A[l][i];</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ind&lt;&lt;<span class="number">1</span>, l, mid); build(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    merge(ind, ind&lt;&lt;<span class="number">1</span>, ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        lm[o(ind,y)] = rm[o(ind,y)] = val[o(ind,y)] = v;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) update(ind&lt;&lt;<span class="number">1</span>, l, mid, x, y, v);</span><br><span class="line">    <span class="keyword">else</span> update(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, v);</span><br><span class="line">    merge(ind, ind&lt;&lt;<span class="number">1</span>, ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        merge(<span class="number">0</span>, <span class="number">0</span>, ind); <span class="comment">//用0号点暂时储存答案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) query(ind&lt;&lt;<span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) query(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n); read(m); read(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i].resize(m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        read(A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tp, x, y, a, b; i &lt;= Q; i++) &#123;</span><br><span class="line">        read(tp);</span><br><span class="line">        <span class="keyword">if</span> (tp == <span class="number">0</span>) &#123;</span><br><span class="line">            read(x); read(y);</span><br><span class="line">            <span class="keyword">if</span> (A[x][y]) update(<span class="number">1</span>, <span class="number">1</span>, n, x, y, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> update(<span class="number">1</span>, <span class="number">1</span>, n, x, y, <span class="number">1</span>);</span><br><span class="line">            A[x][y] = <span class="number">1</span> - A[x][y];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(x); read(y); read(a); read(b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                lm[o(<span class="number">0</span>,j)] = rm[o(<span class="number">0</span>,j)] = val[o(<span class="number">0</span>,j)] = <span class="number">0</span>; <span class="comment">//用0号点暂时储存答案</span></span><br><span class="line">            &#125;</span><br><span class="line">            query(<span class="number">1</span>, <span class="number">1</span>, n, x, a);</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= b; j++) &#123;</span><br><span class="line">                ans = max(ans, min(j-y+<span class="number">1</span>, val[o(<span class="number">0</span>, j)]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;access_globe 有一个巨大的停车场，这个停车场有&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script
      
    
    </summary>
    
    
    
      <category term="线段树" scheme="http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>快餐店[NOI2013]</title>
    <link href="http://akdream.tk/post/500a1398.html/"/>
    <id>http://akdream.tk/post/500a1398.html/</id>
    <published>2020-11-28T14:06:43.000Z</published>
    <updated>2020-11-28T14:10:02.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。</p><p>快餐店的顾客分布在城市 C 的<script type="math/tex">N</script>个建筑中，这<script type="math/tex">N</script>个建筑通过恰好<script type="math/tex">N</script>条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。</p><p>现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑一棵树上答案是怎样的：答案应该是树直径的<script type="math/tex">\dfrac{1}{2}</script>，即快餐店取在直径一半处，证明如下：</p><p>如果快餐店不在直径的中点处，而是在某点<script type="math/tex">X</script>，假设直径是<script type="math/tex">A\rightarrow B</script>，长度为<script type="math/tex">d</script> ，那么树上离<script type="math/tex">X</script>最远的点要么是<script type="math/tex">A</script>要么是<script type="math/tex">B</script>，只有<script type="math/tex">\operatorname{dis}(A,X)<\dfrac{d}{2}</script>且<script type="math/tex">\operatorname{dis}(B,X)<\dfrac{d}{2}</script>时<script type="math/tex">X</script>才更优，两式相加得<script type="math/tex">\operatorname{dis}(A,X)+\operatorname{dis}(B,X)<\operatorname{dis}(A,B)</script>，显然这是不可能的</p><p>那么如果是基环树要怎么做呢？</p><p>考虑断掉基环树环上的某条边，使其变成一棵树，求出这棵树的直径长为<script type="math/tex">d</script>，则表示有一种取址方案使得答案为`$\dfrac{d}{2}$</p><p>所以最终答案就是枚举环上断哪条边求得的所有<script type="math/tex">\dfrac{d}{2}</script>的最小值</p><p>那么现在需要快速算出断某条边后树的直径</p><p>先找出环上的所有点，按顺序给每个点标号<script type="math/tex">1\sim cnt</script></p><p>首先，对于不经过环的那些路径，无论怎么断边它的长度都不会变，可以先在环上每个点的子树里dfs求得其中最长的那条，记为<code>P</code></p><p>算出环上每个点距离环上第1个点的距离，记为<code>len[i]</code>，算出环上每个点子树内距它最远的点到它的距离，记为<code>mx[i]</code></p><p>预处理出<code>bef[i]</code><script type="math/tex">=\max\limits_{1\le j\le i}</script><code>len[j]+mx[j]</code>，<code>aft[i]</code><script type="math/tex">=\max\limits_{i\le j\le cnt}</script><code>(len[cnt]-len[j])+mx[j]</code></p><p><code>bef2[i]</code><script type="math/tex">=\max\limits_{1\le j < k \le i}</script><code>mx[j]+mx[k]+(len[k]-len[j])</code>，<code>aft2[i]</code><script type="math/tex">=\max\limits_{i\le j < k \le cnt}</script><code>mx[j]+mx[k]+(len[k]-len[j])</code></p><p>记环上第一个点和最后一个点之间的边的长度是<code>D</code> </p><p>假设断开的是环上第<script type="math/tex">i</script>个点到第<script type="math/tex">i+1</script>个点之间的边，那么此时树的直径长就是<script type="math/tex">\max(</script><code>bef2[i], aft2[i+1], bef[i]+aft[i+1]+D, P</code>$)$</p><p>求出所有直径长取min，再除以2即为答案</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E(i) int i = head[x]; i; i = pre[i]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, _f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) _f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * _f;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head[N], to[N&lt;&lt;<span class="number">1</span>], pre[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line">ll val[N&lt;&lt;<span class="number">1</span>], ans, Ans, len[N], Mx[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, c[N], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N], onc[N], flg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getcir</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">stk[++top] = x; vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (E(i)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (vis[y]) &#123;</span><br><span class="line">flg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (stk[top] != y) c[++tot] = stk[top--];</span><br><span class="line">c[++tot] = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">getcir(y, x);</span><br><span class="line"><span class="keyword">if</span> (flg) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[N], bef[N], aft[N], bef2[N], aft2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">//求直径 </span></span><br><span class="line"><span class="keyword">for</span> (E(i)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa || onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x);</span><br><span class="line">ans = max(ans, f[y] + f[x] + val[i]); <span class="comment">//直径不在环上</span></span><br><span class="line">f[x] = max(f[x], f[y] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">dfs1(c[id], <span class="number">0</span>);</span><br><span class="line">Mx[id] = f[c[id]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll now = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">bef[i] = max(bef[i<span class="number">-1</span>], now + Mx[i]);</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) bef2[i] = max(bef2[i<span class="number">-1</span>], mx + now + Mx[i]);</span><br><span class="line">mx = max(mx, Mx[i] - now);</span><br><span class="line">now += len[i];</span><br><span class="line">&#125; </span><br><span class="line">now = mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; i--) &#123;</span><br><span class="line">aft[i] = max(aft[i+<span class="number">1</span>], now + Mx[i]);</span><br><span class="line"><span class="keyword">if</span> (i &lt; tot) aft2[i] = max(aft2[i+<span class="number">1</span>], mx + now + Mx[i]);</span><br><span class="line">mx = max(mx, Mx[i] - now);</span><br><span class="line">now += len[i<span class="number">-1</span>];</span><br><span class="line">&#125; </span><br><span class="line">Ans = min(Ans, bef2[tot]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) &#123;</span><br><span class="line">ll ccf = max(max(bef2[i], aft2[i+<span class="number">1</span>]), bef[i] + aft[i+<span class="number">1</span>] + len[tot]);</span><br><span class="line">ccf = max(ccf, ans);</span><br><span class="line">Ans = min(Ans, ccf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); Ans = <span class="number">114514114514114514</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v; ll w;</span><br><span class="line">read(u); read(v); read(w);</span><br><span class="line">addedge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">getcir(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) onc[c[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = c[i];</span><br><span class="line"><span class="keyword">for</span> (E(j)) <span class="keyword">if</span> (to[j] == c[i%tot+<span class="number">1</span>]) len[i] = val[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">solve(i);</span><br><span class="line">&#125;</span><br><span class="line">DP();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, Ans / <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形DP" scheme="http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇[CSP2020]</title>
    <link href="http://akdream.tk/post/8edb7c14.html/"/>
    <id>http://akdream.tk/post/8edb7c14.html/</id>
    <published>2020-11-12T09:55:28.000Z</published>
    <updated>2020-11-12T10:28:40.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.luogu.com.cn/problem/P7078" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7078</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考场上开T4的时候只有40~50分钟了 努力思索了10分钟想到一个结论(中途想假了一次) </p><p>然后发现部分分还挺多：70分</p><h4 id="70分"><a href="#70分" class="headerlink" title="70分"></a>70分</h4><p>简单说说70分做法：先假设游戏一直进行，那么就可以用<code>set</code>把每轮游戏是谁吃谁处理出来</p><p>显然游戏共有<script type="math/tex">n-1</script>轮，从最后一轮开始向前扫，假设当前到第<script type="math/tex">i</script>轮，是<script type="math/tex">A</script>吃掉<script type="math/tex">B</script>，记<script type="math/tex">t</script>为第<script type="math/tex">i\sim n-1</script>轮中第一次有蛇叫停是在第几轮(初始时$t=n$)，同时记录<script type="math/tex">d_x</script>表示若游戏一直进行则第<script type="math/tex">x</script>条蛇在第<script type="math/tex">d_x</script>轮被吃掉，那么如果<script type="math/tex">d_A < t</script>就表示<script type="math/tex">A</script>如果这一轮吃了<script type="math/tex">B</script>，那它在后面一定会被吃掉，所以<script type="math/tex">A</script>必须叫停，更新<script type="math/tex">t</script>为<script type="math/tex">i</script>，否则不更新</p><p>最终答案即为<script type="math/tex">n-t+1</script>，复杂度<script type="math/tex">O(Tn\log n)</script></p><h4 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h4><p>如何<script type="math/tex">O(n)</script>把上面<code>set</code>求的东西求出来？</p><p>这题的做法和NOIP2016蚯蚓比较像，通过维护多个普通队列来存取最小/最大值</p><p>具体地说，维护两个普通队列，一个初始时装着排好序的所有元素，一个初始为空</p><p>每次操作时，分别找出两个队列的队头元素，取其中较小者即是当前的最小元素，最大元素同理取队尾</p><p>然后把最大减最小的那个元素放到第二个队列的队头</p><p>只要两个队列都具有单调性，这个做法就是对的</p><p>显然只出不进的队列1时刻具有单调性 考虑队列2</p><p>整个<script type="math/tex">n-1</script>轮分为两个阶段 假设第<script type="math/tex">i</script>轮场上最大的蛇是<script type="math/tex">A_i</script>，最小是<script type="math/tex">B_i</script></p><p><strong>1.<script type="math/tex">A_i\ge 2*B_i</script></strong></p><p>那么显然有<script type="math/tex">A_{i+1}\le A_i,B{i+1}\ge B_i</script></p><p>假设<script type="math/tex">C_i</script>是<script type="math/tex">A_i</script>吃<script type="math/tex">B_i</script>得到的那条蛇，那么有<script type="math/tex">C_i\ge C_{i+1}</script></p><p>当<script type="math/tex">C_i>C_{i+1}</script>时，队列2就是有单调性的了</p><p>当<script type="math/tex">C_i=C_{i+1}</script>时，一定有<script type="math/tex">A_i=A_{i+1}</script>，那么要不<script type="math/tex">A_i</script>和<script type="math/tex">A_{i+1}</script>两次其实都是标号相同的那条蛇(即<script type="math/tex">C_i</script>作为<script type="math/tex">A_{i+1}</script>被弹出队列2了)，要不<script type="math/tex">A_i</script>的标号大于<script type="math/tex">A_{i+1}</script>也就是说<script type="math/tex">C_i</script>的标号大于<script type="math/tex">C_{i+1}</script>，两种情况都满足队列2的单调性</p><p>至此证明了阶段1中队列2是有单调性的</p><p><strong>2.<script type="math/tex">A_i<2*B_i</script></strong></p><p>第一次满足这个条件时，看作是进入了阶段2</p><p>假设第一次进入阶段2时，共有<script type="math/tex">m</script>条蛇，从小到大为<script type="math/tex">a_1,a_2,\cdots a_m</script></p><p>那么第一次吃完后的蛇长度为<script type="math/tex">a_m-a_1<a_1</script></p><p>第二次一定是<script type="math/tex">a_{m-1}-(a_m-a_1)\le a_1</script></p><p>第三次是<script type="math/tex">a_{m-2}</script>减掉第二次得到的那个值，也是<script type="math/tex"><a_1</script></p><p>假设第<script type="math/tex">i</script>次减出来的值是<script type="math/tex">v_i</script>，由于队列1中已没有长度<strong>小于</strong><script type="math/tex">a_1</script>的蛇，不难看出第<script type="math/tex">i+1</script>次的最短蛇的长度一定是<script type="math/tex">v_i</script>(但是编号不一定相同)</p><p>继续推下去，易证对于所有的奇数次，有<script type="math/tex">v_i<a_1</script>，而偶数次有<script type="math/tex">v_i\le a_1</script></p><p>对于奇数次<script type="math/tex">i</script>，第<script type="math/tex">i+1</script>轮中最小值必然是<script type="math/tex">v_i</script>，那么就相当于<script type="math/tex">v_i</script>进入队列2后又马上被弹出了，依然不影响队列2单调性</p><p>换个说法 也就是说<script type="math/tex">A_i</script>在吃完<script type="math/tex">B_i</script>后，下一轮马上作为<script type="math/tex">B_{i+1}</script>被吃掉</p><p>对于偶数次<script type="math/tex">i</script>，若第<script type="math/tex">i+1</script>轮中最小蛇是<script type="math/tex">v_i</script>则同上</p><p><strong>如果<script type="math/tex">v_i=a_1</script>并且此时有和它长度相同但编号更小的蛇呢？</strong></p><p>假设第一次出现这种情况是在第<script type="math/tex">k</script>轮，<script type="math/tex">A_k</script>吃完<script type="math/tex">B_k</script>后长度变成<script type="math/tex">v_k</script>，由于有比<script type="math/tex">v_k</script>更小的作为<script type="math/tex">B_{k+1}</script>，那么<script type="math/tex">B_{k+1}</script>就一定不和<script type="math/tex">A_k</script>是同一条蛇了</p><p>那么只有<script type="math/tex">k+1</script>和<script type="math/tex">k+2</script>两轮的最大蛇都选择要吃时，$A_k$`才有可能在后续被吃掉</p><p>而由于<script type="math/tex">k+1</script>是奇数，所以如果<script type="math/tex">A_{k+2}</script>在第<script type="math/tex">k+2</script>轮选择吃的话，吃掉的一定是此时长度小于<script type="math/tex">a_1</script>的<script type="math/tex">A_{k+1}</script></p><p>这样一来，<script type="math/tex">A_{k+1}</script>在<script type="math/tex">k+1</script>轮肯定就会选择叫停，所以 “<script type="math/tex">k+1</script>和<script type="math/tex">k+2</script>两轮的最大蛇都选择要吃” 是不可能的</p><p>所以<script type="math/tex">A_k</script>在后续一定不会被吃掉，它就一定会选择吃<script type="math/tex">B_k</script></p><p>注意到此时<script type="math/tex">k-1</script>也是奇数，那么<script type="math/tex">A_{k-1}</script>和<script type="math/tex">B_k</script>就是同一条蛇，所以<script type="math/tex">A_{k-1}</script>在第<script type="math/tex">k-1</script>轮一定叫停</p><p>写了这么多，就是为了证明出现这种情况时，游戏在第<script type="math/tex">k-1</script>轮就一定会终止，那么就从第<script type="math/tex">k-2</script>轮往回扫就行了</p><p>这样我们就<script type="math/tex">O(n)</script>算出了上面<code>set</code>算的东西，然后再套用上面的70分做法即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ttt, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N], eaten[N], h1, t1, h2, t2;</span><br><span class="line">pii q1[N], q2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">getmn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((h2 &gt; t2) || (h1 &lt;= t1 &amp;&amp; q1[t1] &lt; q2[t2])) <span class="keyword">return</span> q1[t1--];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> q2[t2--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">getmx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((h2 &gt; t2) || (h1 &lt;= t1 &amp;&amp; q1[h1] &gt; q2[h2])) <span class="keyword">return</span> q1[h1++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> q2[h2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(eaten, <span class="number">0</span>, <span class="keyword">sizeof</span>(eaten));</span><br><span class="line"><span class="keyword">int</span> ans = st + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i; i--) &#123;</span><br><span class="line">eaten[c[i]] = i;</span><br><span class="line"><span class="keyword">if</span> (eaten[b[i]] &amp;&amp; eaten[b[i]] &lt; ans) &#123;</span><br><span class="line">ans = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">h1 = h2 = <span class="number">1</span>; t1 = t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) q1[++t1] = mp(a[i], i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">pii mx = getmx(), mn = getmn();</span><br><span class="line">pii nowmn = min(h1&lt;=t1?q1[t1]:mp(inf, inf), h2&lt;=t2?q2[t2]:mp(inf, inf));</span><br><span class="line">pii now = mp(mx.fi-mn.fi, mx.se);</span><br><span class="line">b[i] = mx.se; c[i] = mn.se;</span><br><span class="line"><span class="keyword">if</span> (now &lt; nowmn) flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flag &amp;&amp; now &gt;= nowmn) &#123;</span><br><span class="line">calc(i<span class="number">-2</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">q2[++t2] = now;</span><br><span class="line">&#125; </span><br><span class="line">calc(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(ttt); ttt--;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ttt; i++) &#123;</span><br><span class="line">read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x, y; j &lt;= k; j++) &#123;</span><br><span class="line">read(x); read(y);</span><br><span class="line">a[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7078&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数调用[CSP2020]</title>
    <link href="http://akdream.tk/post/aad8b10f.html/"/>
    <id>http://akdream.tk/post/aad8b10f.html/</id>
    <published>2020-11-09T13:17:58.000Z</published>
    <updated>2020-11-10T09:29:39.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P7077" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7077</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>第一眼看像是数据结构题？</p><p>后来发现这题压根不用数据结构</p><p>考虑对于给出的操作建一个图：对于所有操作3，按顺序向它调用的函数连边，这样会得到一个DAG</p><p>对于乘法操作，在最后给所有数组元素乘上就好了，关键在于每个加法操作最后乘了一个多大的系数</p><p>假设整个数组只有一个元素，对它依次执行：+1, *3, +2, *2</p><p>那么+1操作实际上就有一个2*3=6的系数，+2有2的系数，所以假设原来这个元素是$x$，那它最后会是$6x+1\times 6+ 2\times 2$</p><p>发现一个加法操作带的系数就等于它后面的所有乘法操作之积，所以可以倒着进行操作，一边记录已进行的所有乘法操作的积是多少，这样就能计算出每次加法操作带的系数是多少</p><p>至此，只含1,2操作的情况就处理完了，接下来考虑3操作</p><p>对于图上的每个点(代表着一种操作)，维护一个mul属性，表示执行一次这个操作会给累计的积乘上多少</p><p>对于1类操作，它的mul=1；对于2类操作，它的mul就等于它要乘上的值；而对于3类操作，它的mul等于它直接连向的所有点的mul之积</p><p><img src="https://akdream.tk/img/108_1.png" class="lazyload" data-srcset="https://akdream.tk/img/108_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如图，点2的mul为2，点3的mul为3，所以点1的mul为6，那么执行一次操作1就会让前面执行过的所有的加法操作再乘上6的系数</p><p>按照拓扑序倒序扫一遍或者直接dfs即可处理出mul</p><p>然后倒着进行$q$次操作，就可以求得每次操作(类型1或3)带着多少系数，记作sum，然后再把类型3的节点的sum下传到它所包含的类型1节点即可</p><p>但是有些类型3的操作既包含加法又包含乘法怎么办？</p><p><img src="https://akdream.tk/img/108_2.png" class="lazyload" data-srcset="https://akdream.tk/img/108_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>考虑这样一张图 假设编号为1的操作的sum是$x$，那么+2这个操作的sum应该额外增加$3x$，同理+1的sum应增加$12x$</p><p>所以下传sum时，假设一个点$x$的sum是$S$，它的儿子是$y_1,y_2,\cdots y_k$，<br>那么$y_i$的sum就应该增加$S$乘上$y_{i+1}\sim y_k$的mul之积</p><p>最后，让数组的每个元素乘上所有$q$次操作的mul，再遍历所有加法操作计算应该加多少即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, F[N];</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz, inde[N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; inde[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oper</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tp, p;</span><br><span class="line">ll v, mul, sum; </span><br><span class="line">&#125; b[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ord[N], bnbn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123; <span class="comment">//拓扑排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (!inde[i]) q.push(i);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">ord[++bnbn] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line">inde[y]--;</span><br><span class="line"><span class="keyword">if</span> (!inde[y]) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmul</span><span class="params">()</span> </span>&#123; <span class="comment">//计算节点的mul</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = ord[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[x]; j; j = pre[j]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[j];</span><br><span class="line">b[x].mul = b[x].mul * b[y].mul % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsum</span><span class="params">()</span> </span>&#123; <span class="comment">//下传节点的sum</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = ord[i]; ll now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[x]; j; j = pre[j]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[j];</span><br><span class="line">b[y].sum = (b[y].sum + b[x].sum * now % mod) % mod;</span><br><span class="line">now = now * b[y].mul % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]); </span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">read(b[i].tp);</span><br><span class="line"><span class="keyword">if</span> (b[i].tp == <span class="number">1</span>) &#123;</span><br><span class="line">read(b[i].p); read(b[i].v);</span><br><span class="line">b[i].mul = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i].tp == <span class="number">2</span>) &#123;</span><br><span class="line">read(b[i].v); b[i].mul = b[i].v;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">read(b[i].p); b[i].mul = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= b[i].p; j++) &#123;</span><br><span class="line">read(x);</span><br><span class="line">addedge(i, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">toposort(); </span><br><span class="line">getmul();</span><br><span class="line">read(Q); ll now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) read(F[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Q; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = F[i]; b[x].sum = (b[x].sum + now) % mod;</span><br><span class="line">now = now * b[x].mul % mod;</span><br><span class="line">&#125;</span><br><span class="line">getsum();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = a[i] * now % mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i].tp == <span class="number">1</span>) &#123;</span><br><span class="line">a[b[i].p] = (a[b[i].p] + b[i].v * b[i].sum % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7077&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="拓扑排序" scheme="http://akdream.tk/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>动物园[CSP2020]</title>
    <link href="http://akdream.tk/post/ad950814.html/"/>
    <id>http://akdream.tk/post/ad950814.html/</id>
    <published>2020-11-09T13:17:32.000Z</published>
    <updated>2020-11-09T13:20:51.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.luogu.com.cn/problem/P7076" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7076</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这应该是最签到的一题了吧</p><p>饲料共有$c$种，1e8存不下，先对饲料编号进行重新标号</p><p>注意这里并不需要进行离散化(排序去重)，由于$q_i$互不相同，所以只需要把第$i$种饲料的编号看作$i$即可 (什么叫签到题啊)</p><p>首先对于已有的动物，先处理出$K$位中哪些位有动物是1</p><p>然后扫一遍所有要求找出哪些饲料必买</p><p>最后再扫一遍所有要求算出$K$位中哪些位可以是1</p><p>假设有$x$位可以是1，那答案就是$2^x-n$</p><p><strong>注意点：</strong></p><ol><li>答案可能爆<code>long long</code> 需要<code>unsigned long long</code></li><li>如果$n=m=0,k=64$，那么答案为$2^64$，会爆<code>unsigned long long</code>。。。需要特判</li></ol><p>感觉会在2处挂5pts。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, c, k, p[N];</span><br><span class="line">ull a[N], S, ans, fst;</span><br><span class="line"><span class="keyword">bool</span> buy[N], ok[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebuy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((S&gt;&gt;p[i])&amp;<span class="number">1</span>) buy[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveans</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) ok[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!buy[i]) ok[p[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="keyword">if</span> (ok[i]) cnt++;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">64</span>) &#123;</span><br><span class="line">ans = (<span class="number">1u</span>ll &lt;&lt; <span class="number">63</span>) - n + (<span class="number">1u</span>ll &lt;&lt; <span class="number">63</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> ans = (<span class="number">1u</span>ll &lt;&lt; cnt) - n;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m); read(c); read(k);</span><br><span class="line"><span class="keyword">if</span> (!n &amp;&amp; !m &amp;&amp; k == <span class="number">64</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"18446744073709551616"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]); S |= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">read(p[i]); read(fst);</span><br><span class="line">&#125;</span><br><span class="line">solvebuy();</span><br><span class="line">solveans();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//%lld好像不太行 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7076&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>儒略日[CSP2020]</title>
    <link href="http://akdream.tk/post/51b41b34.html/"/>
    <id>http://akdream.tk/post/51b41b34.html/</id>
    <published>2020-11-09T13:17:16.000Z</published>
    <updated>2020-11-09T13:20:51.347Z</updated>
    
    <content type="html"><![CDATA[<p>题面太长不放</p><p><a href="https://www.luogu.com.cn/problem/P7075" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7075</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="如何优雅地在开考40分钟内完成此题？"><a href="#如何优雅地在开考40分钟内完成此题？" class="headerlink" title="如何优雅地在开考40分钟内完成此题？"></a>如何优雅地在开考40分钟内完成此题？</h4><p>首先最重要的一点：发现1600年之前的闰年规律都是每4年一次，而1600又正好是400的倍数，所以以1600作为分界线，分成1600年前后两种情况比较好处理</p><p>其次，发现0年不存在也不方便，所以把所有的负数年份+1，输出时再改回来</p><p>公元前4913年1月1日是第0天也不方便，所以把 <code>r++</code></p><p>准备工作做好，现在来考虑怎么求解</p><h4 id="一-1600年及以前"><a href="#一-1600年及以前" class="headerlink" title="(一)1600年及以前"></a>(一)1600年及以前</h4><p>如果$r&lt;=M$，那么时间在1600年及以前($M$表示-4713到1600共有多少天)</p><p>发现-4713到1600只有6000多年，所以干脆把每一年的天数都算出来(然后求前缀和方便二分)</p><p>注意的点：</p><ol><li>由于我们把所有的负数年份+1了，所以现在所有模4余0的年份都是闰年</li><li><strong>1582年只有355天！！！</strong> </li></ol><p>求出前缀和后(即-4713年到1600年及之前的某一年一共有多少天)，就可以二分求出究竟是在哪一年的第几天，然后跳转到**(三)**</p><h4 id="二-1600年之后"><a href="#二-1600年之后" class="headerlink" title="(二)1600年之后"></a>(二)1600年之后</h4><p>如果$r&gt;M$，那么时间在1600年之后，让$r$减去$M$</p><p>此时每400年为一个周期，400年一共经过了$366<em>97+365</em>303=146097$天</p><p>算出$p=\lfloor\dfrac{r}{146097}\rfloor$表示一共经过了多少个400年</p><p>$q=r\bmod 146097$表示剩余多少天</p><p><strong>注意！如果$q=0$，为方便后续计算，要让$p$减去1，并将$q$设为$146097$</strong></p><p>之后就同**(一)**一样，预处理出400年中每一年的天数和前缀和，就可以二分求出$q$究竟是在最后余下的不到400年中的哪一年，以及是这年的第几天</p><p>如果二分求得是最后400年中的第$k$年，那么答案年份就应该是$1600+400p+k$</p><p>然后跳转到**(三)**</p><h4 id="三-一年内的判断"><a href="#三-一年内的判断" class="headerlink" title="(三)一年内的判断"></a>(三)一年内的判断</h4><p>现在我们已经确定了答案是哪一年，是这一年的第几天，只需要找出月份和日期即可</p><p>发现$Q\le 10^5$，其实可以算出这一年的12个月各有多少天，然后从一月开始枚举，就很容易算出是几月几日</p><p>注意前面给负数年份加了1，现在要减回来</p><p>注意事项：</p><ol><li>1600年之前的闰年判定和1600年之后不同！注意区分</li><li>1582年的10月只有21天！</li><li>如果你得出的答案是1582年10月5<del>21日，给日期加上10！1582.10.5</del>1582.10.14不存在！</li></ol><p>注意事项3成功导致我100pts -&gt; 40pts /kk</p><p>写多几个函数一定会比全部挤在main函数中条理更清晰</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ttt, M = <span class="number">5000</span>; <span class="comment">//M作为数组的偏移量，防止数组越界 </span></span><br><span class="line">ll n;</span><br><span class="line">ll months[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;, nmonth[<span class="number">13</span>];</span><br><span class="line">ll Aday[<span class="number">10005</span>], Bday[<span class="number">10005</span>]; <span class="comment">//A:1600之前; B:400年的周期 </span></span><br><span class="line">ll days400 = <span class="number">146097</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initrun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">-4712</span>; i &lt;= <span class="number">1600</span>; i++) Aday[i+M] = <span class="number">365</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">-4712</span>; i &lt;= <span class="number">1600</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">Aday[i+M] = <span class="number">366</span>;</span><br><span class="line">&#125;</span><br><span class="line">Aday[<span class="number">1582</span>+M] = <span class="number">355</span>; <span class="comment">//!!!</span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">-4712</span>; i &lt;= <span class="number">1600</span>; i++) Aday[i+M] += Aday[i+M<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">400</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i % <span class="number">400</span> == <span class="number">0</span>) || (i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> != <span class="number">0</span>)) Bday[i] = Bday[i<span class="number">-1</span>] + <span class="number">366</span>;</span><br><span class="line"><span class="keyword">else</span> Bday[i] = Bday[i<span class="number">-1</span>] + <span class="number">365</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printans</span><span class="params">(ll y, ll m, ll d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld BC\n"</span>, d, m, -y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld\n"</span>, d, m, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inyear</span><span class="params">(ll y, ll d)</span> </span>&#123; <span class="comment">//y年的第d天 </span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) nmonth[i] = months[i];</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1582</span>) &#123; <span class="comment">//in 1582 </span></span><br><span class="line">nmonth[<span class="number">10</span>] = <span class="number">21</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &lt;= <span class="number">1600</span>) &#123; <span class="comment">//before 1600</span></span><br><span class="line"><span class="keyword">if</span> (y % <span class="number">4</span> == <span class="number">0</span>) nmonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//after 1600</span></span><br><span class="line"><span class="keyword">if</span> ((y % <span class="number">400</span> == <span class="number">0</span>) || (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>)) &#123; </span><br><span class="line">nmonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= <span class="number">0</span>) y--; <span class="comment">//恢复负数年份 </span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d &lt;= nmonth[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1582</span> &amp;&amp; i == <span class="number">10</span> &amp;&amp; d &gt;= <span class="number">5</span>) d += <span class="number">10</span>; <span class="comment">//100pts-&gt;40pts</span></span><br><span class="line">printans(y, i, d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">d -= nmonth[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(ll x)</span> </span>&#123; <span class="comment">//before 1600</span></span><br><span class="line">ll l = <span class="number">-4712</span>, r = <span class="number">1600</span>, mid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (Aday[mid+M] &gt;= x) &#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">inyear(ans, x - Aday[ans+M<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(ll x)</span> </span>&#123; <span class="comment">//after 1600</span></span><br><span class="line">ll p = x / days400;</span><br><span class="line">ll q = x % days400;</span><br><span class="line"><span class="keyword">if</span> (!q) &#123;</span><br><span class="line">p--; q = days400;</span><br><span class="line">&#125;</span><br><span class="line">ll l = <span class="number">1</span>, r = <span class="number">400</span>, mid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (Bday[mid] &gt;= q) &#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">inyear(<span class="number">1600</span> + p * <span class="number">400</span> + ans, q - Bday[ans<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(ttt);</span><br><span class="line">initrun();</span><br><span class="line"><span class="keyword">while</span> (ttt--) &#123;</span><br><span class="line">read(n); n++; </span><br><span class="line"><span class="keyword">if</span> (n &lt;= Aday[<span class="number">1600</span>+M]) &#123; <span class="comment">//before 1600</span></span><br><span class="line">solve1(n);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//after 1600</span></span><br><span class="line">solve2(n - Aday[<span class="number">1600</span>+M]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题面太长不放&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7075&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P7075&lt;/a&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩形区域[IOI2019]</title>
    <link href="http://akdream.tk/post/f48e3c0f.html/"/>
    <id>http://akdream.tk/post/f48e3c0f.html/</id>
    <published>2020-11-04T03:31:25.000Z</published>
    <updated>2020-11-04T03:33:01.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://loj.ac/problem/3177" target="_blank" rel="noopener">https://loj.ac/problem/3177</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设某个合法的矩形只有一行，是$a_{1,l}\sim a_{1,r}$，那么显然有这样一个结论成立：$a_{1,l-1}$是$a_{1,r+1}$左侧第一个大于它的 或者$a_{1,r+1}$是$a_{1,l-1}$右侧第一个大于它的</p><p>那么对于一个合法矩形，每一行都应该满足这个条件</p><p>每一列应该也要满足类似的条件</p><p>所以对于一行(或列)，可以通过单调栈来求出所有这样的$[l,r]$</p><p>对于每一行都用这样的方法求出这样的$[l,r]$，用一个<code>vector</code>:$ok[l][r]$来存储所有$a_{i,l}~a_{i,r}$为合法段的$i$</p><p>枚举矩形右边界$r$，并每次更新$lok[u][d]$表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 </p><p>然后枚举矩形左边界$l$，枚举$ok[l][r]$中的每一个连续段$[u,d]$，那么矩形的上下边界在$[u,d]$中时一定是满足行的限制的，只需找出有多少个左右边界为$l,r$，上下边界在$[u,d]$内的矩形满足条件即可</p><p>代码中做了注释</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2520</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N][N], stk[N], cnt, top, ans; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ok[N][N]; <span class="comment">//ok[l][r]: a[l][i]~a[r][i]为合法段的i的集合 </span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp[N]; <span class="comment">//临时存答案 </span></span><br><span class="line"><span class="keyword">int</span> lok[N][N], rok[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//找出所有合法段 </span></span><br><span class="line">cnt = top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (top &amp;&amp; num[i] &gt; num[stk[top]]) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; stk[top] + <span class="number">1</span>) tmp[++cnt] = make_pair(stk[top]+<span class="number">1</span>, i<span class="number">-1</span>); </span><br><span class="line"><span class="comment">//num[l] &lt; num[r]</span></span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (top) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; stk[top] + <span class="number">1</span>) tmp[++cnt] = make_pair(stk[top]+<span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//num[l]&gt;num[r]</span></span><br><span class="line"><span class="keyword">if</span> (num[i] == num[stk[top]]) top--;</span><br><span class="line"><span class="comment">//特殊处理相等情况 </span></span><br><span class="line">&#125;</span><br><span class="line">stk[++top] = i; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123; </span><br><span class="line"><span class="comment">//左右边界为l,r;上下边界在[u,d]内 </span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u - <span class="number">1</span>; i &lt;= d + <span class="number">1</span>; i++) &#123;</span><br><span class="line">a[<span class="number">0</span>][++len] = a[i][r];</span><br><span class="line">&#125;</span><br><span class="line">solve(a[<span class="number">0</span>], len); <span class="comment">//找出列的合法段 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tl = tmp[i].first + u - <span class="number">2</span>, tr = tmp[i].second + u - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (lok[tl][tr] &lt;= l) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">read(a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123; <span class="comment">//预处理ok集合 </span></span><br><span class="line">solve(a[i], m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) ok[tmp[j].first][tmp[j].second].push_back(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt; m; r++)  &#123; <span class="comment">//枚举矩形右边界 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[<span class="number">0</span>][i] = a[i][r];</span><br><span class="line">solve(a[<span class="number">0</span>], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (rok[tmp[i].first][tmp[i].second] + <span class="number">1</span> &lt; r)</span><br><span class="line">lok[tmp[i].first][tmp[i].second] = r;</span><br><span class="line">rok[tmp[i].first][tmp[i].second] = r;</span><br><span class="line"><span class="comment">//lok[u][d]表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= r; l++) &#123; <span class="comment">//枚举矩形左边界 </span></span><br><span class="line"><span class="keyword">if</span> (!ok[l][r].size()) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> lst = ok[l][r][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ok[l][r].size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ok[l][r][i] &gt; ok[l][r][i<span class="number">-1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//找出ok[l][r]中的一个连续段 </span></span><br><span class="line">calc(l, r, lst, ok[l][r][i<span class="number">-1</span>]);</span><br><span class="line">lst = ok[l][r][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">calc(l, r, lst, ok[l][r][ok[l][r].size()<span class="number">-1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3177&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mr Panda and Survey[HDU6001]</title>
    <link href="http://akdream.tk/post/d3259d46.html/"/>
    <id>http://akdream.tk/post/d3259d46.html/</id>
    <published>2020-10-06T12:25:41.000Z</published>
    <updated>2020-10-08T12:16:08.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6001" target="_blank" rel="noopener">https://acm.hdu.edu.cn/showproblem.php?pid=6001</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设$f(S)$表示有多少种选问卷的情况使得$S$中所有元素都不是好问题</p><p>设$ans[S]$表示选择的问题集合是$S$时，有多少种选择问卷的方案使得它们全部是好问题</p><p>那么由容斥原理，$ans[S]=2^n+\sum\limits_{S_2\subseteq S}(-1)^{t(S)}f(S)$，其中$t(S)$为$S$中元素个数</p><p>考虑如何预处理$f(S)$</p><p>对于每个问卷$x$，设$tag[x]=\sum\limits_{i=1}^{m}2^i[a[x][i]=Y]$，即如果第$i$个问题答案是yes那第$i$位就是$1$</p><p>设$cnt[p]$表示有多少$x$的$cnt[x]=p$</p><p>那么对于一种使得所有问题<strong>都不是好问题</strong>的选择方案，选择的所有问卷的$tag$一定相等</p><p>所以容易得出$f(2^n-1)=1+\sum\limits_{i=0}^{2^m-1}(2^{cnt[i]}-1)$</p><p>最前面那个$1$表示取空集</p><p>假设我们已经算出$f(S)$，考虑$S$去掉一个元素$i$得到的新集合$S_2$</p><p>那么此时$i$是不是好问题就无所谓了，所以可以直接把$i$这一位给“删掉”</p><p>具体实现中，可以对于所有包含$i$的集合$T$，让$cnt[T-i]+=cnt[T]$，然后这个$cnt[T]$就当它不存在，这样就相当于默认第$i$位是$0$(操作A)</p><p>(这里不是做减法，只是表示$T$集合去掉元素$i$)</p><p> 那么对于$f(S_2)$，枚举$S_2$的所有子集$S_3$(显然除了$S_3$以外的那些集合$T$的$cnt[T]$已经被我们当成不存在了)，有$f(S_2)=1+\sum\limits_{S_3\subseteq S_2}(2^{cnt[S_3]}-1)$</p><p>然后考虑用一个dfs，我们已经算出$f(S)$了，这时进行上面那个操作A，然后往$S_2$递归，就能算出$f(S_2)$</p><p>这一步的复杂度是$O(m^3)$的，这样就处理出了所有的$f(S)$</p><p>然后回到上面$ans[S]=2^n+\sum\limits_{S_2\subseteq S}(-1)^{t(S)}f(S)$，这一步的复杂度也是$O(m^3)$的，总时间复杂度为$O(tm^3)$(时限40s?)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>暂时还没有</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://acm.hdu.edu.cn/showproblem.php?pid=6001&quot; targ
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩阵游戏[NOI2013]</title>
    <link href="http://akdream.tk/post/cd282ac6.html/"/>
    <id>http://akdream.tk/post/cd282ac6.html/</id>
    <published>2020-09-27T14:26:06.000Z</published>
    <updated>2020-09-27T14:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足一个神奇的性质：若用$F[i][j]$来表示矩阵中第$i$行第$j$列的元素，则$F[i][j]$满足下面的递推式:</p><p>$$F[1][1]=1$$</p><p>$$F[i,j]=a\times F[i][j-1]+b (j\neq 1)$$</p><p>$$F[i,1]=c\times F[i-1][m]+d (i\neq 1)$$</p><p>递推式中$a,b,c,d$都是给定的常数。</p><p>现在婷婷想知道$F[n][m]$的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出$F[n][m]$除以$1,000,000,007$的余数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑$F[i][1]$和$F[i][m]$之间的关系：</p><p>$$F[i][m]=a(a(\cdots(a\times F[i][1]+b)\cdots)+b)+b$$<br>$$=a^{m-1}\times F[i][1] + a^{m-2}b + a^{m-3}b + \cdots + b$$<br>$$=a^{m-1}\times F[i][1] + \dfrac{a^{m-1}-1}{a-1}\times b$$</p><p>由此可得<br>$$F[i+1][1]=a^{m-1}c\times F[i][1] + \dfrac{a^{m-1}-1}{a-1}\times bc + d$$</p><p>设$A=a^{m-1}c,\ B=\dfrac{a^{m-1}-1}{a-1}\times bc + d$，则</p><p>$$F[i+1][1]=A\times F[i][1]+B$$</p><p>如法炮制，可得</p><p>$$F[n][1]=A^{n-1}\times F[1][1] + \dfrac{A^{n-1}-1}{A-1}\times B$$</p><p>由于$F[1][1]=1$，所以可以先把$F[n][1]$算出来，然后再使用上面那个$F[i][1]$和$F[i][m]$的关系式来推出$F[n][m]$即可</p><p>如何算$a^{m-1}$?</p><p>由于$a^{p-1}\equiv 1 \pmod p$，所以$a^{m-1}\equiv a^{(m-1)\bmod (p-1)} \pmod p$</p><p>那么对$m-1$取模$p-1$后再进行快速幂即可，$A^{n-1}$同理</p><p>注意特判$a=1$或者$A=1$的情况!!!</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">char</span> n[<span class="number">1000005</span>], m[<span class="number">1000005</span>];</span><br><span class="line">ll N, M, _N, _M;</span><br><span class="line">ll a, b, c, d, nl, ml, am, asum, B, A, Am, Asum;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; t; t &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, n + <span class="number">1</span>, m + <span class="number">1</span>);</span><br><span class="line">read(a); read(b); read(c); read(d);</span><br><span class="line">a %= mod; b %= mod; c %= mod; d %= mod;</span><br><span class="line">nl = <span class="built_in">strlen</span>(n + <span class="number">1</span>); ml = <span class="built_in">strlen</span>(m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i++) &#123;</span><br><span class="line">M = (M * <span class="number">10</span> % mod + m[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i++) &#123;</span><br><span class="line">_M = (_M * <span class="number">10</span> % (mod<span class="number">-1</span>) + m[i] - <span class="string">'0'</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nl; i++) &#123;</span><br><span class="line">N = (N * <span class="number">10</span> % mod + n[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nl; i++) &#123;</span><br><span class="line">_N = (_N * <span class="number">10</span> % (mod<span class="number">-1</span>) + n[i] - <span class="string">'0'</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">am = fpow(a, _M<span class="number">-1</span>); <span class="comment">//a^(p-1)==1 (mod p)</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) asum = M - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> asum = (am - <span class="number">1</span>) * fpow(a - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">B = (b * c % mod * asum % mod + d) % mod;</span><br><span class="line">A = am * c % mod;</span><br><span class="line"></span><br><span class="line">Am = fpow(A, _N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">1</span>) Asum = N - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> Asum = (Am - <span class="number">1</span>) * fpow(A - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">ans = (Am + B * Asum % mod) % mod; <span class="comment">// f[n][1]</span></span><br><span class="line">ans = (am * ans % mod + b * asum % mod) % mod; <span class="comment">//f[n][n]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>方伯伯的商场之旅[SCOI2014]</title>
    <link href="http://akdream.tk/post/b941660e.html/"/>
    <id>http://akdream.tk/post/b941660e.html/</id>
    <published>2020-09-26T14:05:25.000Z</published>
    <updated>2020-09-26T14:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第$j$堆的石子的数量，刚好是$i$写成$K$进制后的第$j$位。</p><p>现在方伯伯要玩一个游戏，商场会给方伯伯两个整数$L,R$。方伯伯要把位置在$[L,R]$中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量$\times$移动的距离。商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅有一行，包含三个用空格分隔的整数$L$，$R$，$K$，表示商场给方伯伯的两个整数，以及进制数。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个整数，表示最少的代价。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑用$1\sim R$的答案减掉$1\sim L-1$的答案，即$\operatorname{solve}(R) - \operatorname{solve}(L-1)$。</p><p>考虑$\operatorname{solve}(n)$，先计算把每个人的石子都全部合并到第$1$堆所需的代价</p><p>这个是可以通过一次数位dp解决的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(ll d, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs1(d<span class="number">-1</span>, sum + i * (d - <span class="number">1</span>), lim &amp; (i == mx)); </span><br><span class="line"><span class="comment">//第d位有i个石子要移动到第1位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这样一个性质：对于一个人$x$，假设他把所有石子最终全部移到第$k$位，我们把$k$叫做$x$的集合点，这样移动的代价是$f_x(k)$，那么$f_x$一定是一个单谷函数</p><p>不妨把$x$的最优集合点叫做$p_x$</p><p>所以我们可以执行这样的操作：</p><p><code>for i=2~n</code>，每次把所有 “集合点在$i$时比在$i-1$时更优 (即$f_x(i-1)&gt;f_x(i)$)” 的那些$x$的集合点全部从$i-1$变为$i$，也就是说让答案减去$f_x(i-1)-f_x(i)$</p><p>这样一来，由于$f_x$是单谷函数，那么一个人$x$一定在$i=2\sim p_x$的时候集合点被移动，那么$x$的最终代价就会是$f_x(p_x)$，所以这个做法是正确的</p><p>然后考虑如何进行这个”挪动集合点”的操作 其实和上面的那个计算集合点全为1的数位dp区别不大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(ll d, ll sum, ll p, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> max(<span class="number">0l</span>l, sum); <span class="comment">//如果sum&lt;0则说明不把集合点从p-1挪到p比较优</span></span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs2(d<span class="number">-1</span>, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll k, len, a[<span class="number">60</span>];</span><br><span class="line">ll L, R, f[<span class="number">60</span>][<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(ll d, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs1(d<span class="number">-1</span>, sum + i * (d - <span class="number">1</span>), lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(ll d, ll sum, ll p, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> max(<span class="number">0l</span>l, sum);</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs2(d<span class="number">-1</span>, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">ll tmp = n;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">a[++len] = tmp % k;</span><br><span class="line">tmp /= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">ll ret = dfs1(len, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">ret -= dfs2(len, <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;L, &amp;R, &amp;k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(R) - solve(L<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第
      
    
    </summary>
    
    
    
      <category term="数位DP" scheme="http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>树的计数[NOI2013]</title>
    <link href="http://akdream.tk/post/c65ab714.html/"/>
    <id>http://akdream.tk/post/c65ab714.html/</id>
    <published>2020-09-23T13:14:37.000Z</published>
    <updated>2020-10-08T12:16:08.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 <code>1 2 4 5 3</code>，BFS 序都是 <code>1 2 3 4 5</code>。</p><p><img src="https://akdream.tk/img/103_1.png" class="lazyload" data-srcset="https://akdream.tk/img/103_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有$K$棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是$h_1,h_2,\cdots,h_K$，那么请你输出：</p><p>$$\dfrac{h_1+h_2+\cdots +h_K}{K}$$</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含$n$个正整数 ，表示树的节点个数。</p><p>第二行包含$n$个正整数，是一个$1\dots n$的排列，表示树的 DFS 序。</p><p>第三行包含$n$个正整数，是一个$1\dots n$的排列，表示树的 BFS 序。</p><p>输入保证至少存在一棵树符合给定的两个序列。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出$1$个实数，四舍五入保留恰好三位小数，表示树高的平均值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于给出的dfs序和bfs序，一定有一种方法给点重新标号，使得bfs序变成$1,2,3,\cdots,n$这个样子</p><p>以样例为例：dfs序为$1,2,4,5,3$，bfs序为$1,2,3,4,5$</p><p>发现深度相同的点，在bfs序中一定是连续一段的，所以原题目可以看作给bfs序进行分段，使得分段后满足dfs序</p><p>样例中$n=5$，有4个分段点</p><p>经过观察，有如下几个分段的限制条件：</p><h3 id="条件一"><a href="#条件一" class="headerlink" title="条件一"></a>条件一</h3><p>深度为1的点一定只有一个(根)，所以$1$后面要进行分段。变为$1 | 2 3 4 5$</p><h3 id="条件二"><a href="#条件二" class="headerlink" title="条件二"></a>条件二</h3><p>设$p[i]$表示$i$在dfs序中在第几个，如$p[3]=5,p[4]=3$</p><p>对于$i \in [1, n)$，如果$p[i]&gt;p[i+1]$，那么有如下两种情况：</p><p>(以样例$p[3]&gt;p[4]$为例)</p><p><img src="https://akdream.tk/img/103_2.png" class="lazyload" data-srcset="https://akdream.tk/img/103_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>得到限制条件：对于$i \in [1, n)$，如果$p[i]&gt;p[i+1]$，那么$i$与$i+1$之间要分段</p><p>样例中，$3$和$4$之间必须要有分割线，即$1|23|45$</p><p>样例中，只有$3$满足$p[i]&gt;p[i+1]$，所以已经确定的必须要有的分割线为$1|23|45$</p><h3 id="条件三"><a href="#条件三" class="headerlink" title="条件三"></a>条件三</h3><p>dfs序为$12453$，$2$后一个为$4$，所以点$4$的深度最多比点$2$多$1$</p><p>在bfs序中，这就等价于说$2$和$4$之间最多有一条分割线</p><p>形式化地，设dfs序数组为$d[N]$，那么对于$i\in [1,n)$，如果$d[i]+1&lt;d[i+1]$，那么在bfs序中$d[i]$与$d[i+1]$之间最多有一条分割线</p><p>发现在样例中，$24$连在一起，那么$3$要不在$2$前面，要不在$4$后面</p><p>如果$3$在$2$前面，那么有$p[2]&gt;p[3]$，出现条件二的情况，$2$和$3$之间必须有分割线</p><p>如果$3$在$4$后面，那么有$p[3]&gt;p[4]$，出现条件二的情况，$3$和$4$之间必须有分割线</p><p>样例中就有$p[3]&gt;p[4]$，所以$3$和$4$之间必须有分割线</p><p>所以可以得出结论：$2$和$4$之间必定至少有一条 由条件二得出的必须存在的分割线</p><p>又因为$2$与$4$之间最多有一条分割线，所以$2\sim 4$之间别的未确定的空隙中就必定是没有分割线的</p><hr><p>以上就是3个分割条件，然后考虑如何实现</p><p>先找出所有的必须存在的分割线(条件一，二)</p><p>样例中必须存在的分割线就是$1|23|45$</p><p>然后根据条件三，$2\sim 4$之间剩余的空隙就不能填分割线，这里也就是$2$和$3$之间的那个空隙一定不能填</p><p>我们把所有 必须填/必须不填 的分割点打上标记，而可以自由选择填或不填的就不打标记</p><p>对于条件一，二，有必须要填的分割线，把必须要填的地方打上标记，并且让答案+1(必须多分割出一层)</p><p>对于条件三，有必须不填的分割线，把必须不填的地方打上差分标记</p><p>然后扫一遍，如果有可以自由选择填或不填的分割点，就让答案加上0.5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N], sum[N];</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); ans = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">read(x); b[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">a[i] = b[a[i]]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">b[a[i]] = i; </span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">1</span>]++; sum[<span class="number">2</span>]--; <span class="comment">//ban:1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; b[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//情况1：i后面必须分段</span></span><br><span class="line">ans++;</span><br><span class="line">sum[i]++; sum[i+<span class="number">1</span>]--;  <span class="comment">//ban:i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] + <span class="number">1</span> &lt; a[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//a[i]~a[i+1]只能分一次段， 且肯定至少有一个情况1</span></span><br><span class="line"><span class="comment">//若有大于等于两个情况1则无解 </span></span><br><span class="line">sum[a[i]]++; sum[a[i+<span class="number">1</span>]]--; <span class="comment">//ban:a[i]~a[i+1]-1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">now += sum[i]; <span class="comment">//差分 </span></span><br><span class="line"><span class="keyword">if</span> (!now) ans += <span class="number">0.5</span>; <span class="comment">//now==0表示可以自由选择在i后面分割 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>方伯伯的玉米田[SCOI2014]</title>
    <link href="http://akdream.tk/post/1dcb3735.html/"/>
    <id>http://akdream.tk/post/1dcb3735.html/</id>
    <published>2020-09-14T10:57:09.000Z</published>
    <updated>2020-09-14T10:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有$N$株，它们的高度参差不齐。<br>方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。<br>问能最多剩多少株玉米，来构成一排美丽的玉米。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数$N$，$K$，分别表示这排玉米的数目以及最多可进行多少次操作。<br>第二行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，最多剩下的玉米数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>有一个显而易见的贪心：即每次都是拔高以$n$结尾的一段区间是最优的</p><p>如果拔高了区间$[i,j]$，其中$j&lt;n$，那么换成拔高$[i,n]$一定不会让答案变得更劣</p><p>所以现在的问题就变成每次选择一段后缀上的玉米进行拔高</p><p>设$dp[i][j]$表示第$i$株玉米总计被拔高了$j$次时，以第$i$株玉米结尾的最长不降子序列的长度(这个子状态有亿点点难想到)</p><p>转移方程：$dp[i][j]=\max(dp[k][l])+1$，其中$k&lt;i,\ l\le j,\ a_k+l\le a_i+j$</p><p>那这个max怎么快速求得呢？似乎要用树套树 不过这题由于空间够用，所以树状数组套树状数组就行了</p><p>答案就是整个dp数组中的最大值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, a[N], dp[N][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">505</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">y++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= <span class="number">10000</span>; i += lowbit(i)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= <span class="number">501</span>; j += lowbit(j)) &#123;</span><br><span class="line">tr[i][j] = max(tr[i][j], v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">y++; <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j -= lowbit(j)) &#123;</span><br><span class="line">ret = max(ret, tr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">dp[i][j] = Query(a[i] + j, j) + <span class="number">1</span>;</span><br><span class="line">Update(a[i] + j, j, dp[i][j]);</span><br><span class="line">ans = max(ans, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有$N$株，它们的高度参差不齐。&lt;br&gt;方伯伯认为
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LCT的进阶应用</title>
    <link href="http://akdream.tk/post/cee3a0d7.html/"/>
    <id>http://akdream.tk/post/cee3a0d7.html/</id>
    <published>2020-08-08T14:59:38.000Z</published>
    <updated>2020-10-08T12:16:07.992Z</updated>
    
    <content type="html"><![CDATA[<p>关于LCT的进阶应用</p><p>不光是写算法思路，<del>因为已经有很多人写过了</del>，更重要的是代码写法中的细节，不然LCT各种奇怪应用的细节够你一题调一个小时</p><p><del>本篇文章将助你考试一遍过样例！</del></p><p>当然，还有一些基础应用比如维护路径信息或者维护联通性，但是代码都相对比较模板，所以也没什么好写</p><h2 id="一-LCT维护边双连通分量"><a href="#一-LCT维护边双连通分量" class="headerlink" title="一. LCT维护边双连通分量"></a>一. LCT维护边双连通分量</h2><p>有些题目中会动态加边并有形如“x到y之间有多少必经边” “某个边双内有多少点”的询问，这时候需要用LCT来维护边双联通分量</p><h3 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>注意到，如果把所有边双缩成点，那么一定会构成一个森林</p><p>此时如果新增了一条边$x,y$，一种情况是$x,y$不在同一棵树里，此时直接<code>link(x,y)</code>即可</p><p>一种情况是$x,y$在同一棵树中，但不在同一个边双中，那么就会形成一个新的边双</p><p>找出$x,y$所在的边双所缩成的点$fx,fy$，然后把$fx$到$fy$这条路径上的所有点缩成一个新点，并让这个新点来记录新的边双中的点的权值之和</p><p>实现时可以用并查集来记录每个点在哪个边双中</p><p>注意，维护边双时不支持删边操作，因为无法快速确定删除某个边双内部的一条边后会分裂成几个新的边双</p><h3 id="代码剖析"><a href="#代码剖析" class="headerlink" title="代码剖析"></a>代码剖析</h3><p>相信大家都已经记住原版LCT是怎么写的了 </p><p>这里来看一下维护边双的LCT和原版有哪些区别</p><h4 id="1-并查集维护每个点在哪个边双中"><a href="#1-并查集维护每个点在哪个边双中" class="headerlink" title="1. 并查集维护每个点在哪个边双中"></a>1. 并查集维护每个点在哪个边双中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;</span><br><span class="line"><span class="comment">//记得初始化并查集</span></span><br></pre></td></tr></table></figure><h4 id="2-access操作写法发生变化"><a href="#2-access操作写法发生变化" class="headerlink" title="2. access操作写法发生变化"></a>2. access操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = find(fa[x])) &#123; <span class="comment">//x每次跳到find(fa[x])而不是fa[x]</span></span><br><span class="line">splay(x); ch[x][<span class="number">1</span>] = i; </span><br><span class="line"><span class="keyword">if</span> (i) fa[i] = x; <span class="comment">//一定要把新的重儿子i的父亲设为x</span></span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-新增操作merge：将x到y的路径缩为一个点"><a href="#3-新增操作merge：将x到y的路径缩为一个点" class="headerlink" title="3. 新增操作merge：将x到y的路径缩为一个点"></a>3. 新增操作merge：将x到y的路径缩为一个点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">split(x, y); <span class="comment">//将x到y的路径提取出来</span></span><br><span class="line">q.push(y);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">//用bfs在二叉树上遍历x到y路径上的所有点</span></span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">Fa[find(u)] = y; <span class="comment">//维护并查集</span></span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">0</span>]) q.push(ch[u][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">1</span>]) q.push(ch[u][<span class="number">1</span>]);</span><br><span class="line">ch[u][<span class="number">0</span>] = ch[u][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">val[y] = sum[y]; <span class="comment">//y成为这个边双的代表元</span></span><br><span class="line"><span class="comment">//如果还有其它信息也是要全部让y来存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-连边-x-y-时的分类讨论"><a href="#4-连边-x-y-时的分类讨论" class="headerlink" title="4. 连边$x,y$时的分类讨论"></a>4. 连边$x,y$时的分类讨论</h4><p>伪代码如下 维护两点联通性可以再开一个并查集，也可以用<code>findroot</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LINK</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>; <span class="comment">//x,y已在同一边双中</span></span><br><span class="line"><span class="keyword">if</span> (x,y不在同一棵树中) &#123;</span><br><span class="line">link(x,y); <span class="comment">//如果用另一个并查集维护联通性记得更新并查集</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">merge(fx,fy); <span class="comment">//是fx,fy 不是x,y!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-进行任何修改-询问操作时都一定是对-fx-find-x-进行，而不是-x-本身！"><a href="#5-进行任何修改-询问操作时都一定是对-fx-find-x-进行，而不是-x-本身！" class="headerlink" title="5. 进行任何修改/询问操作时都一定是对$fx=find(x)$进行，而不是$x$本身！"></a>5. 进行任何修改/询问操作时都一定是对$fx=find(x)$进行，而不是$x$本身！</h4><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="httpss://darkbzoj.tk/problem/2959">[bzoj2959]长跑</a><br><a href="httpss://www.luogu.com.cn/problem/P2542">[AHOI2005]航线规划</a></p><h2 id="二-LCT维护子树信息"><a href="#二-LCT维护子树信息" class="headerlink" title="二. LCT维护子树信息"></a>二. LCT维护子树信息</h2><p>LCT一般用来维护路径信息而不是子树信息，因为LCT维护子树信息非常不方便。。。</p><p>但是有些毒瘤题可能在询问子树信息的同时还有加边删边操作，或者可能有换根操作，就只能被迫使用LCT了</p><h3 id="思路讲解-1"><a href="#思路讲解-1" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>假设现在需要用LCT维护原树中一个子树的$siz$</p><p>为了方便查询，一般会把原树中一条重链的顶端$x$的子树信息存储在 ($x$在LCT中所在的二叉树的根) 的位置<br><img src="https://akdream.tk/img/99_2.png" class="lazyload" data-srcset="https://akdream.tk/img/99_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如上图，原树中的$siz[1]$实际上存在LCT中的$siz[3]$里</p><p>但是一个点子树的$siz$不仅包含自己所在的那条重链的$siz$啊 如何维护轻子树的大小？</p><p>我们记$lsiz[x]$表示LCT中$x$的所有轻子树的$siz$之和，这样$siz[x]$就等于$siz[lson]+siz[rson]+lsiz[x]+1$</p><p>如果我们希望查询$x$点的子树信息，只需要<code>access(x)</code>，然后此时$x$就会位于一条重链的底端，那么$siz[lson]$和$siz[rson]$都为$0$，$siz[x]=lsiz[x]+1$，而此时LCT中$x$的轻子树一定一一对应着原树中$x$的子树，所以此时的$siz[x]$就是$x$在原树中的$siz$</p><p>如果需要查询以$x$为根时整棵子树的信息，只需<code>makeroot(x)</code>，然后直接查询</p><p>接下来的问题就在于如何维护这个$lsiz$了 来看一下代码</p><h3 id="代码剖析-1"><a href="#代码剖析-1" class="headerlink" title="代码剖析"></a>代码剖析</h3><h4 id="1-pushup操作写法发生变化"><a href="#1-pushup操作写法发生变化" class="headerlink" title="1. pushup操作写法发生变化"></a>1. pushup操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + lsum[x] + val[x]; <span class="comment">//lsum表示轻子树的权值和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-access操作写法发生变化-1"><a href="#2-access操作写法发生变化-1" class="headerlink" title="2. access操作写法发生变化"></a>2. access操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">lsum[x] += (siz[ch[x][<span class="number">1</span>]] - siz[i]); <span class="comment">//ch[x][1]变为轻儿子，而i不再是轻儿子</span></span><br><span class="line">ch[x][<span class="number">1</span>] = i; pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-link操作写法发生变化"><a href="#3-link操作写法发生变化" class="headerlink" title="3. link操作写法发生变化"></a>3. link操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); makeroot(y); <span class="comment">//x,y都要makeroot!</span></span><br><span class="line">fa[x] = y;</span><br><span class="line">lsum[y] += sum[x]; <span class="comment">//x成为y的轻儿子</span></span><br><span class="line">pushup(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-单点修改-x-时先-makeroot-x-！"><a href="#4-单点修改-x-时先-makeroot-x-！" class="headerlink" title="4. 单点修改$x$时先 makeroot(x)！"></a>4. 单点修改$x$时先 <code>makeroot(x)</code>！</h4><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="httpss://www.luogu.com.cn/problem/P4219">[BJOI2014]大融合</a><br><a href="httpss://www.luogu.com.cn/problem/P4299">[bzoj3510]首都</a></p><h2 id="3-LCT维护形态树-权值树"><a href="#3-LCT维护形态树-权值树" class="headerlink" title="3. LCT维护形态树+权值树"></a>3. LCT维护形态树+权值树</h2><p>这类题目一般是要求维护树上路径信息，但是经常会对路径上的点权做一些奇怪的操作</p><p>如[BZOJ3159]决战：路径翻转操作<br> [GDSOI2017]中学生数据结构题：路径循环移位操作</p><h3 id="思路讲解-2"><a href="#思路讲解-2" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>众所周知，LCT上的Splay以原树中的节点深度为关键字，随便你怎么<code>rotate</code>，只要节点的相对次序不变，那么就只有辅助树的形态会发生改变，而对应的原树形态不变</p><p>在<code>makeroot(x)</code>操作中，我们翻转了以$x$为根的Splay，节点的相对次序发生了改变，所以其实在原树中就体现为原树的根变成了$x$</p><p>但是在这种题里，如果你还是为了维护权值胡乱操作辅助树Splay，那说不定什么时候你就不小心把哪个点变成原树的根了。。。</p><p>所以我们要再建出一棵辅助树来维护权值，使得在这棵辅助树上进行操作一定不会影响原树形态，我们把这棵辅助树叫做权值树，而LCT那棵叫形态树</p><p>这里我选择了非旋Treap来维护权值树</p><p>现在需要解决的问题就是 我们希望形态树和权值树是时刻对应的</p><p>比如说，现在LCT被分为这样几棵Splay：$[1,2],[3,5,6],[4,7]$，那么此时权值树一定也是被这样划分为3棵的</p><p>还有一个东西也要对应，就是形态树的中序遍历序列要时刻与权值树的中序遍历序列相同，这样才能够保证形态树中某棵平衡树排名第$k$的点和权值树中对应平衡树的第$k$个点是同一个点，方便进行修改</p><p>比如说此时形态树中3棵平衡树的中序遍历分别为$[1,2],[6,3,5],[7,4]$，那么权值树也要一样，绝不可能是$[1,2],[5,3,6],[4,7]$</p><p>为了实现这个功能，我们需要在LCT更改轻边重边时同样维护权值树的连边</p><p>同时为了方便查询，还需要动态维护每棵形态树中的平衡树对应着权值树中的哪一棵平衡树</p><p>用$rt[x]$来维护这个信息，一定要保证形态树中每棵平衡树的树根的$rt[x]$是权值树对应的那棵平衡树的树根，这样才能正确修改和查询</p><h3 id="代码剖析-2"><a href="#代码剖析-2" class="headerlink" title="代码剖析"></a>代码剖析</h3><h4 id="1-权值树该怎么写怎么写，写一个正常的平衡树就行"><a href="#1-权值树该怎么写怎么写，写一个正常的平衡树就行" class="headerlink" title="1. 权值树该怎么写怎么写，写一个正常的平衡树就行"></a>1. 权值树该怎么写怎么写，写一个正常的平衡树就行</h4><h4 id="2-splay操作写法发生变化"><a href="#2-splay操作写法发生变化" class="headerlink" title="2. splay操作写法发生变化"></a>2. splay操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">q[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">int</span> i; <span class="keyword">for</span> (i = x; !isroot(i); i = fa[i]) q[++top] = fa[i];</span><br><span class="line">swap(rt[i], rt[x]); <span class="comment">//x将会变成平衡树的根，把原来根的rt值给x</span></span><br><span class="line"><span class="keyword">while</span> (top) pushdown(q[top--]); </span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ((ch[z][<span class="number">1</span>] == y) ^ (ch[y][<span class="number">1</span>] == x)) ? rotate(x) : rotate(y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-划重点！access操作写法"><a href="#3-划重点！access操作写法" class="headerlink" title="3. 划重点！access操作写法"></a>3. 划重点！access操作写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">VAL::split(rt[x], siz[x] - siz[ch[x][<span class="number">1</span>]], rt[x], rt[ch[x][<span class="number">1</span>]]);</span><br><span class="line"><span class="comment">//x的重儿子不再是ch[x][1]，把它的子树从x对应的平衡树中删去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">rt[x] = VAL::merge(rt[x], rt[i]); </span><br><span class="line"><span class="comment">//i成为x的重儿子，把它的子树加入x对应的平衡树</span></span><br><span class="line"><span class="comment">//注意merge顺序</span></span><br><span class="line">&#125;</span><br><span class="line">ch[x][<span class="number">1</span>] = i; pushup(x); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-makeroot操作写法发生变化"><a href="#3-makeroot操作写法发生变化" class="headerlink" title="3. makeroot操作写法发生变化"></a>3. makeroot操作写法发生变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">access(x); splay(x); rev(x); </span><br><span class="line">VAL::Rev(rt[x]); <span class="comment">//为了保证中序遍历相同，权值树也要翻转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-对于任何修改-查询，先split-x-y-，然后在权值树的对应平衡树上修改-查询"><a href="#4-对于任何修改-查询，先split-x-y-，然后在权值树的对应平衡树上修改-查询" class="headerlink" title="4. 对于任何修改/查询，先split(x,y)，然后在权值树的对应平衡树上修改/查询"></a>4. 对于任何修改/查询，先split(x,y)，然后在权值树的对应平衡树上修改/查询</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll v)</span> </span>&#123; split(x, y); VAL::Add(rt[y], v); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); VAL::Rev(rt[y]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Qsum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> VAL::sum[rt[y]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Qmax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> VAL::mx[rt[y]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Qmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> VAL::mn[rt[y]]; &#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="httpss://darkbzoj.tk/problem/3159">[bzoj3159]决战</a></p><h2 id="4-LCT维护边权信息"><a href="#4-LCT维护边权信息" class="headerlink" title="4. LCT维护边权信息"></a>4. LCT维护边权信息</h2><p>LCT怎么维护边权？LCT维护不了边权。</p><p>但是可以把边拆成点，然后就变成维护点权了（</p><p>多用于维护生成树</p><h3 id="思路讲解-3"><a href="#思路讲解-3" class="headerlink" title="思路讲解"></a>思路讲解</h3><p>新科技：KrusLCT算法$O(m\log m)$求最小生成树！</p><p>对于一条边$(u,v)$，新建一个点$w$，把$w$的点权设为边权，$u,v$的点权视题目设成正无穷，负无穷，$0$之类的，然后连边$(u,w)$，$(w,v)$</p><p>这样有什么好处呢？如果我想要查询$x$到$y$路径上的最大边权，只需要在LCT上查询$x$到$y$的最大点权就好了</p><p>所以可以口胡出一个最小生成树算法：</p><p>按顺序考虑每一条边$u,v$：若$u,v$不连通，则在LCT中连上$u,v$</p><p>否则找出LCT上$u,v$路径上的最大点权，若这个”点”权大于当前边$u,v$的边权，就把那条边断开，连上这条边</p><p>当然这就是LCT维护边权的一个应用，其实理解起来非常简单</p><h3 id="代码剖析-3"><a href="#代码剖析-3" class="headerlink" title="代码剖析"></a>代码剖析</h3><p>实在是没有什么好写的了 因为和普通的LCT没有什么区别，唯一的区别就是连边/删边要删两条？</p><h4 id="1-我到底应该删哪两条边？"><a href="#1-我到底应该删哪两条边？" class="headerlink" title="1. 我到底应该删哪两条边？"></a>1. 我到底应该删哪两条边？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 map&lt;pair&lt;int, int&gt; , int&gt; !!!</span></span><br></pre></td></tr></table></figure><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p><a href="httpss://www.luogu.com.cn/problem/P2387">[NOI2014]魔法森林</a><br><a href="httpss://www.luogu.com.cn/problem/P4172">[WC2006]水管局长</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于LCT的进阶应用&lt;/p&gt;
&lt;p&gt;不光是写算法思路，&lt;del&gt;因为已经有很多人写过了&lt;/del&gt;，更重要的是代码写法中的细节，不然LCT各种奇怪应用的细节够你一题调一个小时&lt;/p&gt;
&lt;p&gt;&lt;del&gt;本篇文章将助你考试一遍过样例！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;当然，还有一些基
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>长跑[BZOJ2959]</title>
    <link href="http://akdream.tk/post/f9901713.html/"/>
    <id>http://akdream.tk/post/f9901713.html/</id>
    <published>2020-08-06T12:38:27.000Z</published>
    <updated>2020-09-07T15:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加3000米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。为了让同学们更好地监督自己，学校推行了刷卡机制。学校中有$n$个地点，用$1$到$n$的整数表示，每个地点设有若干个刷卡机。有以下三类事件：</p><ol><li>修建了一条连接A地点和B地点的跑道。</li><li>A点的刷卡机台数变为了B。</li><li>进行了一次长跑。问一个同学从A出发，最后到达B最多可以刷卡多少次。具体的要求如下：</li></ol><p>当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从A地点到B地点能刷卡的最多次数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个正整数$n,m$，表示地点的个数和操作的个数。</p><p>第二行包含$n$个非负整数，其中第$i$个数为第个地点最开始刷卡机的台数。</p><p>接下来有$m$行，每行包含三个非负整数$P,A,B$，$P$为事件类型，$A,B$为事件的两个参数。</p><p>最初所有地点之间都没有跑道。</p><p>每行相邻的两个数之间均用一个空格隔开。表示地点编号的数均在$1$到$n$之间，每个地点的刷卡机台数始终不超过$10000$，$P=1,2,3$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出的行数等于第3类事件的个数，每行表示一个第3类事件。如果该情况下存在一种设定跑道方向的方案和路径的方案，可以到达，则输出最多可以刷卡的次数。如果A不能到达B，则输出$-1$。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>LCT维护边双连通分量</p><p>说是叫边双连通分量，其实就是在连边导致产生环时把环缩成一个点</p><p>例如此题，显然，如果进入了一个环的某个点，那么就一定能把这个环上所有点全部走完，然后再从任意一个点出去</p><p>所以可以把所有环缩成点，点权为环上所有点权之和，这样原图就变成了一棵树，每次直接查询A所在的环到B所在的环之间路径的点权和即可</p><p>然后此题就做完了</p><p>实现也非常简单，可以开并查集来记录两个点是否在同一个边双里，大部分操作与普通的LCT无异，但是有一些细节：</p><ol><li><p>LCT内部维护一个并查集记录两个点是否在同一个边双内，外部还要维护一个并查集记录两个点当前是否联通</p></li><li><p><code>access</code>时跳父亲要跳到find(fa[x])上，更改重儿子时还要记得把新的重儿子的父亲设为自己！</p></li><li><p>如果在两点之间连边时，两点已在同一棵树中，但不在同一个边双中，则要把两点之间的路径上的点合并为一个点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">split(x, y);</span><br><span class="line">q.push(y);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">Fa[find(u)] = y;</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">0</span>]) q.push(ch[u][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">1</span>]) q.push(ch[u][<span class="number">1</span>]);</span><br><span class="line">ch[u][<span class="number">0</span>] = ch[u][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//把儿子清零避免pushup时出错！</span></span><br><span class="line">&#125;</span><br><span class="line">val[y] = sum[y]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行任何操作时(例如<code>link</code>,<code>split</code>)，都是对find(x)进行修改，而不是$x$！</p></li></ol><p>更多细节详见代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">return</span> x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line"><span class="keyword">int</span> Fa[N], fa[N], ch[N][<span class="number">2</span>], sum[N], val[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]); tag[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>; tag[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) rev(ch[x][<span class="number">0</span>]); <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) rev(ch[x][<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], k = (ch[y][<span class="number">1</span>]==x);</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y;</span><br><span class="line">ch[x][!k] = y; fa[y] = x;</span><br><span class="line">pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ((ch[y][<span class="number">1</span>]==x)^(ch[z][<span class="number">1</span>]==y)) ? rotate(x) : rotate(y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = find(fa[x])) &#123;</span><br><span class="line">splay(x); ch[x][<span class="number">1</span>] = i; </span><br><span class="line"><span class="keyword">if</span> (i) fa[i] = x; </span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">access(x); splay(x); rev(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); access(y); splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">split(x, y);</span><br><span class="line">q.push(y);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">Fa[find(u)] = y;</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">0</span>]) q.push(ch[u][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[u][<span class="number">1</span>]) q.push(ch[u][<span class="number">1</span>]);</span><br><span class="line">ch[u][<span class="number">0</span>] = ch[u][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">val[y] = sum[y]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Fa[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Fa[x] == x ? x : Fa[x] = find(Fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = LCT::find(x), fy = LCT::find(y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> u = find(x), v = find(y);</span><br><span class="line"><span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">Fa[u] = v;</span><br><span class="line">LCT::link(fx, fy);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LCT::merge(fx, fy);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = read(), m = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = LCT::val[i] = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Fa[i] = LCT::Fa[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tp, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">tp = read(); x = read(); y = read();</span><br><span class="line"><span class="keyword">if</span> (tp == <span class="number">1</span>) &#123;</span><br><span class="line">Link(x, y);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tp == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> v = y - a[x];</span><br><span class="line">a[x] = y;</span><br><span class="line"><span class="keyword">int</span> fx = LCT::find(x);</span><br><span class="line">LCT::makeroot(fx);</span><br><span class="line">LCT::val[fx] += v;</span><br><span class="line">LCT::pushup(fx);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (find(x) != find(y)) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> fx = LCT::find(x), fy = LCT::find(y);</span><br><span class="line">LCT::split(fx, fy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCT::sum[fy]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>我们的CPU遭到攻击[LOJ558]</title>
    <link href="http://akdream.tk/post/53e0f243.html/"/>
    <id>http://akdream.tk/post/53e0f243.html/</id>
    <published>2020-08-06T12:36:25.000Z</published>
    <updated>2020-10-08T12:16:08.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个有$n$个点的森林，点有黑白两种颜色，初始时所有点都是白色，森林的每条边有边权，初始时这个森林有$m$条边。  </p><p>对这个森林进行$k$次操作，操作有三种：</p><ul><li><code>L u v w</code>：添加一条连接$u$和$v$，长度为$w$的边。</li><li><code>C u v</code>：删除连接$u$和$v$的边（保证存在）。</li><li><code>F u</code>：反转点$u$的颜色（黑变白，白变黑）。</li><li><code>Q u</code>：询问所有与$u$相连的黑点到$u$的距离之和。（相连指的是在同一连通块中）</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行三个非负整数，分别表示$n,m,k$。<br>以下$m$行，每行三个整数$u,v,w$，表示初始时有一条边连接$u$和$v$，长度为$w$。<br>以下$k$行，每行描述一个操作，格式如上所述。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个 Q 操作，单独一行输出一个整数表示答案。</p><p>保证任何时候这个图都是一个森林。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>LCT维护子树信息</p><p>假设现在需要用LCT维护原树中一个子树的$siz$</p><p>为了方便查询，一般会把原树中一条重链的顶端$x$这个点的子树信息存储在($x$在LCT中所在的二叉树的根)的位置<br><img src="https://akdream.tk/img/99_2.png" class="lazyload" data-srcset="https://akdream.tk/img/99_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如上图，原树中的$siz[1]$实际上存在LCT中的$siz[3]$里，而$siz[1]$里存的其实是$1$和$2$的权值和</p><p>但是一个点子树的$siz$不仅包含自己所在的那条重链啊 如何维护轻子树的大小？</p><p>很简单，我们记$lsiz[x]$表示LCT中$x$的所有轻子树的$siz$之和，这样$siz[x]$就等于$siz[lson]+siz[rson]+lsiz[x]+1$</p><p>如何维护$lsiz$呢？首先，在<code>link(x,y)</code>操作时$y$会变成$x$的一个新的轻儿子，所以$lsiz[x]$要加上$siz[y]$</p><p>其次，<code>access</code>时经过的点的重儿子变成了轻儿子，而某个轻儿子变成了重儿子，要注意更新$lsiz$</p><p>总之记住轻儿子发生变化的时候记得更新$lsiz$即可</p><p>但是实际应用中我们肯定不会用LCT去维护子树$siz$这种这么简单的东西的<del>(好像还真有，而且不少)</del>，所以来看看这道题</p><p>对于询问操作，其实我们可以通过LCT来做一个<code>makeroot(u)</code>的操作，这样每次询问就变成了询问所有黑点到根的距离之和了</p><p>对于每条边$u,v$，新建一个点$w$，把$w$的点权设为边权，把$u,v$的点权设为$0$，然后在LCT中连$u,w$和$w,v$，这样询问路径长度就变成询问路径上的点权和了</p><p><img src="https://akdream.tk/img/99_1.png" class="lazyload" data-srcset="https://akdream.tk/img/99_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对于点$x$如何统计答案？</p><p>这里是一张LCT的部分图，图中的箭头表示某一个点走到根应该沿什么方向走</p><p>由于LCT中左子树的点在原树中深度较小，所以应该向左走</p><p>我们设$sum[x]$表示LCT中$x$子树的点权和，$siz[x]$表示有多少个黑点，$lsiz[x]$表示$x$的所有轻子树中共有多少个黑点</p><p>不难发现，如果图中所有点想要从$x$开始走到$x$所在重链的顶端，那么需要走过的路径长度是$sum[lson]+val[x]$</p><p>有多少个点要走过去呢？$lsiz[x]+siz[rson]$个，如果$x$也是黑点就还要额外+1</p><p>所以这里$x$的答案就是$(sum[lson]+val[x])*(lsiz[x]+siz[rson]+color[x])$</p><p>累加答案也可以用类似的方法 即$ans[x]=ans[lson]+ans[rson]+lightans[x]$；$lightans[x]$就是轻子树的答案之和</p><p>然后是一些细节：</p><p>进行<code>access</code>时，某个重儿子变成了轻儿子，而轻儿子变成了重儿子，所以要记得更新$lsiz[x]$之类的东西</p><p>注意，执行<code>makeroot</code>操作时翻转了整棵LCT，所以我们不仅要记录从右子树向左子树走的答案，还要记录从左到右的答案，这样才能$O(1)$翻转</p><p>时间复杂度$O(n\log n)$</p><p>代码还算较为好写 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> cch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; cch &gt; <span class="string">'9'</span> || cch &lt; <span class="string">'0'</span>; cch = getchar()) <span class="keyword">if</span> (cch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; cch &lt;= <span class="string">'9'</span> &amp;&amp; cch &gt;= <span class="string">'0'</span>; cch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (cch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), num = -num;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">9</span>) write(num / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(num % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tot, m, q, ch[N][<span class="number">2</span>], fa[N];</span><br><span class="line">ll siz[N], lsiz[N], tp[N], sum[N], val[N], lans[N], rans[N], light[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">siz[x] = lsiz[x] + siz[ch[x][<span class="number">0</span>]] + siz[ch[x][<span class="number">1</span>]] + tp[x];</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">lans[x] = lans[ch[x][<span class="number">0</span>]] + lans[ch[x][<span class="number">1</span>]] + light[x];</span><br><span class="line">lans[x] += (sum[ch[x][<span class="number">0</span>]] + val[x]) * (lsiz[x] + siz[ch[x][<span class="number">1</span>]] + tp[x]);</span><br><span class="line">rans[x] = rans[ch[x][<span class="number">0</span>]] + rans[ch[x][<span class="number">1</span>]] + light[x];</span><br><span class="line">rans[x] += (sum[ch[x][<span class="number">1</span>]] + val[x]) * (lsiz[x] + siz[ch[x][<span class="number">0</span>]] + tp[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">swap(lans[x], rans[x]);</span><br><span class="line">tag[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) rev(ch[x][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) rev(ch[x][<span class="number">0</span>]);</span><br><span class="line">tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], k = (ch[y][<span class="number">1</span>] == x);</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][k] = ch[x][k^<span class="number">1</span>]; fa[ch[x][k^<span class="number">1</span>]] = y;</span><br><span class="line">ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) &#123;</span><br><span class="line">((ch[y][<span class="number">1</span>] == z) ^ (ch[z][<span class="number">1</span>] == y)) ? rotate(x) : rotate(y);</span><br><span class="line">&#125;</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">lsiz[x] -= (siz[i] - siz[ch[x][<span class="number">1</span>]]);</span><br><span class="line">light[x] -= (lans[i] - lans[ch[x][<span class="number">1</span>]]);</span><br><span class="line">ch[x][<span class="number">1</span>] = i; pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">access(x); splay(x); rev(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); makeroot(y);</span><br><span class="line">fa[x] = y;</span><br><span class="line">lsiz[y] += siz[x]; </span><br><span class="line">light[y] += lans[x];</span><br><span class="line">pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x); access(y); splay(y);</span><br><span class="line">ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>;</span><br><span class="line">pushup(y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; , <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m); read(q);</span><br><span class="line">tot = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">read(u); read(v); read(val[++tot]);</span><br><span class="line">link(u, tot); link(v, tot);</span><br><span class="line">mp[make_pair(u, v)] = mp[make_pair(v, u)] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'L'</span>) &#123;</span><br><span class="line">read(x); read(y); read(val[++tot]);</span><br><span class="line">link(x, tot); link(y, tot);</span><br><span class="line">mp[make_pair(x, y)] = mp[make_pair(y, x)] = tot;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">read(x); read(y);</span><br><span class="line"><span class="keyword">int</span> z = mp[make_pair(x, y)];</span><br><span class="line">mp[make_pair(x, y)] = mp[make_pair(y, x)] = <span class="number">0</span>;</span><br><span class="line">cut(x, z); cut(y, z);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'F'</span>) &#123;</span><br><span class="line">read(x);</span><br><span class="line">makeroot(x);</span><br><span class="line">tp[x] ^= <span class="number">1</span>;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">read(x);</span><br><span class="line">makeroot(x);</span><br><span class="line">write(lans[x]); </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一个有$n$个点的森林，点有黑白两种颜色，初始时所有点都是白色，森林的每条边有边权，初始时这个森林有$m$条边。  &lt;/
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>历史[ZJOI2018]</title>
    <link href="http://akdream.tk/post/5fefa37.html/"/>
    <id>http://akdream.tk/post/5fefa37.html/</id>
    <published>2020-08-06T12:34:59.000Z</published>
    <updated>2020-11-12T10:11:07.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述-amp-输入-输出格式"><a href="#题目描述-amp-输入-输出格式" class="headerlink" title="题目描述&amp;输入/输出格式"></a>题目描述&amp;输入/输出格式</h3><p><a href="httpss://www.luogu.com.cn/problem/P4338">[ZJOI2018]历史</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，没有修改时的答案可以使用树形DP解决</p><p><img src="https://akdream.tk/img/98_1.png" class="lazyload" data-srcset="https://akdream.tk/img/98_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>上图中，红色数字表示$a_x$，蓝色数字表示$x$子树的点权和$sum_x$</p><p>观察点$2$，显然只有$2,5,6$”崛起”时才有可能在$2$发动战争</p><p>显然，当操作顺序形如$5,2,5,6$时，会在$2$进行三次战争，为最大值。</p><p>再来看点$1$，其实我们可以把$2,5,6$三个点看作一个点，因为$2,5,6$两两的LCA都为$2$，若某时刻$6$在$5$之后一个崛起，则只会在$2$进行战争，而不会在$1$进行战争</p><p>于是此时可以把$sum_2$的点权看作$2$的点权，则此时一种最优的操作顺序为$2,1,2,3,2,2$，在$1$发动五次战争</p><p>接着再来找找规律，发现$sum_2=4$，而存在一种操作方案(即上面的$5,2,5,6$)使得相邻两次崛起的城市不相同，所以此时最多在$2$发动$sum_2-1$次战争</p><p>而$1$就不存在一种相邻元素不相同的操作方案了，因为来自$2$的操作次数过多</p><p>我们记$mx[u]=\max(\max_{u,v\in E} sum[v]\ , a[u])$，  </p><p>比如$mx[1]=\max(sum[2],sum[3],sum[4],a[1])=4$，  </p><p>$ans[x]$为最多在$x$发动多少次战争，则存在这样一个规律：  </p><p>若$mx[x]*2\ge sum[x]+1$，则$ans[x]=2*(sum[x]-mx[x])$<br>否则$ans[x]=sum[x]-1$</p><p>然后按照上面的式子进行DP即可拿到30分的暴力分</p><p>如何处理修改？</p><p>发现每个点$x$最多有一个儿子$y$满足$sum[y]*2\ge sum[x]+1$，我们定义这个儿子$y$为$x$的”重”儿子</p><p>注意 一个点$x$可能没有任何”重”儿子</p><p>维护一棵没有makeroot操作的伪LCT，初始时每个点$x$向”重”儿子连实边，向其他儿子连轻边</p><p>每次修改时，从被修改的点$x$开始向上access，沿途把某些满足上述条件的轻边修改为重边，把不满足条件的重边修改成轻边</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">CCF -= ans[x]; <span class="comment">//不要在意变量名</span></span><br><span class="line"><span class="keyword">if</span> (son[x]) ans[x] = <span class="number">2</span> * (sum[x] - sum[son[x]]); <span class="comment">//如果有"重"儿子 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ans[x] = <span class="number">2</span> * (sum[x] - a[x]); <span class="comment">//如果自己点权过大 </span></span><br><span class="line"><span class="keyword">else</span> ans[x] = sum[x] - <span class="number">1</span>; <span class="comment">//没有点权过大的点或子树 </span></span><br><span class="line">CCF += ans[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">a[x] += v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) sum[ch[x][<span class="number">0</span>]] += v, tag[ch[x][<span class="number">0</span>]] += v; </span><br><span class="line"><span class="comment">//给重链上的祖先打标记</span></span><br><span class="line"><span class="comment">//要打标记是因为没有makeroot,没法用split把路径分割出来 </span></span><br><span class="line"><span class="comment">//只能通过把重链打上标记来加 </span></span><br><span class="line"><span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = son[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = son[x]; !isroot(j); j = fa[j]) stk[++top] = fa[j];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]); </span><br><span class="line"><span class="comment">//pushdown确保sum[son[x]]的值正确 </span></span><br><span class="line"><span class="keyword">if</span> (sum[son[x]] * <span class="number">2</span> &lt;= sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = <span class="number">0</span>, son[x] = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//判断还有没有"重"儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F = findroot(i); </span><br><span class="line"><span class="comment">//找到轻子树的深度最小的节点 </span></span><br><span class="line"><span class="comment">//它的sum才是整棵轻子树的sum </span></span><br><span class="line"><span class="keyword">if</span> (sum[F] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = F, son[x] = F; </span><br><span class="line"><span class="comment">//找到新的"重"儿子</span></span><br><span class="line">calc(x); <span class="comment">//更新答案 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个<code>CCF</code>变量维护的就是答案</p><p>注释应该足够详细了 LCT中的其他操作，例如<code>findroot</code>和<code>pushdown</code>，与原来无异</p><p>关于此题时间复杂度</p><p>复杂度由于重边轻边的不确定性，非常玄学。。。也许是$O(1000ms)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ccf = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ccf &gt; <span class="string">'9'</span> || ccf &lt; <span class="string">'0'</span>; ccf = getchar()) <span class="keyword">if</span> (ccf == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ccf &lt;= <span class="string">'9'</span> &amp;&amp; ccf &gt;= <span class="string">'0'</span>; ccf = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ccf ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), num = -num;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">9</span>) write(num / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(num % <span class="number">10</span> +<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line">ll CCF, a[N], sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; </span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Main&#123;</span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], ch[N][<span class="number">2</span>];</span><br><span class="line">ll tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">CCF -= ans[x];</span><br><span class="line"><span class="keyword">if</span> (son[x]) ans[x] = <span class="number">2</span> * (sum[x] - sum[son[x]]); <span class="comment">//如果有"重"儿子 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ans[x] = <span class="number">2</span> * (sum[x] - a[x]); <span class="comment">//如果自己点权过大 </span></span><br><span class="line"><span class="keyword">else</span> ans[x] = sum[x] - <span class="number">1</span>; <span class="comment">//没有点权过大的点或子树 </span></span><br><span class="line">CCF += ans[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sum[x] = a[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">fa[y] = x; dfs(y);</span><br><span class="line">sum[x] += sum[y];</span><br><span class="line"><span class="keyword">if</span> (!son[x] || sum[son[x]] &lt; sum[y]) son[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum[son[x]] * <span class="number">2</span> &lt;= sum[x] + <span class="number">1</span>) son[x] = <span class="number">0</span>;</span><br><span class="line">calc(x);</span><br><span class="line">ch[x][<span class="number">1</span>] = son[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !tag[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) &#123;</span><br><span class="line">tag[ch[x][<span class="number">0</span>]] += tag[x];</span><br><span class="line">sum[ch[x][<span class="number">0</span>]] += tag[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">tag[ch[x][<span class="number">1</span>]] += tag[x];</span><br><span class="line">sum[ch[x][<span class="number">1</span>]] += tag[x];</span><br><span class="line">&#125;</span><br><span class="line">tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], k = (ch[y][<span class="number">1</span>]==x);</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y;</span><br><span class="line">ch[x][!k] = y; fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (!isroot(y)) ((ch[y][<span class="number">1</span>]==x)^(ch[z][<span class="number">1</span>]==y))?rotate(x):rotate(y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">a[x] += v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; x; i = x, x = fa[x]) &#123;</span><br><span class="line">splay(x);</span><br><span class="line">sum[x] += v;</span><br><span class="line"><span class="keyword">if</span> (ch[x][<span class="number">0</span>]) sum[ch[x][<span class="number">0</span>]] += v, tag[ch[x][<span class="number">0</span>]] += v; </span><br><span class="line"><span class="comment">//给重链上的祖先打标记</span></span><br><span class="line"><span class="comment">//要打标记是因为没有makeroot,没法用split把路径分割出来 </span></span><br><span class="line"><span class="comment">//只能通过把重链打上标记来加 </span></span><br><span class="line"><span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">stk[top=<span class="number">1</span>] = son[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = son[x]; !isroot(j); j = fa[j]) stk[++top] = fa[j];</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]); </span><br><span class="line"><span class="comment">//pushdown确保sum[son[x]]的值正确 </span></span><br><span class="line"><span class="keyword">if</span> (sum[son[x]] * <span class="number">2</span> &lt;= sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = <span class="number">0</span>, son[x] = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//判断还有没有"重"儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F = findroot(i); </span><br><span class="line"><span class="comment">//找到轻子树的深度最小的节点 </span></span><br><span class="line"><span class="comment">//它的sum才是整棵轻子树的sum </span></span><br><span class="line"><span class="keyword">if</span> (sum[F] * <span class="number">2</span> &gt; sum[x] + <span class="number">1</span>) ch[x][<span class="number">1</span>] = F, son[x] = F; </span><br><span class="line"><span class="comment">//找到新的"重"儿子</span></span><br><span class="line">calc(x); <span class="comment">//更新答案 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, CCF);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, w; i &lt;= m; i++) &#123;</span><br><span class="line">read(x); read(w);</span><br><span class="line">access(x, w); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, CCF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) &#123;</span><br><span class="line">read(u); read(v);</span><br><span class="line">addedge(u, v);</span><br><span class="line">&#125;</span><br><span class="line">Main::solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述-amp-输入-输出格式&quot;&gt;&lt;a href=&quot;#题目描述-amp-输入-输出格式&quot; class=&quot;headerlink&quot; title=&quot;题目描述&amp;amp;输入/输出格式&quot;&gt;&lt;/a&gt;题目描述&amp;amp;输入/输出格式&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
    
      <category term="Link-cut Tree" scheme="http://akdream.tk/tags/Link-cut-Tree/"/>
    
      <category term="树形DP" scheme="http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
</feed>
