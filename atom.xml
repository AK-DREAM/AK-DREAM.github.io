<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AK-dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://akdream.tk/"/>
  <updated>2021-01-04T14:33:27.220Z</updated>
  <id>http://akdream.tk/</id>
  
  <author>
    <name>AK-dream</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>战略游戏[SDOI2018]</title>
    <link href="http://akdream.tk/post/b441f3b6.html/"/>
    <id>http://akdream.tk/post/b441f3b6.html/</id>
    <published>2021-01-04T14:32:03.000Z</published>
    <updated>2021-01-04T14:33:27.220Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4606" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4606</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每次是试图摧毁一个城市和它连着的所有边，发现如果摧毁的不是一个割点那么就不会有任何影响，所以先建出原图的圆方树</p><p>每次选择了若干个关键节点，建出这些关键节点在圆方树上的虚树，有一个显而易见的结论：</p><p>答案即为虚树上(包括在虚树的某条边上)所有非关键节点的圆点个数</p><p>虚树上所有的叶子节点都一定是关键节点</p><p>断掉一个非关键的圆点一定会使得它子树里的一个叶子节点和其它子树外的关键节点不再连通</p><p>所以断掉一个非关键的圆点一定满足小Q要求</p><p>这题也不需要真的把虚树建出来，预处理圆方树上每个点到根的路径上有多少圆点，查询时只需要统计虚树的每条边上有多少圆点，最后再减掉<script type="math/tex">|S|</script>个关键圆点即为答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, ff = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ff = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * ff; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), num = -num;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">9</span>) write(num/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(num%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ttt, n, P, m, Q, K;</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">int</span> dfn[N], dfsx[N], low[N], tme, stk[N], top, pp[N]; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="keyword">int</span> d[N], p[N][<span class="number">21</span>], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_TU</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)); sz = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_OTHERS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[i].clear();</span><br><span class="line"><span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn)); <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low)); tme = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(stk, <span class="number">0</span>, <span class="keyword">sizeof</span>(stk)); top = <span class="number">0</span>; <span class="built_in">memset</span>(dfsx, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfsx));</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)); <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p)); <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initALL</span><span class="params">()</span> </span>&#123; init_TU(); init_OTHERS(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++tme; stk[++top] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">tarjan(y);</span><br><span class="line">low[x] = min(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (low[y] == dfn[x]) &#123;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>; ++n;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">z = stk[top--];</span><br><span class="line">e[z].push_back(n); e[n].push_back(z);</span><br><span class="line">&#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">e[x].push_back(n); e[n].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfsx[x] = ++tme; sum[x] = (x &lt;= P) + sum[fa];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; l) &lt;= n; l++) p[x][l] = p[p[x][l<span class="number">-1</span>]][l<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : e[x]) &#123;</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">d[y] = d[x] + <span class="number">1</span>; p[y][<span class="number">0</span>] = x; dfs(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; i--) <span class="keyword">if</span> (d[x]-(<span class="number">1</span>&lt;&lt;i)&gt;=d[y]) x = p[x][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; i--) <span class="keyword">if</span> (p[x][i] != p[y][i]) x = p[x][i], y = p[y][i];</span><br><span class="line"><span class="keyword">return</span> p[x][<span class="number">0</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dfsx[x] &lt; dfsx[y]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">top = <span class="number">0</span>; <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!top) &#123; stk[++top] = pp[i]; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> lca = LCA(stk[top], pp[i]);</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfsx[stk[top<span class="number">-1</span>]] &gt;= dfsx[lca]) &#123;</span><br><span class="line">ans += sum[stk[top]]-sum[stk[top<span class="number">-1</span>]]; --top;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (stk[top] != lca) &#123;</span><br><span class="line">ans += sum[stk[top]]-sum[lca]; stk[top] = lca;</span><br><span class="line">&#125;</span><br><span class="line">stk[++top] = pp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123; </span><br><span class="line">ans += sum[stk[top]]-sum[stk[top<span class="number">-1</span>]]; --top; </span><br><span class="line">&#125;</span><br><span class="line">ans += (stk[top] &lt;= P);</span><br><span class="line"><span class="keyword">return</span> ans - K;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(ttt);</span><br><span class="line"><span class="keyword">while</span> (ttt--) &#123;</span><br><span class="line">initALL();</span><br><span class="line">read(n); read(m); P = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">read(u); read(v); addedge(u, v);</span><br><span class="line">&#125;</span><br><span class="line">tarjan(<span class="number">1</span>); tme = <span class="number">0</span>; dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">read(Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">1</span>; kk &lt;= Q; kk++) &#123;</span><br><span class="line">read(K); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) read(pp[i]);</span><br><span class="line">sort(pp + <span class="number">1</span>, pp + K + <span class="number">1</span>, cmp);</span><br><span class="line">write(solve()); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4606&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4606&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题解
      
    
    </summary>
    
    
    
      <category term="强/双连通分量" scheme="http://akdream.tk/tags/%E5%BC%BA-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="虚树" scheme="http://akdream.tk/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最佳团体[JSOI2016]</title>
    <link href="http://akdream.tk/post/6d3463b1.html/"/>
    <id>http://akdream.tk/post/6d3463b1.html/</id>
    <published>2021-01-04T14:30:48.000Z</published>
    <updated>2021-01-04T14:34:46.617Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4322" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4322</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>网上怎么这么多<script type="math/tex">O(n^3\log n)</script>假做法啊。。。一条链就卡掉了</p><p>假设0号节点是根 建出表示依赖关系的图 发现正好有<script type="math/tex">n</script>条边且每个点的父亲都比它编号小所以正好是一棵树</p><p>那么原问题就是要在树上取一个包含根的性价比最高的连通块</p><p>看到”性价比”考虑使用01分数规划 假设<script type="math/tex">x_i\in \{0,1\}</script>表示第<script type="math/tex">i</script>个人选不选 答案是<script type="math/tex">ans</script> 那么</p><script type="math/tex; mode=display">\dfrac{\sum x_iP_i}{\sum x_iS_i} \le ans</script><p>挪一下 </p><script type="math/tex; mode=display">\sum x_i(P_i-S_i*ans) \le 0</script><p>二分答案<script type="math/tex">mid</script>，如果上方左式可以大于0说明答案小了 否则答案大了</p><p>如何求出左式的最大值？</p><p>考虑dp，求出原树的dfs序，设<script type="math/tex">f[i][j]</script>表示考虑到dfs序为<script type="math/tex">i</script>的点，共选了<script type="math/tex">j</script>个点</p><p>设<script type="math/tex">V_i=P_i-S_i*mid</script>，<script type="math/tex">a_i</script>是dfs序为<script type="math/tex">i</script>的点的<script type="math/tex">V</script>值</p><p>可以选择这个点并且进入它的子树，即 </p><script type="math/tex; mode=display">f[i+1][j] = \max(f[i+1][j], f[i][j-1]+a_i)</script><p>可以不选这个点，这样它子树里的所有点都不能选了，所以直接跳到下一个在它子树外的点，假设它的dfs序是<script type="math/tex">k</script>：</p><script type="math/tex; mode=display">f[k][j]=\max(f[k][j],f[i][j])</script><p>这种按dfs序dp的方式常见于求包含根的连通块</p><p>先预处理一下每个点的dfs序和下一个它子树外的点的dfs序编号 </p><p>一次dp是<script type="math/tex">O(n^2)</script>的，总时间<script type="math/tex">O(n^2\log n)</script></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, ff = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ff = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * ff; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, a[N], b[N], dfn[N], ed[N], tme = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">double</span> p[N], f[N][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++tme;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i]; <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>; dfs(y, x); </span><br><span class="line">&#125;</span><br><span class="line">ed[dfn[x]] = tme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">p[dfn[i]] = <span class="number">1.0</span> * a[i] - k * b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) f[i][j] = <span class="number">-1e9</span>;</span><br><span class="line">&#125; </span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">f[ed[i]+<span class="number">1</span>][j] = max(f[ed[i]+<span class="number">1</span>][j], f[i][j]);</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) f[i+<span class="number">1</span>][j] = max(f[i+<span class="number">1</span>][j], f[i][j<span class="number">-1</span>] + p[i]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> f[n+<span class="number">1</span>][m];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(m); read(n); ++m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">read(b[i]); read(a[i]); read(x);</span><br><span class="line">addedge(x, i);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e4</span>, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-5</span>) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">l = mid + <span class="number">1e-7</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> r = mid - <span class="number">1e-7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4322&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4322&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题解
      
    
    </summary>
    
    
    
      <category term="01分数规划" scheme="http://akdream.tk/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>按位或[HAOI2015]</title>
    <link href="http://akdream.tk/post/9fcbf1e0.html/"/>
    <id>http://akdream.tk/post/9fcbf1e0.html/</id>
    <published>2021-01-04T14:28:35.000Z</published>
    <updated>2021-01-04T14:45:53.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>刚开始你有一个数字<script type="math/tex">0</script>，每一秒钟你会随机选择一个<script type="math/tex">[0,2^n-1]</script>的数字，与你手上的数字进行或（C++, C 的 |， Pascal 的 or）操作。选择数字<script type="math/tex">i</script> 的概率是<script type="math/tex">p[i]</script>（保证<script type="math/tex">0\le p[i]\le 1,\ \sum p[i]=1</script>） 问期望多少秒后，你手上的数字变成<script type="math/tex">2^n-1</script>。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>min-max容斥：</p><script type="math/tex; mode=display">\max(S)=\sum\limits_{T \subset S \cap T \neq \varnothing} (-1)^{|T|+1}\min(T)</script><p>.<script type="math/tex">\max(S)</script>表示集合<script type="math/tex">S</script>的最大元素         </p><p> 证明大概就是除了<script type="math/tex">\max(S)</script>剩一个，其他都加加减减消掉了。。。          </p><p> 如果我们设<script type="math/tex">E(x)</script>表示二进制中<script type="math/tex">x</script>这一位第一次变成<script type="math/tex">1</script>的期望步数，则有       </p><p>.<script type="math/tex">\max\limits_{x\in S}E(x)=\sum\limits_{T \subset S \cap T \neq \varnothing} (-1)^{|T|+1}\min\limits_{y\in T}E(y)</script>                     </p><p>.<script type="math/tex">\max\limits_{x\in S}E(x)</script>也就是<script type="math/tex">S</script>中所有位都变成<script type="math/tex">1</script>的期望步数，<script type="math/tex">\min\limits_{x\in S}E(x)</script>即为<script type="math/tex">S</script>中至少有<script type="math/tex">1</script>位变成<script type="math/tex">1</script>的期望步数                       </p><p>考虑后者怎么求，一步就使得<script type="math/tex">S</script>中至少有<script type="math/tex">1</script>位变成<script type="math/tex">1</script>的概率为<script type="math/tex">(1-\sum\limits_{i\cap S=\varnothing} p[i])</script>，所以期望步数就是<script type="math/tex">\dfrac{1}{1-\sum\limits_{i\cap S=\varnothing} p[i]}</script>                            </p><p>假设<script type="math/tex">S_0</script>为<script type="math/tex">S</script>的补集，那么<script type="math/tex">\sum\limits_{i\cap S=\varnothing} p[i]=\sum\limits_{i\subseteq S_0} p[i]</script>，右式可以用FMT或者状压DP在<script type="math/tex">O(n2^n)</script>的复杂度中求得 那么<script type="math/tex">\min\limits_{x\in S}E(x)=\dfrac{1}{1-\sum\limits_{i\subseteq S_0} p[i]}</script>然后套用上面的minmax容斥即可 答案即为<script type="math/tex">\max\limits_{x\in S}E(2^n-1)</script></p><p>无解判断方法很多也很好判断就不说了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">double</span> *F)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = i&lt;&lt;<span class="number">1</span>, j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); j += p) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line"><span class="keyword">double</span> x = F[j+k], y = F[j+k+i];</span><br><span class="line">F[j+k] = x; F[j+k+i] = x + y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line">FWT(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1.0</span>-a[((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^i] &lt;= <span class="number">1e-8</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"INF"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (__builtin_popcount(i) &amp; <span class="number">1</span>) ans += <span class="number">1.0</span> / (<span class="number">1.0</span>-a[((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^i]);</span><br><span class="line"><span class="keyword">else</span> ans -= <span class="number">1.0</span> / (<span class="number">1.0</span>-a[((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.10lf"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;刚开始你有一个数字&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;，每一秒钟你会随机选择一个&lt;scrip
      
    
    </summary>
    
    
    
      <category term="FWT" scheme="http://akdream.tk/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>无归岛[HNOI2009]</title>
    <link href="http://akdream.tk/post/61f3b981.html/"/>
    <id>http://akdream.tk/post/61f3b981.html/</id>
    <published>2021-01-04T14:27:21.000Z</published>
    <updated>2021-01-04T14:46:24.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P4410" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4410</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>原图显然是一个仙人掌(似乎还有些别的性质 但是其实没什么必要)</p><p>先考虑树的情况，题意即为不能同时选择相邻的两点，设<script type="math/tex">f[x][0/1]</script>表示选/不选<script type="math/tex">x</script>时，<script type="math/tex">x</script>子树内的最大战斗力</p><script type="math/tex; mode=display">f[x][0]=\max\limits_{y\in son(x)} (\max(f[y][0],f[y][1]))</script><script type="math/tex; mode=display">f[x][1]=\max\limits_{y\in son(x)} (f[y][0]) + A_x</script><p>在环上如何dp？</p><p>在环上找到一个点<script type="math/tex">x</script>并从那里把环断开，分<script type="math/tex">x</script>选或<script type="math/tex">x</script>不选两种，分别进行dp来推出<script type="math/tex">f[x][0/1]</script>即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, a[N], f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], stk[N], top, c[N], tot, tme;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a0 = <span class="number">0</span>, a1 = <span class="number">0</span>, b0 = <span class="number">0</span>, b1 = <span class="number">-0x3f3f3f3f</span>; <span class="comment">//不选x</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">a0 = max(b0, b1) + f[c[i]][<span class="number">0</span>]; a1 = b0 + f[c[i]][<span class="number">1</span>];</span><br><span class="line">b0 = a0; b1 = a1;</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">0</span>] += max(b0, b1);</span><br><span class="line">a0 = a1 = <span class="number">0</span>; b0 = <span class="number">-0x3f3f3f3f</span>; b1 = <span class="number">0</span>; <span class="comment">//选择x</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">a0 = max(b0, b1) + f[c[i]][<span class="number">0</span>]; a1 = b0 + f[c[i]][<span class="number">1</span>];</span><br><span class="line">b0 = a0; b1 = a1;</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] += b0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++tme;</span><br><span class="line">stk[++top] = x;</span><br><span class="line">f[x][<span class="number">1</span>] = a[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">tarjan(y);</span><br><span class="line">low[x] = min(low[x], low[y]);</span><br><span class="line"><span class="keyword">if</span> (dfn[x] == low[y]) &#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>; tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">u = stk[top--];</span><br><span class="line">c[++tot] = u;</span><br><span class="line">&#125; <span class="keyword">while</span> (u != y);</span><br><span class="line">solve(x);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[x] &lt; low[y]) &#123;</span><br><span class="line">f[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">addedge(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">tarjan(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4410&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="仙人掌" scheme="http://akdream.tk/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"/>
    
  </entry>
  
  <entry>
    <title>仓库建设[ZJOI2007]</title>
    <link href="http://akdream.tk/post/4cbc3c7c.html/"/>
    <id>http://akdream.tk/post/4cbc3c7c.html/</id>
    <published>2020-12-13T11:53:33.000Z</published>
    <updated>2020-12-22T11:44:52.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P2120" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2120</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设<script type="math/tex">S_i=\sum\limits_{j=1}^{i} p_j</script>，<script type="math/tex">T_i=\sum\limits_{j=1}^{i} p_j*a_j</script></p><p> $S_i$即为前<script type="math/tex">i</script>个工厂的物品总数，<script type="math/tex">T_i</script>为前<script type="math/tex">i</script>个工厂都把所有物品运到工厂<script type="math/tex">1</script>的总花费（虽然不能运到仓库<script type="math/tex">1</script>）</p><p>设<script type="math/tex">f_i</script>表示把前<script type="math/tex">i</script>个工厂的物品都运到仓库里且在<script type="math/tex">i</script>工厂处建立仓库的最小花费</p><p>则有<script type="math/tex">f_i=\min\limits_{1\le j < i} f_j + a_i * (S_i-S_j) - (T_i-T_j) + c_i</script></p><p>变化一下式子就是<script type="math/tex">(f_j+T_j)=a_i*S_j+(F_i-a_i*S_i-c_i+T_i)</script></p><p>使用斜率优化即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head, tail, q[N];</span><br><span class="line">ll a[N], p[N], c[N], dp[N], sum[N], sum2[N], K[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getx</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gety</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dp[id] + sum2[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getx(x) == getx(y) ? <span class="number">1e15</span> : <span class="number">1.0</span> * (gety(x) - gety(y)) / (getx(x) - getx(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]); read(p[i]); read(c[i]);</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + p[i];</span><br><span class="line">sum2[i] = sum2[i<span class="number">-1</span>] + a[i] * p[i];</span><br><span class="line">K[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">q[head=tail=<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[head], q[head+<span class="number">1</span>]) &lt; K[i]) head++;</span><br><span class="line"><span class="keyword">int</span> j = q[head];</span><br><span class="line">dp[i] = dp[j] + a[i] * (sum[i] - sum[j]) - (sum2[i] - sum2[j]) + c[i];</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[tail<span class="number">-1</span>], q[tail]) &gt; slope(q[tail], i)) tail--;</span><br><span class="line">q[++tail] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2120&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="斜率优化" scheme="http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>征途[SDOI2016]</title>
    <link href="http://akdream.tk/post/d391bdf.html/"/>
    <id>http://akdream.tk/post/d391bdf.html/</id>
    <published>2020-12-11T13:48:10.000Z</published>
    <updated>2020-12-22T10:29:06.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Pine 开始了从<script type="math/tex">S</script>地到<script type="math/tex">T</script>地的征途。</p><p>从<script type="math/tex">S</script>地到<script type="math/tex">T</script>地的路可以划分成<script type="math/tex">h</script>段，相邻两段路的分界点设有休息站。<br>Pine 计划用<script type="math/tex">m</script>天到达<script type="math/tex">T</script>地。除第<script type="math/tex">n</script>天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。<br>Pine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。</p><p>帮助 Pine 求出最小方差是多少。</p><p>设方差是<script type="math/tex">v</script>，可以证明，<script type="math/tex">v*m^2</script>是一个整数。为了避免精度误差，输出结果时输出<script type="math/tex">v*m^2</script>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个数<script type="math/tex">n</script>、<script type="math/tex">m</script>。<br>第二行<script type="math/tex">n</script>个数，表示<script type="math/tex">n</script>段路的长度。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>CCF不考DP了(悲)</del></p><p>假设有一个序列<script type="math/tex">a_1\sim a_n</script>，平均数是<script type="math/tex">v</script>，那么它的方差就是<script type="math/tex">\dfrac{\sum\limits_{i=1}^{n}(a_i)^2}{n}-v^2</script></p><p>所以原问题就变成：将<script type="math/tex">n</script>个数分为<script type="math/tex">m</script>段，假设第<script type="math/tex">i</script>段内的所有数之和为<script type="math/tex">b_i</script>，求<script type="math/tex">\sum\limits_{i=1}^{m} (b_i)^2</script>的最小值</p><p>设<script type="math/tex">f_{i,j}</script>表示将前<script type="math/tex">j</script>个数分成<script type="math/tex">i</script>段的最小平方和</p><p>容易得到转移方程：<script type="math/tex">f_{i,j} = \min\limits_{0\le k<j} (f_{i-1,k} + (S_j-S_k)^2)</script>，<script type="math/tex">S</script>表示前缀和</p><p>变换一下得到<script type="math/tex">f_{i-1,k}+(S_k)^2=2*S_j*S_k+(f_{i,j}-(S_j)^2)</script></p><p>这样就可以进行斜率优化，维护<script type="math/tex">f_{i-1}</script>的凸壳来转移出<script type="math/tex">f_i</script></p><p>由于<script type="math/tex">S</script>数组单调递增，所以直接用单调队列维护下凸壳即可</p><p>时间复杂度<script type="math/tex">O(nm)</script></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, head, tail, q[N];</span><br><span class="line">ll a[N], f[<span class="number">2</span>][N], x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x[p] == x[q]) <span class="keyword">return</span> <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1.0</span> * (y[p] - y[q]) / (x[p] - x[q]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]); a[i] += a[i<span class="number">-1</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> o = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">o = i &amp; <span class="number">1</span>;</span><br><span class="line">head = <span class="number">1</span>; tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[tail<span class="number">-1</span>], q[tail]) &gt; slope(q[tail], j)) tail--;</span><br><span class="line">q[++tail] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[head], q[head+<span class="number">1</span>]) &lt; (<span class="keyword">double</span>)a[j]) head++;</span><br><span class="line"><span class="keyword">int</span> k = q[head];</span><br><span class="line">f[o][j] = f[!o][k] + (a[j]-a[k]) * (a[j]-a[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">f[!o][j] = <span class="number">0</span>;</span><br><span class="line">x[j] = <span class="number">2</span> * a[j]; y[j] = f[o][j] + a[j] * a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[m&amp;<span class="number">1</span>][n] * m - a[n] * a[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Pine 开始了从&lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;地到&lt;script type=&quot;mat
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="斜率优化" scheme="http://akdream.tk/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>区间[NOI2016]</title>
    <link href="http://akdream.tk/post/ba8b5f94.html/"/>
    <id>http://akdream.tk/post/ba8b5f94.html/</id>
    <published>2020-12-04T11:31:41.000Z</published>
    <updated>2020-12-04T11:33:44.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数轴上有<script type="math/tex">n</script>个闭区间从<script type="math/tex">1</script>至<script type="math/tex">n</script>编号，第<script type="math/tex">i</script>个闭区间为<script type="math/tex">[l_i,r_i]</script></p><p>现在要从中选出<script type="math/tex">m</script>个区间，使得这<script type="math/tex">m</script>个区间共同包含至少一个位置。换句话说，就是使得存在一个<script type="math/tex">x</script>，使得对于每一个被选中的区间<script type="math/tex">[l_i,r_i]</script></p><p>对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间<script type="math/tex">[l_i,r_i]</script>的长度定义为<script type="math/tex">(r_i-l_i)</script>即等于它的右端点的值减去左端点的值。</p><p>求所有合法方案中最小的花费。如果不存在合法的方案，输出<script type="math/tex">−1</script>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数，分别代表<script type="math/tex">n</script>和<script type="math/tex">m</script>。</p><p>第<script type="math/tex">2</script>到第<script type="math/tex">(n + 1)</script>行，每行两个整数表示一个区间，第<script type="math/tex">(i + 1)</script>行的整数<script type="math/tex">l_i, r_i</script>分别代表第<script type="math/tex">i</script>个区间的左右端点。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数表示答案。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将区间按长度从小到大排序，记为<script type="math/tex">p_1,p_2,\cdots p_n</script></p><p>假设最后选的区间中长度最短和最长的分别是<script type="math/tex">p_l, p_r</script>，那么答案就是<script type="math/tex">p_r</script>的长度减<script type="math/tex">p_l</script>的长度，在<script type="math/tex">p_{l+1}\sim p_{r-1}</script>中选哪些并不会给答案造成影响</p><p>判定一个答案是否合法的方法：假设现在有一个长度为1e9的序列，每个位置的值都是<script type="math/tex">0</script>，如果我们对于<script type="math/tex">p_l \sim p_r</script>的每个区间，都把这个区间中的每个位置+1，那么操作完后如果有某个位置的值大于<script type="math/tex">m</script>，那么就说明这个位置被<script type="math/tex">p_l \sim p_r</script>中的至少<script type="math/tex">m</script>个区间覆盖了，也就是说存在一种合法方案只选择了<script type="math/tex">m</script>个<script type="math/tex">p_l\sim p_r</script>中的区间，就可以用 (<script type="math/tex">p_r</script>的长度减<script type="math/tex">p_l</script>的长度) 来更新答案</p><p>如果选择的最短区间为<script type="math/tex">p_l</script>时，使得代价最小的方案中选择的的最长区间是<script type="math/tex">p_r</script>，那么选择的最短区间固定为<script type="math/tex">p_{l+1}</script>时，此时的最优方案选择的最长区间一定比<script type="math/tex">p_r</script>长</p><p>证明：假设最短区间固定为<script type="math/tex">p_{l+1}</script>时，此时的最优方案选择的最长区间是<script type="math/tex">p_k</script>，且<script type="math/tex">k < r</script>，那么按照上面那个判合法性的方法，选择<script type="math/tex">p_l\sim p_k</script>也一定是合法的，矛盾</p><p>所以可以使用双指针的方法，每次固定左指针(即最短区间)，然后移动右指针找到第一个满足条件的最长区间，然后更新答案</p><p>上面的判定合法的方法需要区间加，查询全局最大值，用线段树维护即可</p><p>为方便线段树维护，可以先给区间端点进行离散化</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, len[N], srt[N], mx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intv</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(intv x, intv y)</span> </span>&#123; <span class="keyword">return</span> x.r-x.l &lt; y.r-y.l; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fCuCcFk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) srt[++mx] = p[i].l, srt[++mx] = p[i].r;</span><br><span class="line">sort(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>);</span><br><span class="line">mx = unique(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>) - srt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">len[i] = p[i].r - p[i].l + <span class="number">1</span>;</span><br><span class="line">p[i].l = lower_bound(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>, p[i].l) - srt;</span><br><span class="line">p[i].r = lower_bound(srt+<span class="number">1</span>, srt+mx+<span class="number">1</span>, p[i].r) - srt; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> mx, tag;</span><br><span class="line">&#125; tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">tr[ind].mx = tr[ind].tag = <span class="number">0</span>; <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(ind&lt;&lt;<span class="number">1</span>, l, mid); build(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[ind].tag) <span class="keyword">return</span>; <span class="keyword">int</span> v = tr[ind].tag; tr[ind].tag = <span class="number">0</span>;</span><br><span class="line">tr[ind&lt;&lt;<span class="number">1</span>].mx += v; tr[ind&lt;&lt;<span class="number">1</span>].tag += v;</span><br><span class="line">tr[ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx += v; tr[ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">tr[ind].mx += v; tr[ind].tag += v; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(ind); <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update(ind&lt;&lt;<span class="number">1</span>, l, mid, x, y, v);</span><br><span class="line"><span class="keyword">if</span> (mid &lt; y) update(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, v);</span><br><span class="line">tr[ind].mx = max(tr[ind&lt;&lt;<span class="number">1</span>].mx, tr[ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(p[i].l); read(p[i].r);</span><br><span class="line">&#125;</span><br><span class="line">sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">fCuCcFk(); <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, mx);</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, mx, p[<span class="number">1</span>].l, p[<span class="number">1</span>].r, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; n &amp;&amp; tr[<span class="number">1</span>].mx &lt; m) &#123;</span><br><span class="line">j++;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, mx, p[j].l, p[j].r, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">1</span>].mx &gt;= m) ans = min(ans, len[j] - len[i]);</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, mx, p[i].l, p[i].r, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在数轴上有&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个闭区间从&lt;script type=&quot;math
      
    
    </summary>
    
    
    
      <category term="线段树" scheme="http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>文件路径[BOI2015]</title>
    <link href="http://akdream.tk/post/832a20d9.html/"/>
    <id>http://akdream.tk/post/832a20d9.html/</id>
    <published>2020-12-04T11:27:34.000Z</published>
    <updated>2020-12-04T11:33:44.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P6843" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P6843</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目实际在求这样一个东西：给定一棵树和边权，你可以在树中加上一条长为<script type="math/tex">S</script>的有向边</p><p>对于每个叶子节点问：是否能构造出一条从根节点出发以该节点为终点的长为<script type="math/tex">K</script>的路径</p><p>设有一个叶子节点<script type="math/tex">x</script></p><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>根到<script type="math/tex">x</script>的路径长等于`$K$</p><p>那显然答案就是 <code>Yes</code></p><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p>走了一次附加的有向边使得路径长为`$K$</p><p>考虑这条有向边的终点在哪里：由于走过这条有向边之后还要从它的终点走到<script type="math/tex">x$，所以有向边的终点一定要是`$x</script>的一个祖先</p><p>记点<script type="math/tex">p</script>的深度是<script type="math/tex">d_p$，那么假设走了一条`$p\rightarrow q</script>的有向边，总长度就是`$d_p+S+(d_x-d_q)$</p><p>其中，$p$<code>是树上的任意一个非叶子节点，$q$</code>必须是<script type="math/tex">x</script>的祖先</p><p>要判断是否有<script type="math/tex">p,q</script>满足<script type="math/tex">d_p+S+(d_x-d_q)=K</script>，可以考虑枚举<script type="math/tex">q</script>，这样就确定了<script type="math/tex">d_x-d_q</script>，预处理出<script type="math/tex">d_p+S</script>可以取哪些值(存在一个 <code>bool</code> 数组里)，如果存在某个<script type="math/tex">p</script>使得<script type="math/tex">d_p+S=K-(d_x-d_q)</script>那么<script type="math/tex">x</script>的答案就是 <code>Yes</code></p><p>一个例子</p><p><img src="https://akdream.tk/img/113_1.png" class="lazyload" data-srcset="https://akdream.tk/img/113_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.png"></p><h4 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h4><p>当然，可能可以走很多次附加的有向边(在一个环上一直绕)</p><p>如果一条有向边可以走很多次，那么必须满足它的终点是起点的祖先</p><p>又因为终点要是<script type="math/tex">x</script>的祖先，所以现在需要找到这样一条路径<script type="math/tex">p\rightarrow q</script>：</p><p>满足<script type="math/tex">d_x+t*(d_p-d_q+S)=K</script>(<script type="math/tex">t</script>为一个正整数)</p><p>其中<script type="math/tex">q</script>是<script type="math/tex">x</script>的祖先，<script type="math/tex">p</script>是<script type="math/tex">q</script>子树中一个非叶子节点</p><p>在dfs时，每到一个非叶子节点就再把以它为根的子树遍历一遍，把所有合法的<script type="math/tex">d_p-d_q+S</script>存在 <code>bool</code> 数组里，并在回溯时清除贡献</p><p>枚举<script type="math/tex">K-d_x</script>的所有约数，判断是否有满足条件的<script type="math/tex">d_p-d_q+S</script>即可</p><p><img src="https://akdream.tk/img/113_2.png" class="lazyload" data-srcset="https://akdream.tk/img/113_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>时间复杂度<script type="math/tex">O((n+m)^2+m\sqrt{K})</script></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, ff = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ff = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ccf, K, S, a[N], d[N];</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">int</span> ok[<span class="number">1000005</span>], ok2[<span class="number">1000005</span>], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x]+S &lt;= <span class="number">1000000</span> &amp;&amp; x &lt;= ccf) ok[d[x]+S]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">d[y] = d[x] + a[y];</span><br><span class="line">dfs1(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> rt, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; ccf) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> now = d[x] - d[rt] + S;</span><br><span class="line"><span class="keyword">if</span> (now &lt;= <span class="number">1000000</span>) ok2[now] += v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y != fa) dfs3(y, x, rt, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d[x] == K) &#123;</span><br><span class="line">ans[x] = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = stk[i];</span><br><span class="line"><span class="keyword">int</span> v = d[x] - d[y];</span><br><span class="line"><span class="keyword">if</span> (v &lt;= K &amp;&amp; ok[K-v]) ans[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[x] &lt; K) &#123;</span><br><span class="line"><span class="keyword">int</span> v = K - d[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= v; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (v % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ok2[i] || ok2[v/i]) ans[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; ccf) &#123;</span><br><span class="line">solve(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">stk[++top] = x;</span><br><span class="line">dfs3(x, fa, x, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y != fa) dfs2(y, x);</span><br><span class="line">&#125;</span><br><span class="line">dfs3(x, fa, x, <span class="number">-1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(ccf); read(K); read(S); S++;</span><br><span class="line">swap(ccf, n); n += ccf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p; i &lt;= n; i++) &#123;</span><br><span class="line">read(p); read(a[i]); a[i]++;</span><br><span class="line">addedge(p, i);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ccf + <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">puts</span>(ans[i]?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6843&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>仙人掌[ZJOI2017]</title>
    <link href="http://akdream.tk/post/75f14cc2.html/"/>
    <id>http://akdream.tk/post/75f14cc2.html/</id>
    <published>2020-11-29T14:18:56.000Z</published>
    <updated>2020-11-29T14:31:31.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P3687" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3687</a></p><p><del>题面里咋还有张图啊，就不放这了</del></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，如果原图不是仙人掌，显然答案为<script type="math/tex">0</script></p><p>如果原图是一棵树，那么我们可以选择若干条边不相交的路径，如果某条路径长度大于一，就将路径的两个端点间加一条边，那么这样构造出来的图一定是一个仙人掌</p><p>所以原问题实际在问有多少种方案用若干条边不相交的路径覆盖原图</p><p>设<script type="math/tex">f[x]</script>表示考虑<script type="math/tex">x</script>的子树内和<script type="math/tex">x</script>到父亲的那条边，有多少种方案把这些边划分成若干条路径</p><p>假设<script type="math/tex">x</script>有<script type="math/tex">k</script>个儿子，那么如果<script type="math/tex">x</script>不为根，就有<script type="math/tex">k+1</script>条从<script type="math/tex">x</script>连出的边，这些边可以两两配对连接形成穿过<script type="math/tex">x</script>的路径，也可以不配对</p><p>设<script type="math/tex">p_i</script>表示将<script type="math/tex">i</script>条边两两配对(或不配对)有多少种方案，考虑最后一条边是否和另一条边配对，易得递推式：<script type="math/tex">p_i=p_{i-1}+(i-1)*p_{i-2}</script></p><p>那么对于树边，有<script type="math/tex">f[x]=(\prod\limits_{y\in son(x)} f[y]) * p_{k+1}</script>(如果<script type="math/tex">x</script>是根那么最后乘的应该是<script type="math/tex">p_k</script>)</p><p>如果原图不是树而是仙人掌呢？</p><p>考虑仙人掌上的环，从上面那个”路径覆盖”的角度思考，发现环的要求就是环上的边不能被路径覆盖，而树边必须被覆盖</p><p>所以直接把所有环上的边删掉得到一个森林，把每棵树的根的答案乘在一起就是最终答案了</p><p>当然这样做有点麻烦，维护一个<script type="math/tex">g[x]</script>表示只考虑<script type="math/tex">x</script>的子树内的边 (<script type="math/tex">x</script>到父亲的边可能是环边)，有多少种方案把这些边划分成若干条路径</p><p>然后在碰到环时特殊处理一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, ff = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ff = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> ttt, n, m;</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], stk[N], top, c[N], tot, tme;</span><br><span class="line">ll f[N], g[N], p[N];</span><br><span class="line"><span class="keyword">bool</span> tmp[N], flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) head[i] = <span class="number">0</span>; sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dfn[i] = low[i] = <span class="number">0</span>, f[i] = <span class="number">0</span>;</span><br><span class="line">    tme = top = <span class="number">0</span>; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是仙人掌</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) tmp[c[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = c[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[x]; j; j = pre[j]) <span class="keyword">if</span> (tmp[to[j]]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != tot * <span class="number">2</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) tmp[c[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//维护DP值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) f[X] = f[X] * g[c[i]] % mod; <span class="comment">//c[1]~c[tot-1]为环上除x之外的其它点</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tme; stk[++top] = x;</span><br><span class="line">    f[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x] = min(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] == low[y]) &#123;</span><br><span class="line">                <span class="keyword">int</span> z = <span class="number">0</span>; tot = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    z = stk[top--];</span><br><span class="line">                    c[++tot] = z;</span><br><span class="line">                &#125; <span class="keyword">while</span> (z != y);</span><br><span class="line">                c[++tot] = x;</span><br><span class="line">                <span class="keyword">if</span> (tot &gt; <span class="number">2</span>) solve(x); <span class="comment">//找到环</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    f[x] = f[x] * f[y] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    g[x] = f[x] * p[cnt] % mod;</span><br><span class="line">    f[x] = f[x] * p[cnt+(x!=<span class="number">1</span>)] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(ttt);</span><br><span class="line">    p[<span class="number">0</span>] = p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">500000</span>; i++) p[i] = (p[i<span class="number">-1</span>] + p[i<span class="number">-2</span>] * (i<span class="number">-1</span>) % mod) % mod;</span><br><span class="line">    <span class="keyword">while</span> (ttt--) &#123;</span><br><span class="line">        read(n); read(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">            read(u); read(v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[<span class="number">1</span>]);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3687&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="树形DP" scheme="http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>寻找车位[Code+#3]</title>
    <link href="http://akdream.tk/post/e3b2cbf5.html/"/>
    <id>http://akdream.tk/post/e3b2cbf5.html/</id>
    <published>2020-11-28T14:10:40.000Z</published>
    <updated>2020-11-28T14:13:28.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>access_globe 有一个巨大的停车场，这个停车场有<script type="math/tex">N</script>行，每行有<script type="math/tex">M</script>个车位。为了美观，access_globe 在建立这个停车场时，规定这个停车场必须是长条形的，即<script type="math/tex">N\ge M</script>。每个车位都是一个正方形的区域。</p><p>最近，access_globe 正在为抽不到 Missing Poster 而苦恼，因此他请你帮他维护这个停车场。你需要支持两个事件：</p><ul><li>一辆车停到某一个车位中，或一辆车从某个车位开走</li><li>查询一个矩形区域内最大的只包含空车位的正方形区域</li></ul><p>如果你能帮 access_globe 高效地解决这个问题，access_globe 一定会好好奖励你的。</p><script type="math/tex; mode=display">N \times M \le 4*10^6,Q\le 2000</script><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>线段树神题</p><p>对<script type="math/tex">N</script>这一维开一棵线段树，然后线段树上的每个节点维护3个数组：<code>lm[M]</code>, <code>rm[M]</code>, <code>val[M]</code></p><p>假设线段树的某个节点表示的是<script type="math/tex">[l,r]</script>这段区间 (<script type="math/tex">1\le l\le r\le N</script>) ，那么这个节点的 <code>lm[i]</code> 表示第<script type="math/tex">i</script>列中，从第<script type="math/tex">l</script>个车位开始往后数有多少个连续的<script type="math/tex">1</script>，<code>rm[i]</code> 表示从第<script type="math/tex">r</script>个车位往前数有多少个连续的`$1$</p><p>这个节点的 <code>val[i]</code> 表示如果以第<script type="math/tex">i</script>列作为正方形的右边界，且正方形的上下边界在<script type="math/tex">[l,r]</script>内 (这里的<script type="math/tex">l,r</script>实际上是竖着的一段区间) ，全1的正方形的边长最大是多少</p><p><code>lm[M]</code> 和 <code>rm[M]</code> 都很容易通过左右儿子的值求出来，如何求出 <code>val[M]</code> ?</p><p>假设<script type="math/tex">mid=\dfrac{l+r}{2}</script>，先考虑这个正方形的上下边界都在<script type="math/tex">[l,mid]</script>或者都在`$[mid+1,r]$</p><p>显然此时 <code>val[i]</code> 等于左右儿子的 <code>val[i]</code> 的较大值</p><p>如果正方形跨过了<script type="math/tex">mid</script>呢?</p><p>假设我们现在已经知道了正方形的上下边界在<script type="math/tex">[l,r]</script>内，如果正方形的右边界在<script type="math/tex">i</script>，左边界在<script type="math/tex">j</script>(即边长为<script type="math/tex">i-j+1</script>) ，如何判断是否存在合法的正方形？</p><p><img src="https://akdream.tk/img/111_1.png" class="lazyload" data-srcset="https://akdream.tk/img/111_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>如图 我们对于<script type="math/tex">[j,i]</script>中的每一列，找到从第<script type="math/tex">mid</script>行开始有多少个向上延申的连续的<script type="math/tex">1</script>(蓝线)，同理找到向下延申的，然后分别找到向上和向下最少的 (绿线) ， 记为<script type="math/tex">a,b</script>，如果<script type="math/tex">i-j+1\le a+b</script>，就表示一定存在合法的正方形</p><p>容易发现如果以<script type="math/tex">i</script>为右边界可以构成的最大全1正方形的左边界在<script type="math/tex">j</script>，那么以<script type="math/tex">i+1</script>为右边界可以构成的最大全1正方形的左边界不可能小于<script type="math/tex">j</script></p><p>所以这个每次查询区间<script type="math/tex">[j,i]</script>的最小值可以使用单调队列来维护，枚举右端点<script type="math/tex">i</script>并且维护另外一个指针<script type="math/tex">j</script>，如果此时<script type="math/tex">i-j+1</script>大于上下两个最小值之和，那就说明不满足条件，<script type="math/tex">j</script>继续右移，找到第一个满足条件的<script type="math/tex">j</script>，那么<script type="math/tex">[l,r]</script>这个线段树节点的 <code>val[i]</code> 就等于<script type="math/tex">j</script></p><p>这样就通过合并左右儿子两个区间算出了当前节点的值了</p><p>注意这样 <code>pushup</code> 一次的复杂度是<script type="math/tex">O(m)</script>的，所以进行一次修改或查询</p><p>那么怎么查询答案呢？</p><p>假设询问是<script type="math/tex">x1,y1,x2,y2</script>，将<script type="math/tex">[x1,x2]</script>在线段树上分为<script type="math/tex">\log N</script>个区间，然后在线段树上合并这些区间即可</p><p>一种比较聪明的做法是用一个没有用的节点暂时储存一下这<script type="math/tex">\log N</script>个区间合并得到的答案，最后只需要找出这个临时节点 <code>val[y1]</code> 到 <code>val[y2]</code> 之间的最大值即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Q;</span><br><span class="line"><span class="keyword">int</span> len[N&lt;&lt;<span class="number">2</span>], q1[N], q2[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A[N];</span><br><span class="line"><span class="keyword">int</span> lm[N&lt;&lt;<span class="number">2</span>], rm[N&lt;&lt;<span class="number">2</span>], val[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">o</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x*m+y; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1 = <span class="number">1</span>, h2 = <span class="number">1</span>, t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span>; r &lt;= m; r++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; rm[o(ls,q1[t1])] &gt; rm[o(ls,r)]) t1--;</span><br><span class="line">        q1[++t1] = r;</span><br><span class="line">        <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; lm[o(rs,q2[t2])] &gt; lm[o(rs,r)]) t2--;</span><br><span class="line">        q2[++t2] = r;</span><br><span class="line">        <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; rm[o(ls,q1[h1])] + lm[o(rs,q2[h2])] &lt; r-l+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1[h1] == l) h1++;</span><br><span class="line">            <span class="keyword">if</span> (q2[h2] == l) h2++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        val[o(ind,r)] = max(max(val[o(ls,r)], val[o(rs,r)]), r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) lm[o(ind,i)] = lm[o(ls,i)] + (lm[o(ls,i)]==len[ls]?lm[o(rs,i)]:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) rm[o(ind,i)] = rm[o(rs,i)] + (rm[o(rs,i)]==len[rs]?rm[o(ls,i)]:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    len[ind] = r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) lm[o(ind,i)] = rm[o(ind,i)] = val[o(ind,i)] = A[l][i];</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ind&lt;&lt;<span class="number">1</span>, l, mid); build(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    merge(ind, ind&lt;&lt;<span class="number">1</span>, ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        lm[o(ind,y)] = rm[o(ind,y)] = val[o(ind,y)] = v;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) update(ind&lt;&lt;<span class="number">1</span>, l, mid, x, y, v);</span><br><span class="line">    <span class="keyword">else</span> update(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, v);</span><br><span class="line">    merge(ind, ind&lt;&lt;<span class="number">1</span>, ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        merge(<span class="number">0</span>, <span class="number">0</span>, ind); <span class="comment">//用0号点暂时储存答案</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) query(ind&lt;&lt;<span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) query(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n); read(m); read(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i].resize(m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        read(A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tp, x, y, a, b; i &lt;= Q; i++) &#123;</span><br><span class="line">        read(tp);</span><br><span class="line">        <span class="keyword">if</span> (tp == <span class="number">0</span>) &#123;</span><br><span class="line">            read(x); read(y);</span><br><span class="line">            <span class="keyword">if</span> (A[x][y]) update(<span class="number">1</span>, <span class="number">1</span>, n, x, y, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> update(<span class="number">1</span>, <span class="number">1</span>, n, x, y, <span class="number">1</span>);</span><br><span class="line">            A[x][y] = <span class="number">1</span> - A[x][y];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(x); read(y); read(a); read(b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                lm[o(<span class="number">0</span>,j)] = rm[o(<span class="number">0</span>,j)] = val[o(<span class="number">0</span>,j)] = <span class="number">0</span>; <span class="comment">//用0号点暂时储存答案</span></span><br><span class="line">            &#125;</span><br><span class="line">            query(<span class="number">1</span>, <span class="number">1</span>, n, x, a);</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= b; j++) &#123;</span><br><span class="line">                ans = max(ans, min(j-y+<span class="number">1</span>, val[o(<span class="number">0</span>, j)]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;access_globe 有一个巨大的停车场，这个停车场有&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script
      
    
    </summary>
    
    
    
      <category term="线段树" scheme="http://akdream.tk/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>快餐店[NOI2013]</title>
    <link href="http://akdream.tk/post/500a1398.html/"/>
    <id>http://akdream.tk/post/500a1398.html/</id>
    <published>2020-11-28T14:06:43.000Z</published>
    <updated>2020-11-28T14:10:02.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。</p><p>快餐店的顾客分布在城市 C 的<script type="math/tex">N</script>个建筑中，这<script type="math/tex">N</script>个建筑通过恰好<script type="math/tex">N</script>条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。</p><p>现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑一棵树上答案是怎样的：答案应该是树直径的<script type="math/tex">\dfrac{1}{2}</script>，即快餐店取在直径一半处，证明如下：</p><p>如果快餐店不在直径的中点处，而是在某点<script type="math/tex">X</script>，假设直径是<script type="math/tex">A\rightarrow B</script>，长度为<script type="math/tex">d</script> ，那么树上离<script type="math/tex">X</script>最远的点要么是<script type="math/tex">A</script>要么是<script type="math/tex">B</script>，只有<script type="math/tex">\operatorname{dis}(A,X)<\dfrac{d}{2}</script>且<script type="math/tex">\operatorname{dis}(B,X)<\dfrac{d}{2}</script>时<script type="math/tex">X</script>才更优，两式相加得<script type="math/tex">\operatorname{dis}(A,X)+\operatorname{dis}(B,X)<\operatorname{dis}(A,B)</script>，显然这是不可能的</p><p>那么如果是基环树要怎么做呢？</p><p>考虑断掉基环树环上的某条边，使其变成一棵树，求出这棵树的直径长为<script type="math/tex">d</script>，则表示有一种取址方案使得答案为`$\dfrac{d}{2}$</p><p>所以最终答案就是枚举环上断哪条边求得的所有<script type="math/tex">\dfrac{d}{2}</script>的最小值</p><p>那么现在需要快速算出断某条边后树的直径</p><p>先找出环上的所有点，按顺序给每个点标号<script type="math/tex">1\sim cnt</script></p><p>首先，对于不经过环的那些路径，无论怎么断边它的长度都不会变，可以先在环上每个点的子树里dfs求得其中最长的那条，记为<code>P</code></p><p>算出环上每个点距离环上第1个点的距离，记为<code>len[i]</code>，算出环上每个点子树内距它最远的点到它的距离，记为<code>mx[i]</code></p><p>预处理出<code>bef[i]</code><script type="math/tex">=\max\limits_{1\le j\le i}</script><code>len[j]+mx[j]</code>，<code>aft[i]</code><script type="math/tex">=\max\limits_{i\le j\le cnt}</script><code>(len[cnt]-len[j])+mx[j]</code></p><p><code>bef2[i]</code><script type="math/tex">=\max\limits_{1\le j < k \le i}</script><code>mx[j]+mx[k]+(len[k]-len[j])</code>，<code>aft2[i]</code><script type="math/tex">=\max\limits_{i\le j < k \le cnt}</script><code>mx[j]+mx[k]+(len[k]-len[j])</code></p><p>记环上第一个点和最后一个点之间的边的长度是<code>D</code> </p><p>假设断开的是环上第<script type="math/tex">i</script>个点到第<script type="math/tex">i+1</script>个点之间的边，那么此时树的直径长就是<script type="math/tex">\max(</script><code>bef2[i], aft2[i+1], bef[i]+aft[i+1]+D, P</code>$)$</p><p>求出所有直径长取min，再除以2即为答案</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E(i) int i = head[x]; i; i = pre[i]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, _f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) _f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * _f;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head[N], to[N&lt;&lt;<span class="number">1</span>], pre[N&lt;&lt;<span class="number">1</span>], sz;</span><br><span class="line">ll val[N&lt;&lt;<span class="number">1</span>], ans, Ans, len[N], Mx[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, c[N], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N], onc[N], flg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; val[sz] = w;</span><br><span class="line">pre[++sz] = head[v]; head[v] = sz; to[sz] = u; val[sz] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getcir</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">stk[++top] = x; vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (E(i)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (vis[y]) &#123;</span><br><span class="line">flg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (stk[top] != y) c[++tot] = stk[top--];</span><br><span class="line">c[++tot] = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">getcir(y, x);</span><br><span class="line"><span class="keyword">if</span> (flg) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[N], bef[N], aft[N], bef2[N], aft2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">//求直径 </span></span><br><span class="line"><span class="keyword">for</span> (E(i)) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (y == fa || onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x);</span><br><span class="line">ans = max(ans, f[y] + f[x] + val[i]); <span class="comment">//直径不在环上</span></span><br><span class="line">f[x] = max(f[x], f[y] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">dfs1(c[id], <span class="number">0</span>);</span><br><span class="line">Mx[id] = f[c[id]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll now = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">bef[i] = max(bef[i<span class="number">-1</span>], now + Mx[i]);</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) bef2[i] = max(bef2[i<span class="number">-1</span>], mx + now + Mx[i]);</span><br><span class="line">mx = max(mx, Mx[i] - now);</span><br><span class="line">now += len[i];</span><br><span class="line">&#125; </span><br><span class="line">now = mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; i--) &#123;</span><br><span class="line">aft[i] = max(aft[i+<span class="number">1</span>], now + Mx[i]);</span><br><span class="line"><span class="keyword">if</span> (i &lt; tot) aft2[i] = max(aft2[i+<span class="number">1</span>], mx + now + Mx[i]);</span><br><span class="line">mx = max(mx, Mx[i] - now);</span><br><span class="line">now += len[i<span class="number">-1</span>];</span><br><span class="line">&#125; </span><br><span class="line">Ans = min(Ans, bef2[tot]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) &#123;</span><br><span class="line">ll ccf = max(max(bef2[i], aft2[i+<span class="number">1</span>]), bef[i] + aft[i+<span class="number">1</span>] + len[tot]);</span><br><span class="line">ccf = max(ccf, ans);</span><br><span class="line">Ans = min(Ans, ccf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); Ans = <span class="number">114514114514114514</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v; ll w;</span><br><span class="line">read(u); read(v); read(w);</span><br><span class="line">addedge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">getcir(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) onc[c[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = c[i];</span><br><span class="line"><span class="keyword">for</span> (E(j)) <span class="keyword">if</span> (to[j] == c[i%tot+<span class="number">1</span>]) len[i] = val[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">solve(i);</span><br><span class="line">&#125;</span><br><span class="line">DP();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, Ans / <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快
      
    
    </summary>
    
    
    
      <category term="动态规划" scheme="http://akdream.tk/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形DP" scheme="http://akdream.tk/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇[CSP2020]</title>
    <link href="http://akdream.tk/post/8edb7c14.html/"/>
    <id>http://akdream.tk/post/8edb7c14.html/</id>
    <published>2020-11-12T09:55:28.000Z</published>
    <updated>2020-11-12T10:28:40.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.luogu.com.cn/problem/P7078" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7078</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考场上开T4的时候只有40~50分钟了 努力思索了10分钟想到一个结论(中途想假了一次) </p><p>然后发现部分分还挺多：70分</p><h4 id="70分"><a href="#70分" class="headerlink" title="70分"></a>70分</h4><p>简单说说70分做法：先假设游戏一直进行，那么就可以用<code>set</code>把每轮游戏是谁吃谁处理出来</p><p>显然游戏共有<script type="math/tex">n-1</script>轮，从最后一轮开始向前扫，假设当前到第<script type="math/tex">i</script>轮，是<script type="math/tex">A</script>吃掉<script type="math/tex">B</script>，记<script type="math/tex">t</script>为第<script type="math/tex">i\sim n-1</script>轮中第一次有蛇叫停是在第几轮(初始时$t=n$)，同时记录<script type="math/tex">d_x</script>表示若游戏一直进行则第<script type="math/tex">x</script>条蛇在第<script type="math/tex">d_x</script>轮被吃掉，那么如果<script type="math/tex">d_A < t</script>就表示<script type="math/tex">A</script>如果这一轮吃了<script type="math/tex">B</script>，那它在后面一定会被吃掉，所以<script type="math/tex">A</script>必须叫停，更新<script type="math/tex">t</script>为<script type="math/tex">i</script>，否则不更新</p><p>最终答案即为<script type="math/tex">n-t+1</script>，复杂度<script type="math/tex">O(Tn\log n)</script></p><h4 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h4><p>如何<script type="math/tex">O(n)</script>把上面<code>set</code>求的东西求出来？</p><p>这题的做法和NOIP2016蚯蚓比较像，通过维护多个普通队列来存取最小/最大值</p><p>具体地说，维护两个普通队列，一个初始时装着排好序的所有元素，一个初始为空</p><p>每次操作时，分别找出两个队列的队头元素，取其中较小者即是当前的最小元素，最大元素同理取队尾</p><p>然后把最大减最小的那个元素放到第二个队列的队头</p><p>只要两个队列都具有单调性，这个做法就是对的</p><p>显然只出不进的队列1时刻具有单调性 考虑队列2</p><p>整个<script type="math/tex">n-1</script>轮分为两个阶段 假设第<script type="math/tex">i</script>轮场上最大的蛇是<script type="math/tex">A_i</script>，最小是<script type="math/tex">B_i</script></p><p><strong>1.<script type="math/tex">A_i\ge 2*B_i</script></strong></p><p>那么显然有<script type="math/tex">A_{i+1}\le A_i,B{i+1}\ge B_i</script></p><p>假设<script type="math/tex">C_i</script>是<script type="math/tex">A_i</script>吃<script type="math/tex">B_i</script>得到的那条蛇，那么有<script type="math/tex">C_i\ge C_{i+1}</script></p><p>当<script type="math/tex">C_i>C_{i+1}</script>时，队列2就是有单调性的了</p><p>当<script type="math/tex">C_i=C_{i+1}</script>时，一定有<script type="math/tex">A_i=A_{i+1}</script>，那么要不<script type="math/tex">A_i</script>和<script type="math/tex">A_{i+1}</script>两次其实都是标号相同的那条蛇(即<script type="math/tex">C_i</script>作为<script type="math/tex">A_{i+1}</script>被弹出队列2了)，要不<script type="math/tex">A_i</script>的标号大于<script type="math/tex">A_{i+1}</script>也就是说<script type="math/tex">C_i</script>的标号大于<script type="math/tex">C_{i+1}</script>，两种情况都满足队列2的单调性</p><p>至此证明了阶段1中队列2是有单调性的</p><p><strong>2.<script type="math/tex">A_i<2*B_i</script></strong></p><p>第一次满足这个条件时，看作是进入了阶段2</p><p>假设第一次进入阶段2时，共有<script type="math/tex">m</script>条蛇，从小到大为<script type="math/tex">a_1,a_2,\cdots a_m</script></p><p>那么第一次吃完后的蛇长度为<script type="math/tex">a_m-a_1<a_1</script></p><p>第二次一定是<script type="math/tex">a_{m-1}-(a_m-a_1)\le a_1</script></p><p>第三次是<script type="math/tex">a_{m-2}</script>减掉第二次得到的那个值，也是<script type="math/tex"><a_1</script></p><p>假设第<script type="math/tex">i</script>次减出来的值是<script type="math/tex">v_i</script>，由于队列1中已没有长度<strong>小于</strong><script type="math/tex">a_1</script>的蛇，不难看出第<script type="math/tex">i+1</script>次的最短蛇的长度一定是<script type="math/tex">v_i</script>(但是编号不一定相同)</p><p>继续推下去，易证对于所有的奇数次，有<script type="math/tex">v_i<a_1</script>，而偶数次有<script type="math/tex">v_i\le a_1</script></p><p>对于奇数次<script type="math/tex">i</script>，第<script type="math/tex">i+1</script>轮中最小值必然是<script type="math/tex">v_i</script>，那么就相当于<script type="math/tex">v_i</script>进入队列2后又马上被弹出了，依然不影响队列2单调性</p><p>换个说法 也就是说<script type="math/tex">A_i</script>在吃完<script type="math/tex">B_i</script>后，下一轮马上作为<script type="math/tex">B_{i+1}</script>被吃掉</p><p>对于偶数次<script type="math/tex">i</script>，若第<script type="math/tex">i+1</script>轮中最小蛇是<script type="math/tex">v_i</script>则同上</p><p><strong>如果<script type="math/tex">v_i=a_1</script>并且此时有和它长度相同但编号更小的蛇呢？</strong></p><p>假设第一次出现这种情况是在第<script type="math/tex">k</script>轮，<script type="math/tex">A_k</script>吃完<script type="math/tex">B_k</script>后长度变成<script type="math/tex">v_k</script>，由于有比<script type="math/tex">v_k</script>更小的作为<script type="math/tex">B_{k+1}</script>，那么<script type="math/tex">B_{k+1}</script>就一定不和<script type="math/tex">A_k</script>是同一条蛇了</p><p>那么只有<script type="math/tex">k+1</script>和<script type="math/tex">k+2</script>两轮的最大蛇都选择要吃时，$A_k$`才有可能在后续被吃掉</p><p>而由于<script type="math/tex">k+1</script>是奇数，所以如果<script type="math/tex">A_{k+2}</script>在第<script type="math/tex">k+2</script>轮选择吃的话，吃掉的一定是此时长度小于<script type="math/tex">a_1</script>的<script type="math/tex">A_{k+1}</script></p><p>这样一来，<script type="math/tex">A_{k+1}</script>在<script type="math/tex">k+1</script>轮肯定就会选择叫停，所以 “<script type="math/tex">k+1</script>和<script type="math/tex">k+2</script>两轮的最大蛇都选择要吃” 是不可能的</p><p>所以<script type="math/tex">A_k</script>在后续一定不会被吃掉，它就一定会选择吃<script type="math/tex">B_k</script></p><p>注意到此时<script type="math/tex">k-1</script>也是奇数，那么<script type="math/tex">A_{k-1}</script>和<script type="math/tex">B_k</script>就是同一条蛇，所以<script type="math/tex">A_{k-1}</script>在第<script type="math/tex">k-1</script>轮一定叫停</p><p>写了这么多，就是为了证明出现这种情况时，游戏在第<script type="math/tex">k-1</script>轮就一定会终止，那么就从第<script type="math/tex">k-2</script>轮往回扫就行了</p><p>这样我们就<script type="math/tex">O(n)</script>算出了上面<code>set</code>算的东西，然后再套用上面的70分做法即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ttt, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N], eaten[N], h1, t1, h2, t2;</span><br><span class="line">pii q1[N], q2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">getmn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((h2 &gt; t2) || (h1 &lt;= t1 &amp;&amp; q1[t1] &lt; q2[t2])) <span class="keyword">return</span> q1[t1--];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> q2[t2--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">getmx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((h2 &gt; t2) || (h1 &lt;= t1 &amp;&amp; q1[h1] &gt; q2[h2])) <span class="keyword">return</span> q1[h1++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> q2[h2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(eaten, <span class="number">0</span>, <span class="keyword">sizeof</span>(eaten));</span><br><span class="line"><span class="keyword">int</span> ans = st + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i; i--) &#123;</span><br><span class="line">eaten[c[i]] = i;</span><br><span class="line"><span class="keyword">if</span> (eaten[b[i]] &amp;&amp; eaten[b[i]] &lt; ans) &#123;</span><br><span class="line">ans = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">h1 = h2 = <span class="number">1</span>; t1 = t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) q1[++t1] = mp(a[i], i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">pii mx = getmx(), mn = getmn();</span><br><span class="line">pii nowmn = min(h1&lt;=t1?q1[t1]:mp(inf, inf), h2&lt;=t2?q2[t2]:mp(inf, inf));</span><br><span class="line">pii now = mp(mx.fi-mn.fi, mx.se);</span><br><span class="line">b[i] = mx.se; c[i] = mn.se;</span><br><span class="line"><span class="keyword">if</span> (now &lt; nowmn) flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (flag &amp;&amp; now &gt;= nowmn) &#123;</span><br><span class="line">calc(i<span class="number">-2</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">q2[++t2] = now;</span><br><span class="line">&#125; </span><br><span class="line">calc(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(ttt); ttt--;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ttt; i++) &#123;</span><br><span class="line">read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x, y; j &lt;= k; j++) &#123;</span><br><span class="line">read(x); read(y);</span><br><span class="line">a[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7078&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数调用[CSP2020]</title>
    <link href="http://akdream.tk/post/aad8b10f.html/"/>
    <id>http://akdream.tk/post/aad8b10f.html/</id>
    <published>2020-11-09T13:17:58.000Z</published>
    <updated>2020-11-10T09:29:39.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P7077" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7077</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>第一眼看像是数据结构题？</p><p>后来发现这题压根不用数据结构</p><p>考虑对于给出的操作建一个图：对于所有操作3，按顺序向它调用的函数连边，这样会得到一个DAG</p><p>对于乘法操作，在最后给所有数组元素乘上就好了，关键在于每个加法操作最后乘了一个多大的系数</p><p>假设整个数组只有一个元素，对它依次执行：+1, *3, +2, *2</p><p>那么+1操作实际上就有一个2*3=6的系数，+2有2的系数，所以假设原来这个元素是$x$，那它最后会是$6x+1\times 6+ 2\times 2$</p><p>发现一个加法操作带的系数就等于它后面的所有乘法操作之积，所以可以倒着进行操作，一边记录已进行的所有乘法操作的积是多少，这样就能计算出每次加法操作带的系数是多少</p><p>至此，只含1,2操作的情况就处理完了，接下来考虑3操作</p><p>对于图上的每个点(代表着一种操作)，维护一个mul属性，表示执行一次这个操作会给累计的积乘上多少</p><p>对于1类操作，它的mul=1；对于2类操作，它的mul就等于它要乘上的值；而对于3类操作，它的mul等于它直接连向的所有点的mul之积</p><p><img src="https://akdream.tk/img/108_1.png" class="lazyload" data-srcset="https://akdream.tk/img/108_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如图，点2的mul为2，点3的mul为3，所以点1的mul为6，那么执行一次操作1就会让前面执行过的所有的加法操作再乘上6的系数</p><p>按照拓扑序倒序扫一遍或者直接dfs即可处理出mul</p><p>然后倒着进行$q$次操作，就可以求得每次操作(类型1或3)带着多少系数，记作sum，然后再把类型3的节点的sum下传到它所包含的类型1节点即可</p><p>但是有些类型3的操作既包含加法又包含乘法怎么办？</p><p><img src="https://akdream.tk/img/108_2.png" class="lazyload" data-srcset="https://akdream.tk/img/108_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>考虑这样一张图 假设编号为1的操作的sum是$x$，那么+2这个操作的sum应该额外增加$3x$，同理+1的sum应增加$12x$</p><p>所以下传sum时，假设一个点$x$的sum是$S$，它的儿子是$y_1,y_2,\cdots y_k$，<br>那么$y_i$的sum就应该增加$S$乘上$y_{i+1}\sim y_k$的mul之积</p><p>最后，让数组的每个元素乘上所有$q$次操作的mul，再遍历所有加法操作计算应该加多少即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, F[N];</span><br><span class="line"><span class="keyword">int</span> head[N], pre[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], sz, inde[N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">pre[++sz] = head[u]; head[u] = sz; to[sz] = v; inde[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oper</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tp, p;</span><br><span class="line">ll v, mul, sum; </span><br><span class="line">&#125; b[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ord[N], bnbn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123; <span class="comment">//拓扑排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (!inde[i]) q.push(i);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">ord[++bnbn] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = pre[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line">inde[y]--;</span><br><span class="line"><span class="keyword">if</span> (!inde[y]) q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmul</span><span class="params">()</span> </span>&#123; <span class="comment">//计算节点的mul</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = ord[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[x]; j; j = pre[j]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[j];</span><br><span class="line">b[x].mul = b[x].mul * b[y].mul % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsum</span><span class="params">()</span> </span>&#123; <span class="comment">//下传节点的sum</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = ord[i]; ll now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[x]; j; j = pre[j]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[j];</span><br><span class="line">b[y].sum = (b[y].sum + b[x].sum * now % mod) % mod;</span><br><span class="line">now = now * b[y].mul % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]); </span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">read(b[i].tp);</span><br><span class="line"><span class="keyword">if</span> (b[i].tp == <span class="number">1</span>) &#123;</span><br><span class="line">read(b[i].p); read(b[i].v);</span><br><span class="line">b[i].mul = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i].tp == <span class="number">2</span>) &#123;</span><br><span class="line">read(b[i].v); b[i].mul = b[i].v;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">read(b[i].p); b[i].mul = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= b[i].p; j++) &#123;</span><br><span class="line">read(x);</span><br><span class="line">addedge(i, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">toposort(); </span><br><span class="line">getmul();</span><br><span class="line">read(Q); ll now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) read(F[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Q; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = F[i]; b[x].sum = (b[x].sum + now) % mod;</span><br><span class="line">now = now * b[x].mul % mod;</span><br><span class="line">&#125;</span><br><span class="line">getsum();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = a[i] * now % mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i].tp == <span class="number">1</span>) &#123;</span><br><span class="line">a[b[i].p] = (a[b[i].p] + b[i].v * b[i].sum % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7077&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="拓扑排序" scheme="http://akdream.tk/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>动物园[CSP2020]</title>
    <link href="http://akdream.tk/post/ad950814.html/"/>
    <id>http://akdream.tk/post/ad950814.html/</id>
    <published>2020-11-09T13:17:32.000Z</published>
    <updated>2020-11-09T13:20:51.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.luogu.com.cn/problem/P7076" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7076</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这应该是最签到的一题了吧</p><p>饲料共有$c$种，1e8存不下，先对饲料编号进行重新标号</p><p>注意这里并不需要进行离散化(排序去重)，由于$q_i$互不相同，所以只需要把第$i$种饲料的编号看作$i$即可 (什么叫签到题啊)</p><p>首先对于已有的动物，先处理出$K$位中哪些位有动物是1</p><p>然后扫一遍所有要求找出哪些饲料必买</p><p>最后再扫一遍所有要求算出$K$位中哪些位可以是1</p><p>假设有$x$位可以是1，那答案就是$2^x-n$</p><p><strong>注意点：</strong></p><ol><li>答案可能爆<code>long long</code> 需要<code>unsigned long long</code></li><li>如果$n=m=0,k=64$，那么答案为$2^64$，会爆<code>unsigned long long</code>。。。需要特判</li></ol><p>感觉会在2处挂5pts。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, c, k, p[N];</span><br><span class="line">ull a[N], S, ans, fst;</span><br><span class="line"><span class="keyword">bool</span> buy[N], ok[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebuy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((S&gt;&gt;p[i])&amp;<span class="number">1</span>) buy[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveans</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) ok[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!buy[i]) ok[p[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="keyword">if</span> (ok[i]) cnt++;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">64</span>) &#123;</span><br><span class="line">ans = (<span class="number">1u</span>ll &lt;&lt; <span class="number">63</span>) - n + (<span class="number">1u</span>ll &lt;&lt; <span class="number">63</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> ans = (<span class="number">1u</span>ll &lt;&lt; cnt) - n;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m); read(c); read(k);</span><br><span class="line"><span class="keyword">if</span> (!n &amp;&amp; !m &amp;&amp; k == <span class="number">64</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"18446744073709551616"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">read(a[i]); S |= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">read(p[i]); read(fst);</span><br><span class="line">&#125;</span><br><span class="line">solvebuy();</span><br><span class="line">solveans();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//%lld好像不太行 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7076&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>儒略日[CSP2020]</title>
    <link href="http://akdream.tk/post/51b41b34.html/"/>
    <id>http://akdream.tk/post/51b41b34.html/</id>
    <published>2020-11-09T13:17:16.000Z</published>
    <updated>2020-11-09T13:20:51.347Z</updated>
    
    <content type="html"><![CDATA[<p>题面太长不放</p><p><a href="https://www.luogu.com.cn/problem/P7075" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7075</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="如何优雅地在开考40分钟内完成此题？"><a href="#如何优雅地在开考40分钟内完成此题？" class="headerlink" title="如何优雅地在开考40分钟内完成此题？"></a>如何优雅地在开考40分钟内完成此题？</h4><p>首先最重要的一点：发现1600年之前的闰年规律都是每4年一次，而1600又正好是400的倍数，所以以1600作为分界线，分成1600年前后两种情况比较好处理</p><p>其次，发现0年不存在也不方便，所以把所有的负数年份+1，输出时再改回来</p><p>公元前4913年1月1日是第0天也不方便，所以把 <code>r++</code></p><p>准备工作做好，现在来考虑怎么求解</p><h4 id="一-1600年及以前"><a href="#一-1600年及以前" class="headerlink" title="(一)1600年及以前"></a>(一)1600年及以前</h4><p>如果$r&lt;=M$，那么时间在1600年及以前($M$表示-4713到1600共有多少天)</p><p>发现-4713到1600只有6000多年，所以干脆把每一年的天数都算出来(然后求前缀和方便二分)</p><p>注意的点：</p><ol><li>由于我们把所有的负数年份+1了，所以现在所有模4余0的年份都是闰年</li><li><strong>1582年只有355天！！！</strong> </li></ol><p>求出前缀和后(即-4713年到1600年及之前的某一年一共有多少天)，就可以二分求出究竟是在哪一年的第几天，然后跳转到**(三)**</p><h4 id="二-1600年之后"><a href="#二-1600年之后" class="headerlink" title="(二)1600年之后"></a>(二)1600年之后</h4><p>如果$r&gt;M$，那么时间在1600年之后，让$r$减去$M$</p><p>此时每400年为一个周期，400年一共经过了$366<em>97+365</em>303=146097$天</p><p>算出$p=\lfloor\dfrac{r}{146097}\rfloor$表示一共经过了多少个400年</p><p>$q=r\bmod 146097$表示剩余多少天</p><p><strong>注意！如果$q=0$，为方便后续计算，要让$p$减去1，并将$q$设为$146097$</strong></p><p>之后就同**(一)**一样，预处理出400年中每一年的天数和前缀和，就可以二分求出$q$究竟是在最后余下的不到400年中的哪一年，以及是这年的第几天</p><p>如果二分求得是最后400年中的第$k$年，那么答案年份就应该是$1600+400p+k$</p><p>然后跳转到**(三)**</p><h4 id="三-一年内的判断"><a href="#三-一年内的判断" class="headerlink" title="(三)一年内的判断"></a>(三)一年内的判断</h4><p>现在我们已经确定了答案是哪一年，是这一年的第几天，只需要找出月份和日期即可</p><p>发现$Q\le 10^5$，其实可以算出这一年的12个月各有多少天，然后从一月开始枚举，就很容易算出是几月几日</p><p>注意前面给负数年份加了1，现在要减回来</p><p>注意事项：</p><ol><li>1600年之前的闰年判定和1600年之后不同！注意区分</li><li>1582年的10月只有21天！</li><li>如果你得出的答案是1582年10月5<del>21日，给日期加上10！1582.10.5</del>1582.10.14不存在！</li></ol><p>注意事项3成功导致我100pts -&gt; 40pts /kk</p><p>写多几个函数一定会比全部挤在main函数中条理更清晰</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ttt, M = <span class="number">5000</span>; <span class="comment">//M作为数组的偏移量，防止数组越界 </span></span><br><span class="line">ll n;</span><br><span class="line">ll months[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;, nmonth[<span class="number">13</span>];</span><br><span class="line">ll Aday[<span class="number">10005</span>], Bday[<span class="number">10005</span>]; <span class="comment">//A:1600之前; B:400年的周期 </span></span><br><span class="line">ll days400 = <span class="number">146097</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initrun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">-4712</span>; i &lt;= <span class="number">1600</span>; i++) Aday[i+M] = <span class="number">365</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">-4712</span>; i &lt;= <span class="number">1600</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">Aday[i+M] = <span class="number">366</span>;</span><br><span class="line">&#125;</span><br><span class="line">Aday[<span class="number">1582</span>+M] = <span class="number">355</span>; <span class="comment">//!!!</span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">-4712</span>; i &lt;= <span class="number">1600</span>; i++) Aday[i+M] += Aday[i+M<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">400</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i % <span class="number">400</span> == <span class="number">0</span>) || (i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> != <span class="number">0</span>)) Bday[i] = Bday[i<span class="number">-1</span>] + <span class="number">366</span>;</span><br><span class="line"><span class="keyword">else</span> Bday[i] = Bday[i<span class="number">-1</span>] + <span class="number">365</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printans</span><span class="params">(ll y, ll m, ll d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld BC\n"</span>, d, m, -y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld\n"</span>, d, m, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inyear</span><span class="params">(ll y, ll d)</span> </span>&#123; <span class="comment">//y年的第d天 </span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) nmonth[i] = months[i];</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1582</span>) &#123; <span class="comment">//in 1582 </span></span><br><span class="line">nmonth[<span class="number">10</span>] = <span class="number">21</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &lt;= <span class="number">1600</span>) &#123; <span class="comment">//before 1600</span></span><br><span class="line"><span class="keyword">if</span> (y % <span class="number">4</span> == <span class="number">0</span>) nmonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//after 1600</span></span><br><span class="line"><span class="keyword">if</span> ((y % <span class="number">400</span> == <span class="number">0</span>) || (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>)) &#123; </span><br><span class="line">nmonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= <span class="number">0</span>) y--; <span class="comment">//恢复负数年份 </span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d &lt;= nmonth[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1582</span> &amp;&amp; i == <span class="number">10</span> &amp;&amp; d &gt;= <span class="number">5</span>) d += <span class="number">10</span>; <span class="comment">//100pts-&gt;40pts</span></span><br><span class="line">printans(y, i, d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">d -= nmonth[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(ll x)</span> </span>&#123; <span class="comment">//before 1600</span></span><br><span class="line">ll l = <span class="number">-4712</span>, r = <span class="number">1600</span>, mid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (Aday[mid+M] &gt;= x) &#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">inyear(ans, x - Aday[ans+M<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(ll x)</span> </span>&#123; <span class="comment">//after 1600</span></span><br><span class="line">ll p = x / days400;</span><br><span class="line">ll q = x % days400;</span><br><span class="line"><span class="keyword">if</span> (!q) &#123;</span><br><span class="line">p--; q = days400;</span><br><span class="line">&#125;</span><br><span class="line">ll l = <span class="number">1</span>, r = <span class="number">400</span>, mid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (Bday[mid] &gt;= q) &#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">inyear(<span class="number">1600</span> + p * <span class="number">400</span> + ans, q - Bday[ans<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(ttt);</span><br><span class="line">initrun();</span><br><span class="line"><span class="keyword">while</span> (ttt--) &#123;</span><br><span class="line">read(n); n++; </span><br><span class="line"><span class="keyword">if</span> (n &lt;= Aday[<span class="number">1600</span>+M]) &#123; <span class="comment">//before 1600</span></span><br><span class="line">solve1(n);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//after 1600</span></span><br><span class="line">solve2(n - Aday[<span class="number">1600</span>+M]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题面太长不放&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P7075&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P7075&lt;/a&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩形区域[IOI2019]</title>
    <link href="http://akdream.tk/post/f48e3c0f.html/"/>
    <id>http://akdream.tk/post/f48e3c0f.html/</id>
    <published>2020-11-04T03:31:25.000Z</published>
    <updated>2020-11-04T03:33:01.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://loj.ac/problem/3177" target="_blank" rel="noopener">https://loj.ac/problem/3177</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设某个合法的矩形只有一行，是$a_{1,l}\sim a_{1,r}$，那么显然有这样一个结论成立：$a_{1,l-1}$是$a_{1,r+1}$左侧第一个大于它的 或者$a_{1,r+1}$是$a_{1,l-1}$右侧第一个大于它的</p><p>那么对于一个合法矩形，每一行都应该满足这个条件</p><p>每一列应该也要满足类似的条件</p><p>所以对于一行(或列)，可以通过单调栈来求出所有这样的$[l,r]$</p><p>对于每一行都用这样的方法求出这样的$[l,r]$，用一个<code>vector</code>:$ok[l][r]$来存储所有$a_{i,l}~a_{i,r}$为合法段的$i$</p><p>枚举矩形右边界$r$，并每次更新$lok[u][d]$表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 </p><p>然后枚举矩形左边界$l$，枚举$ok[l][r]$中的每一个连续段$[u,d]$，那么矩形的上下边界在$[u,d]$中时一定是满足行的限制的，只需找出有多少个左右边界为$l,r$，上下边界在$[u,d]$内的矩形满足条件即可</p><p>代码中做了注释</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2520</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N][N], stk[N], cnt, top, ans; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ok[N][N]; <span class="comment">//ok[l][r]: a[l][i]~a[r][i]为合法段的i的集合 </span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp[N]; <span class="comment">//临时存答案 </span></span><br><span class="line"><span class="keyword">int</span> lok[N][N], rok[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//找出所有合法段 </span></span><br><span class="line">cnt = top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (top &amp;&amp; num[i] &gt; num[stk[top]]) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; stk[top] + <span class="number">1</span>) tmp[++cnt] = make_pair(stk[top]+<span class="number">1</span>, i<span class="number">-1</span>); </span><br><span class="line"><span class="comment">//num[l] &lt; num[r]</span></span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (top) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; stk[top] + <span class="number">1</span>) tmp[++cnt] = make_pair(stk[top]+<span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//num[l]&gt;num[r]</span></span><br><span class="line"><span class="keyword">if</span> (num[i] == num[stk[top]]) top--;</span><br><span class="line"><span class="comment">//特殊处理相等情况 </span></span><br><span class="line">&#125;</span><br><span class="line">stk[++top] = i; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123; </span><br><span class="line"><span class="comment">//左右边界为l,r;上下边界在[u,d]内 </span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u - <span class="number">1</span>; i &lt;= d + <span class="number">1</span>; i++) &#123;</span><br><span class="line">a[<span class="number">0</span>][++len] = a[i][r];</span><br><span class="line">&#125;</span><br><span class="line">solve(a[<span class="number">0</span>], len); <span class="comment">//找出列的合法段 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tl = tmp[i].first + u - <span class="number">2</span>, tr = tmp[i].second + u - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (lok[tl][tr] &lt;= l) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">read(a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123; <span class="comment">//预处理ok集合 </span></span><br><span class="line">solve(a[i], m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) ok[tmp[j].first][tmp[j].second].push_back(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt; m; r++)  &#123; <span class="comment">//枚举矩形右边界 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[<span class="number">0</span>][i] = a[i][r];</span><br><span class="line">solve(a[<span class="number">0</span>], n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (rok[tmp[i].first][tmp[i].second] + <span class="number">1</span> &lt; r)</span><br><span class="line">lok[tmp[i].first][tmp[i].second] = r;</span><br><span class="line">rok[tmp[i].first][tmp[i].second] = r;</span><br><span class="line"><span class="comment">//lok[u][d]表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= r; l++) &#123; <span class="comment">//枚举矩形左边界 </span></span><br><span class="line"><span class="keyword">if</span> (!ok[l][r].size()) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> lst = ok[l][r][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ok[l][r].size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ok[l][r][i] &gt; ok[l][r][i<span class="number">-1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//找出ok[l][r]中的一个连续段 </span></span><br><span class="line">calc(l, r, lst, ok[l][r][i<span class="number">-1</span>]);</span><br><span class="line">lst = ok[l][r][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">calc(l, r, lst, ok[l][r][ok[l][r].size()<span class="number">-1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3177&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mr Panda and Survey[HDU6001]</title>
    <link href="http://akdream.tk/post/d3259d46.html/"/>
    <id>http://akdream.tk/post/d3259d46.html/</id>
    <published>2020-10-06T12:25:41.000Z</published>
    <updated>2020-10-08T12:16:08.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6001" target="_blank" rel="noopener">https://acm.hdu.edu.cn/showproblem.php?pid=6001</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设$f(S)$表示有多少种选问卷的情况使得$S$中所有元素都不是好问题</p><p>设$ans[S]$表示选择的问题集合是$S$时，有多少种选择问卷的方案使得它们全部是好问题</p><p>那么由容斥原理，$ans[S]=2^n+\sum\limits_{S_2\subseteq S}(-1)^{t(S)}f(S)$，其中$t(S)$为$S$中元素个数</p><p>考虑如何预处理$f(S)$</p><p>对于每个问卷$x$，设$tag[x]=\sum\limits_{i=1}^{m}2^i[a[x][i]=Y]$，即如果第$i$个问题答案是yes那第$i$位就是$1$</p><p>设$cnt[p]$表示有多少$x$的$cnt[x]=p$</p><p>那么对于一种使得所有问题<strong>都不是好问题</strong>的选择方案，选择的所有问卷的$tag$一定相等</p><p>所以容易得出$f(2^n-1)=1+\sum\limits_{i=0}^{2^m-1}(2^{cnt[i]}-1)$</p><p>最前面那个$1$表示取空集</p><p>假设我们已经算出$f(S)$，考虑$S$去掉一个元素$i$得到的新集合$S_2$</p><p>那么此时$i$是不是好问题就无所谓了，所以可以直接把$i$这一位给“删掉”</p><p>具体实现中，可以对于所有包含$i$的集合$T$，让$cnt[T-i]+=cnt[T]$，然后这个$cnt[T]$就当它不存在，这样就相当于默认第$i$位是$0$(操作A)</p><p>(这里不是做减法，只是表示$T$集合去掉元素$i$)</p><p> 那么对于$f(S_2)$，枚举$S_2$的所有子集$S_3$(显然除了$S_3$以外的那些集合$T$的$cnt[T]$已经被我们当成不存在了)，有$f(S_2)=1+\sum\limits_{S_3\subseteq S_2}(2^{cnt[S_3]}-1)$</p><p>然后考虑用一个dfs，我们已经算出$f(S)$了，这时进行上面那个操作A，然后往$S_2$递归，就能算出$f(S_2)$</p><p>这一步的复杂度是$O(m^3)$的，这样就处理出了所有的$f(S)$</p><p>然后回到上面$ans[S]=2^n+\sum\limits_{S_2\subseteq S}(-1)^{t(S)}f(S)$，这一步的复杂度也是$O(m^3)$的，总时间复杂度为$O(tm^3)$(时限40s?)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>暂时还没有</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://acm.hdu.edu.cn/showproblem.php?pid=6001&quot; targ
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩阵游戏[NOI2013]</title>
    <link href="http://akdream.tk/post/cd282ac6.html/"/>
    <id>http://akdream.tk/post/cd282ac6.html/</id>
    <published>2020-09-27T14:26:06.000Z</published>
    <updated>2020-09-27T14:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足一个神奇的性质：若用$F[i][j]$来表示矩阵中第$i$行第$j$列的元素，则$F[i][j]$满足下面的递推式:</p><p>$$F[1][1]=1$$</p><p>$$F[i,j]=a\times F[i][j-1]+b (j\neq 1)$$</p><p>$$F[i,1]=c\times F[i-1][m]+d (i\neq 1)$$</p><p>递推式中$a,b,c,d$都是给定的常数。</p><p>现在婷婷想知道$F[n][m]$的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出$F[n][m]$除以$1,000,000,007$的余数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑$F[i][1]$和$F[i][m]$之间的关系：</p><p>$$F[i][m]=a(a(\cdots(a\times F[i][1]+b)\cdots)+b)+b$$<br>$$=a^{m-1}\times F[i][1] + a^{m-2}b + a^{m-3}b + \cdots + b$$<br>$$=a^{m-1}\times F[i][1] + \dfrac{a^{m-1}-1}{a-1}\times b$$</p><p>由此可得<br>$$F[i+1][1]=a^{m-1}c\times F[i][1] + \dfrac{a^{m-1}-1}{a-1}\times bc + d$$</p><p>设$A=a^{m-1}c,\ B=\dfrac{a^{m-1}-1}{a-1}\times bc + d$，则</p><p>$$F[i+1][1]=A\times F[i][1]+B$$</p><p>如法炮制，可得</p><p>$$F[n][1]=A^{n-1}\times F[1][1] + \dfrac{A^{n-1}-1}{A-1}\times B$$</p><p>由于$F[1][1]=1$，所以可以先把$F[n][1]$算出来，然后再使用上面那个$F[i][1]$和$F[i][m]$的关系式来推出$F[n][m]$即可</p><p>如何算$a^{m-1}$?</p><p>由于$a^{p-1}\equiv 1 \pmod p$，所以$a^{m-1}\equiv a^{(m-1)\bmod (p-1)} \pmod p$</p><p>那么对$m-1$取模$p-1$后再进行快速幂即可，$A^{n-1}$同理</p><p>注意特判$a=1$或者$A=1$的情况!!!</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">char</span> n[<span class="number">1000005</span>], m[<span class="number">1000005</span>];</span><br><span class="line">ll N, M, _N, _M;</span><br><span class="line">ll a, b, c, d, nl, ml, am, asum, B, A, Am, Asum;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; t; t &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, n + <span class="number">1</span>, m + <span class="number">1</span>);</span><br><span class="line">read(a); read(b); read(c); read(d);</span><br><span class="line">a %= mod; b %= mod; c %= mod; d %= mod;</span><br><span class="line">nl = <span class="built_in">strlen</span>(n + <span class="number">1</span>); ml = <span class="built_in">strlen</span>(m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i++) &#123;</span><br><span class="line">M = (M * <span class="number">10</span> % mod + m[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ml; i++) &#123;</span><br><span class="line">_M = (_M * <span class="number">10</span> % (mod<span class="number">-1</span>) + m[i] - <span class="string">'0'</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nl; i++) &#123;</span><br><span class="line">N = (N * <span class="number">10</span> % mod + n[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nl; i++) &#123;</span><br><span class="line">_N = (_N * <span class="number">10</span> % (mod<span class="number">-1</span>) + n[i] - <span class="string">'0'</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">am = fpow(a, _M<span class="number">-1</span>); <span class="comment">//a^(p-1)==1 (mod p)</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) asum = M - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> asum = (am - <span class="number">1</span>) * fpow(a - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">B = (b * c % mod * asum % mod + d) % mod;</span><br><span class="line">A = am * c % mod;</span><br><span class="line"></span><br><span class="line">Am = fpow(A, _N<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">1</span>) Asum = N - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> Asum = (Am - <span class="number">1</span>) * fpow(A - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">ans = (Am + B * Asum % mod) % mod; <span class="comment">// f[n][1]</span></span><br><span class="line">ans = (am * ans % mod + b * asum % mod) % mod; <span class="comment">//f[n][n]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的$n$行$m$列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>方伯伯的商场之旅[SCOI2014]</title>
    <link href="http://akdream.tk/post/b941660e.html/"/>
    <id>http://akdream.tk/post/b941660e.html/</id>
    <published>2020-09-26T14:05:25.000Z</published>
    <updated>2020-09-26T14:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第$j$堆的石子的数量，刚好是$i$写成$K$进制后的第$j$位。</p><p>现在方伯伯要玩一个游戏，商场会给方伯伯两个整数$L,R$。方伯伯要把位置在$[L,R]$中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量$\times$移动的距离。商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅有一行，包含三个用空格分隔的整数$L$，$R$，$K$，表示商场给方伯伯的两个整数，以及进制数。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个整数，表示最少的代价。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑用$1\sim R$的答案减掉$1\sim L-1$的答案，即$\operatorname{solve}(R) - \operatorname{solve}(L-1)$。</p><p>考虑$\operatorname{solve}(n)$，先计算把每个人的石子都全部合并到第$1$堆所需的代价</p><p>这个是可以通过一次数位dp解决的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(ll d, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs1(d<span class="number">-1</span>, sum + i * (d - <span class="number">1</span>), lim &amp; (i == mx)); </span><br><span class="line"><span class="comment">//第d位有i个石子要移动到第1位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这样一个性质：对于一个人$x$，假设他把所有石子最终全部移到第$k$位，我们把$k$叫做$x$的集合点，这样移动的代价是$f_x(k)$，那么$f_x$一定是一个单谷函数</p><p>不妨把$x$的最优集合点叫做$p_x$</p><p>所以我们可以执行这样的操作：</p><p><code>for i=2~n</code>，每次把所有 “集合点在$i$时比在$i-1$时更优 (即$f_x(i-1)&gt;f_x(i)$)” 的那些$x$的集合点全部从$i-1$变为$i$，也就是说让答案减去$f_x(i-1)-f_x(i)$</p><p>这样一来，由于$f_x$是单谷函数，那么一个人$x$一定在$i=2\sim p_x$的时候集合点被移动，那么$x$的最终代价就会是$f_x(p_x)$，所以这个做法是正确的</p><p>然后考虑如何进行这个”挪动集合点”的操作 其实和上面的那个计算集合点全为1的数位dp区别不大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(ll d, ll sum, ll p, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> max(<span class="number">0l</span>l, sum); <span class="comment">//如果sum&lt;0则说明不把集合点从p-1挪到p比较优</span></span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs2(d<span class="number">-1</span>, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll k, len, a[<span class="number">60</span>];</span><br><span class="line">ll L, R, f[<span class="number">60</span>][<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(ll d, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs1(d<span class="number">-1</span>, sum + i * (d - <span class="number">1</span>), lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(ll d, ll sum, ll p, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!d) <span class="keyword">return</span> max(<span class="number">0l</span>l, sum);</span><br><span class="line"><span class="keyword">if</span> (!lim &amp;&amp; ~f[d][sum]) <span class="keyword">return</span> f[d][sum];</span><br><span class="line">ll ret = <span class="number">0</span>; <span class="keyword">int</span> mx = lim ? a[d] : k<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">ret += dfs2(d<span class="number">-1</span>, sum + (d &lt; p ? -i : i), p, lim &amp; (i == mx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!lim) f[d][sum] = ret;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">ll tmp = n;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">a[++len] = tmp % k;</span><br><span class="line">tmp /= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">ll ret = dfs1(len, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">ret -= dfs2(len, <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;L, &amp;R, &amp;k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(R) - solve(L<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。说来也巧，位置在$i$的人面前的第
      
    
    </summary>
    
    
    
      <category term="数位DP" scheme="http://akdream.tk/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>树的计数[NOI2013]</title>
    <link href="http://akdream.tk/post/c65ab714.html/"/>
    <id>http://akdream.tk/post/c65ab714.html/</id>
    <published>2020-09-23T13:14:37.000Z</published>
    <updated>2020-10-08T12:16:08.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 <code>1 2 4 5 3</code>，BFS 序都是 <code>1 2 3 4 5</code>。</p><p><img src="https://akdream.tk/img/103_1.png" class="lazyload" data-srcset="https://akdream.tk/img/103_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有$K$棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是$h_1,h_2,\cdots,h_K$，那么请你输出：</p><p>$$\dfrac{h_1+h_2+\cdots +h_K}{K}$$</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含$n$个正整数 ，表示树的节点个数。</p><p>第二行包含$n$个正整数，是一个$1\dots n$的排列，表示树的 DFS 序。</p><p>第三行包含$n$个正整数，是一个$1\dots n$的排列，表示树的 BFS 序。</p><p>输入保证至少存在一棵树符合给定的两个序列。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出$1$个实数，四舍五入保留恰好三位小数，表示树高的平均值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于给出的dfs序和bfs序，一定有一种方法给点重新标号，使得bfs序变成$1,2,3,\cdots,n$这个样子</p><p>以样例为例：dfs序为$1,2,4,5,3$，bfs序为$1,2,3,4,5$</p><p>发现深度相同的点，在bfs序中一定是连续一段的，所以原题目可以看作给bfs序进行分段，使得分段后满足dfs序</p><p>样例中$n=5$，有4个分段点</p><p>经过观察，有如下几个分段的限制条件：</p><h3 id="条件一"><a href="#条件一" class="headerlink" title="条件一"></a>条件一</h3><p>深度为1的点一定只有一个(根)，所以$1$后面要进行分段。变为$1 | 2 3 4 5$</p><h3 id="条件二"><a href="#条件二" class="headerlink" title="条件二"></a>条件二</h3><p>设$p[i]$表示$i$在dfs序中在第几个，如$p[3]=5,p[4]=3$</p><p>对于$i \in [1, n)$，如果$p[i]&gt;p[i+1]$，那么有如下两种情况：</p><p>(以样例$p[3]&gt;p[4]$为例)</p><p><img src="https://akdream.tk/img/103_2.png" class="lazyload" data-srcset="https://akdream.tk/img/103_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>得到限制条件：对于$i \in [1, n)$，如果$p[i]&gt;p[i+1]$，那么$i$与$i+1$之间要分段</p><p>样例中，$3$和$4$之间必须要有分割线，即$1|23|45$</p><p>样例中，只有$3$满足$p[i]&gt;p[i+1]$，所以已经确定的必须要有的分割线为$1|23|45$</p><h3 id="条件三"><a href="#条件三" class="headerlink" title="条件三"></a>条件三</h3><p>dfs序为$12453$，$2$后一个为$4$，所以点$4$的深度最多比点$2$多$1$</p><p>在bfs序中，这就等价于说$2$和$4$之间最多有一条分割线</p><p>形式化地，设dfs序数组为$d[N]$，那么对于$i\in [1,n)$，如果$d[i]+1&lt;d[i+1]$，那么在bfs序中$d[i]$与$d[i+1]$之间最多有一条分割线</p><p>发现在样例中，$24$连在一起，那么$3$要不在$2$前面，要不在$4$后面</p><p>如果$3$在$2$前面，那么有$p[2]&gt;p[3]$，出现条件二的情况，$2$和$3$之间必须有分割线</p><p>如果$3$在$4$后面，那么有$p[3]&gt;p[4]$，出现条件二的情况，$3$和$4$之间必须有分割线</p><p>样例中就有$p[3]&gt;p[4]$，所以$3$和$4$之间必须有分割线</p><p>所以可以得出结论：$2$和$4$之间必定至少有一条 由条件二得出的必须存在的分割线</p><p>又因为$2$与$4$之间最多有一条分割线，所以$2\sim 4$之间别的未确定的空隙中就必定是没有分割线的</p><hr><p>以上就是3个分割条件，然后考虑如何实现</p><p>先找出所有的必须存在的分割线(条件一，二)</p><p>样例中必须存在的分割线就是$1|23|45$</p><p>然后根据条件三，$2\sim 4$之间剩余的空隙就不能填分割线，这里也就是$2$和$3$之间的那个空隙一定不能填</p><p>我们把所有 必须填/必须不填 的分割点打上标记，而可以自由选择填或不填的就不打标记</p><p>对于条件一，二，有必须要填的分割线，把必须要填的地方打上标记，并且让答案+1(必须多分割出一层)</p><p>对于条件三，有必须不填的分割线，把必须不填的地方打上差分标记</p><p>然后扫一遍，如果有可以自由选择填或不填的分割点，就让答案加上0.5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;num)</span> </span>&#123;</span><br><span class="line">T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">for</span> (; ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>; ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>; ch = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>);</span><br><span class="line">num = x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N], sum[N];</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); ans = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">read(x); b[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">a[i] = b[a[i]]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">b[a[i]] = i; </span><br><span class="line">&#125;</span><br><span class="line">sum[<span class="number">1</span>]++; sum[<span class="number">2</span>]--; <span class="comment">//ban:1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; b[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//情况1：i后面必须分段</span></span><br><span class="line">ans++;</span><br><span class="line">sum[i]++; sum[i+<span class="number">1</span>]--;  <span class="comment">//ban:i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] + <span class="number">1</span> &lt; a[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//a[i]~a[i+1]只能分一次段， 且肯定至少有一个情况1</span></span><br><span class="line"><span class="comment">//若有大于等于两个情况1则无解 </span></span><br><span class="line">sum[a[i]]++; sum[a[i+<span class="number">1</span>]]--; <span class="comment">//ban:a[i]~a[i+1]-1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">now += sum[i]; <span class="comment">//差分 </span></span><br><span class="line"><span class="keyword">if</span> (!now) ans += <span class="number">0.5</span>; <span class="comment">//now==0表示可以自由选择在i后面分割 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
